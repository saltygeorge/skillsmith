<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}
body {
  margin: 0;
  font-family: "Garamond", serif;
  /* --- NEW BACKGROUND START --- */
  background: #3f2b21; /* Fallback color for dark brick */
  background-image: url('images/brick_background.png');
  background-size: cover; /* Ensures the image covers the entire screen */
  background-attachment: fixed; /* Keeps the background static */
  background-position: center center; /* Centers the background image */
  /* --- NEW BACKGROUND END --- */
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column; /* <-- CHANGED: Now a column layout */
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- +++ NEW: Panel Row Wrappers +++ --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch; /* <-- This makes all 3 panels the same height */
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- +++ NEW: Spacer for Chat Panel +++ --- */
.sidebar-spacer {
  /* This width MUST match the .sidebar width */
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0; /* Prevents it from shrinking */
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  background: var(--panel-bg);
  padding: 16px;
  border-radius: 10px; /* Slightly less rounded */
  /* Worn/Sturdy Shadow: Inner shadow for depth, outer shadow for lift */
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  /* Strong, dark border for a rustic frame look */
  border: 4px solid #453625;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.char-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px; /* <-- GUARANTEED: Sets all main h2s to 20px */
}

.hp-bar { background: #772222; border-radius: 6px; overflow: hidden; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start; /* keep content at top */
}

/* Equipment slots vertically centered between tabs and bottom */
#equipmentTab {
  display: flex;
  flex-direction: column;
  justify-content: center;
  flex-grow: 1;
  padding-top: 70px; /* lowers them a bit */
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { display: flex; flex-direction: column; align-items: center; }
.equipment-row { display: flex; justify-content: center; margin: 6px 0; gap: 10px; }
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden; /* prevent side scroll */
  padding-right: 0; /* <-- MODIFIED: Removed 6px padding */
  
  /* --- NEW: For Firefox --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  /* --- FIX: Use auto-fit to force 4 columns within the space. --- */
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  /* Ensure padding is uniform and matches the gap */
  padding: var(--slot-gap); 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  /* +++ NEW: Add cursor pointer for items +++ */
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 2000;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- +++ NEW: Custom Scrollbar for WebKit (Chrome, Safari) +++ --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px; /* Sets the width of the scrollbar */
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2); /* Dark, subtle track background */
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent); /* Uses your game's accent color for the handle */
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover); /* Uses your hover color */
}
/* --- +++ END: Custom Scrollbar +++ --- */


/* --- Main area (MODIFIED) --- */
.main {
  flex: 1; /* <-- RE-ADDED: To fill the middle space */
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px; /* Slightly less rounded */
  /* Worn/Sturdy Shadow: Inner shadow for depth, outer shadow for lift */
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  /* Strong, dark border for a rustic frame look */
  border: 4px solid #453625;
  min-height: 500px; 
  position: relative;
}

/* +++ NEW CHAT PANEL STYLE (MODIFIED) +++ */
.chat-panel {
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  display: flex; 
  flex-direction: column;
  min-height: 200px; /* Give it a minimum height */
  flex-shrink: 0;
  flex: 1; /* <-- ADDED: To fill the middle space in its row */
}

/* --- THIS IS THE CHAT MESSAGES DIV --- */
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  
  /* --- NEW: For Firefox --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}

#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}
/* --- END CHAT STYLES --- */


.progress-container {
  background: #7c644c; /* NEW: Lighter, muted tan/brown */
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}
.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }

.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }

button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}
button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

@media(max-width:900px) {
  /* MODIFIED for new structure */
  .container { flex-direction: column; align-items: center; }
  
  /* Make all panels full width and stack */
  #top-row-panels, #bottom-row-chat {
      flex-direction: column;
      width: 95%;
  }
  .sidebar, .main, .chat-panel { 
      width: 100%; /* Make them fill the 95% wrapper */
      box-sizing: border-box;
  }
  /* Hide the spacers on mobile */
  .sidebar-spacer {
      display: none;
  }
}

/* --- +++ NEW TRADE MODAL STYLES +++ --- */
#tradeModal {
  display: none; /* Changed by JS */
}

.trade-content {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}

.trade-main-area {
  display: flex;
  gap: 20px;
  flex: 1; /* Make it fill the vertical space */
}

.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}

.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img {
  width: 30px;
  height: 30px;
}

/* Make trade inventory scrollable */
#tradeInventoryGridWrap {
  flex: 1; /* This makes it fill the panel's height */
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  
  /* --- NEW: For Firefox --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

/* Make trade offer grids fixed size */
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}

/* This makes empty offer slots visible */
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}

.trade-offer-layout {
  display: flex;
  gap: 20px;
}

.trade-offer-box {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}

#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}

.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
/* --- +++ END TRADE MODAL STYLES +++ --- */
</style>
</head>
<body>

<div id="authScreen" style="display:flex; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header">
          <h2 id="charName">Player</h2>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-row">
                  <div class="equipment-slot" id="helmet">
                    <img src="images/helmet.png" alt="Helmet">
                  </div>
                </div>
                <div class="equipment-row" style="align-items:center;">
                  <div class="equipment-slot" id="weapon">
                    <img src="images/weapon.png" alt="Weapon">
                  </div>
                  <div class="equipment-slot" id="chest">
                    <img src="images/chestplate.png" alt="Chest">
                  </div>
                </div>
                <div class="equipment-row">
                  <div class="equipment-slot" id="boots">
                    <img src="images/boots.png" alt="Boots">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
              <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
                <img src="images/goldpouch.png" alt="Gold" style="width: 60px; height: 60px; object-fit: contain;">
                <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 8px;">0</span>
              </div>
              
            </div>
            
          </div>
          <div id="skillsTab" style="display:none;">
            <div style="font-size:14px; margin-bottom:8px;">Skills</div>
            <div>Mining: <span id="miningLevel">1</span> — XP: <span id="miningXP">0</span> / <span id="nextXP">100</span> (Total: <span id="miningTotalXP">0</span>)</div>
          </div>
        </div>
      </div>

      <div class="main" id="mainArea">
        <div id="mainContentWrapper">
          <div id="actionScreen">
  <img src="images/mines.png" 
       alt="Mines" 
       onclick="openMineHub()" 
       onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Mines</div>')" 
       onmouseleave="hideTooltip()" 
       style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
</div>
        </div>
        <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>
      </div>

    </div> <div id="bottom-row-chat">

      <div class="sidebar-spacer"></div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div class="sidebar-spacer"></div>

    </div> </div> </div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>
<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  inventory: {},
  inventoryCapacity: 39,
  gold: 0, 
  // MODIFIED: Added totalXP
  mining: { level: 1, xp: 0, totalXP: 0 },
  miningActive: false,
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, // <-- +++ NEW: For Shop
  isAdmin: false,
  
  // +++ ADDED FOR TRADE +++
  inTrade: false,
  activeTradeSessionId: null,
  activeTradeListener: null, // To unsubscribe later
  myTradeRole: null, // <-- +++ FIX 1: ADDED THIS +++
  myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
  theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};

// +++ ADD THIS NEW ARRAY +++
const VALID_ITEMS = [
  'Copper Ore'
  // As you add more items, add their exact names here
];

// --- All your original game functions (setText, formatAmount, etc.) are unchanged ---
function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) {
    return n.toString();
  }
  if (n < 1000000) {
    const val = (n / 1000).toFixed(2);
    return parseFloat(val) + 'k';
  }
  const val = (n / 1000000).toFixed(2);
  return parseFloat(val) + 'M';
}

// --- MODIFIED createCharacter ---
function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  backToActions(); 
}

function updateHPUI(){
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}

// --- NEW FUNCTIONS FOR GOLD ---
function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount); // Prevents negative gold
  updateGoldUI();
}
// --- END NEW FUNCTIONS ---

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;
  const entries = Object.entries(game.inventory);
  const slots = new Array(capacity).fill(null);

  for(let i=0;i<entries.length && i<capacity;i++){
    slots[i] = { name: entries[i][0], qty: entries[i][1] };
  }

  for(let i=0;i<capacity;i++){
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    if(slots[i]){
      const item = slots[i];
      const img = document.createElement('img');
      const imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      
      // +++ NEW: Add click handler for selling +++
      slot.onclick = () => {
        handleSellItemClick(item.name, item.qty);
      };
      
    }
    grid.appendChild(slot);
  }
}
function addItem(name, qty=1){
  if(!game.inventory[name]) game.inventory[name]=0;
  game.inventory[name]+=qty;
  renderInventoryGrid();
}

// +++ NEW: removeItem function +++
function removeItem(name, qty = 1) {
  if (!game.inventory[name]) {
    console.warn(`Tried to remove item not in inventory: ${name}`);
    return;
  }
  game.inventory[name] -= qty;
  if (game.inventory[name] <= 0) {
    delete game.inventory[name];
  }
}

// +++ NEW: handleSellItemClick function +++
function handleSellItemClick(itemName, currentQty) {
  // 1. Check if shop is open
  if (!game.shopOpen) {
    return; // Do nothing if shop isn't open
  }
  
  // 2. Define prices
  let sellPrice = 0;
  if (itemName === 'Copper Ore') {
    sellPrice = 1;
  } else {
    alert("This shop doesn't buy that item.");
    return;
  }
  
  // 3. Get quantity
  let qtyToSell = 0;
  if (currentQty === 1) {
    qtyToSell = 1;
  } else {
    const input = prompt(`How many ${itemName} do you want to sell? (You have: ${currentQty})`, currentQty);
    if (input === null) return; // User cancelled
    qtyToSell = parseInt(input);
  }
  
  // 4. Validate quantity
  if (isNaN(qtyToSell) || qtyToSell <= 0) {
    return; // Invalid number
  }
  if (qtyToSell > currentQty) {
    alert("You don't have that many to sell.");
    return;
  }
  
  // 5. Confirm sale
  const totalGold = qtyToSell * sellPrice;
  const confirmed = confirm(`Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`);
  
  // 6. Execute sale
  if (confirmed) {
    removeItem(itemName, qtyToSell);
    addGold(totalGold); // This already updates the gold UI
    
    hideTooltip(); // <-- +++ THIS IS THE FIX +++
    
    renderInventoryGrid(); // Manually re-render inventory UI
    
    // Also re-render trade inventory if it's open (it shouldn't be)
    if (game.inTrade) {
      renderTradeInventory();
    }
    
    alert(`You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`);
  }
}


const tooltip = document.getElementById('tooltip');

function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}

function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}

function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){ return Math.floor(100 * Math.pow(1.15, level-1)); }

function getTotalXPForLevel(level) {
    let total = 0;
    for(let i = 1; i < level; i++) {
        total += getNextXP(i);
    }
    return total;
  }

function updateSkillUI(){
  setText('miningLevel', game.mining.level);
  setText('miningXP', game.mining.xp);
  setText('nextXP', getNextXP(game.mining.level));
  setText('miningTotalXP', game.mining.totalXP); 
}

function addXP(skill, amount){
  game[skill].totalXP += amount; 
  game[skill].xp += amount;
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
  }
  updateSkillUI();
  const main = document.getElementById('mainArea');
  const popup = document.createElement('div');
  popup.className = 'xp-popup';
  popup.innerText = `+${amount} ${skill.toUpperCase()} XP`;
  const bar = document.getElementById('mineProgress');
  if (bar) {
    const barRect = bar.getBoundingClientRect();
    const mainRect = main.getBoundingClientRect();
    const relativeX = barRect.left - mainRect.left;
    const relativeY = barRect.top - mainRect.top;
    popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
    popup.style.top = (relativeY - 30) + 'px';
  } else {
    popup.style.left = '50%';
    popup.style.top = '120px';
    popup.style.transform = 'translateX(-50%)';
  }
  main.appendChild(popup);
  setTimeout(()=>popup.remove(), 900);
}

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

// --- PASTE THIS ENTIRE BLOCK ---

function startMining() {
  if (game.miningActive) return; // Don't start if already mining
  game.miningActive = true;
  
  // Hide start, show stop
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';

  // Start the loop
  game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; // Stop the loop if flag is false

  const elapsed = timestamp - startTime;
  let progress = (elapsed / MINE_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Action Complete ---
    addItem(MINE_ITEM, 1);
    addXP('mining', MINE_XP);
    
    // Reset for next loop
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now)); // Loop
  } else {
    // --- In Progress ---
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, startTime)); // Continue
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);

  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';

  // --- This is the fix: Check if buttons exist first ---
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
}

// 1. This is your OLD "openMine" function, but RENAMED and with one small change.
function openCopperMine(){
  game.shopOpen = false; // <-- +++ NEW: Reset shop state
  hideTooltip();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Beginner Mine - Copper vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A low level copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
}

// 2. This is the NEW function for the mine selection screen.
function openMineHub() {
  game.shopOpen = false; // <-- +++ NEW: Reset shop state
  hideTooltip();
  stopMining(); // Stop any mining action when leaving the mine
  const wrapper = document.getElementById('mainContentWrapper');
  
  // 1. Set the simple HTML, giving the buttons unique IDs
  wrapper.innerHTML = `
    <h2>Mines</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose a mine to enter.</div>
    
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
      
      <button id="copperVeinBtn" 
              class="primary" 
              style="display: flex; align-items: center; gap: 10px;">
        
        <img src="images/coppervein.png" 
             alt="Copper Vein" 
             style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
             
        <span>Copper Vein</span>
      </button>
      
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  
  // 2. Find the new buttons you just created
  const copperBtn = document.getElementById('copperVeinBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');

  // 3. Attach all events directly using JavaScript
  if (copperBtn) {
    copperBtn.onclick = openCopperMine;
    
    // --- THIS IS THE NEW TOOLTIP YOU REQUESTED ---
    copperBtn.onmouseenter = (event) => {
      showTooltip(event, 'Lvl Required: 1');
    };
    copperBtn.onmouseleave = hideTooltip;
  }
  
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}


function backToActions(){
  game.shopOpen = false; // <-- +++ NEW: Reset shop state
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('mainContentWrapper');

  // 1. Set the simple HTML, giving the image a unique ID
  // +++ MODIFIED: Added shop button +++
  wrapper.innerHTML = `
    <div id="actionScreen" style="display: flex; gap: 10px;">
      <img id="minesActionIcon" 
           src="images/mines.png" 
           alt="Mines" 
           style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
           
      <img id="shopActionIcon" 
           src="images/shopbutton.png" 
           alt="Shop" 
           style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
    </div>
  `;

  // 2. Find the new element you just created
  const minesIcon = document.getElementById('minesActionIcon');
  const shopIcon = document.getElementById('shopActionIcon'); // <-- +++ NEW

  // 3. Attach the events directly using JavaScript
  if (minesIcon) {
    minesIcon.onclick = openMineHub;
    minesIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Mines</div>');
    };
    minesIcon.onmouseleave = hideTooltip;
  }
  
  // +++ NEW: Attach shop icon events +++
  if (shopIcon) {
    shopIcon.onclick = openShop; // <-- New function
    shopIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
    };
    shopIcon.onmouseleave = hideTooltip;
  }
}

// +++ NEW: openShop function +++
function openShop() {
  hideTooltip();
  stopMining();
  game.shopOpen = true; // <-- SET STATE
  const wrapper = document.getElementById('mainContentWrapper');
  
  wrapper.innerHTML = `
    <h2>General Store</h2>
    <div style="margin-top:8px; color:#efe3cf;">
      Click an item in your inventory to sell it.
    </div>
    <div style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.1); border-radius:6px;">
      <strong>Items you can sell:</strong>
      <ul style="margin: 5px 0 0 20px; padding: 0;">
        <li style="margin-top:5px;">Copper Ore - 1 Gold each</li>
      </ul>
    </div>
    
    <div class="action-buttons" style="margin-top:14px;">
      <button id="returnToActionsBtn" class="primary" style="background:#666;">Return</button>
    </div>
  `;
  
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}


// --- MODIFIED resetGameState ---
function resetGameState() {
  if (game.miningActive) {
    stopMining(); 
  }
  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = {};
  game.gold = 0; 
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.miningActive = false;
  game.shopOpen = false; // <-- +++ NEW
  game.isAdmin = false;
  if (game.progressFrame) {
    cancelAnimationFrame(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('equipment');
  }
}

document.addEventListener('DOMContentLoaded', ()=>{
  showTab('equipment');
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
});
</script>

<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  // +++ MODIFIED CHAT/TRADE IMPORTS +++
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";
  
  // --- Your Firebase config (Unchanged) ---
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // DOM refs (Unchanged)
  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // --- MODIFIED savePlayerData ---
  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      const nameToSave = game.name || ""; 
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: game.inventory || {},
        gold: game.gold, // <-- ADDED
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        updatedAt: new Date().toISOString()
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- MODIFIED loadPlayerDataAndStart ---
  async function loadPlayerDataAndStart(user) {
    try {
      const ref = doc(db, "players", user.uid);
      const snap = await getDoc(ref);
      if (!snap.exists() || !snap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false;
      }
      const data = snap.data();
      game.name = data.name || game.name || "Adventurer";
      game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
      game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
      game.inventory = data.inventory || {};
      game.gold = (typeof data.gold === 'number') ? data.gold : 0; // <-- ADDED
      if (data.mining) {
        game.mining.level = data.mining.level || game.mining.level;
        game.mining.xp = data.mining.xp || game.mining.xp;
        game.mining.totalXP = data.mining.totalXP || 
                              (data.mining.level > 1 ? getTotalXPForLevel(data.mining.level - 1) + data.mining.xp : data.mining.xp) || 0; 
      }
      document.getElementById('charName').innerText = game.name;
      startScreen.style.display = 'none';
      authScreen.style.display = 'none';
      gameScreen.style.display = 'block';
      updateHPUI();
      renderInventoryGrid();
      updateSkillUI();
      updateGoldUI(); // <-- ADDED
      window.renderLeaderboards(); 
      backToActions();
      return true;
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }


  // --- MODIFIED registerBtn.onclick ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: {},
        gold: 0, // <-- ADDED
        mining: { level: 1, xp: 0, totalXP: 0 },
        createdAt: new Date().toISOString()
      });
      alert("Account created. Now create your character."); 
    } catch (err) {
      alert(err.message || "Registration failed.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      alert(err.message || "Login failed."); 
      console.error(err);
    }
  };

  // +++ MODIFIED Auth state listener (FOR TRADE) +++
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      // --- Detach old trade listeners ---
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); // <-- Changed
      tradeSessionUnsubscribes = []; // <-- Changed

      const started = await loadPlayerDataAndStart(user);
      
      // +++ ADD THIS BLOCK +++
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
      }
      // +++ END OF BLOCK +++
      
      if (started) {
        initChatListener();
        initTradeListeners(); // <--- +++ ADDED THIS LINE +++
      } else {
        // Show create-character screen
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // No user => show auth UI
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      if (window.resetGameState) {
        window.resetGameState();
      }
      // --- Detach listeners on logout ---
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); // <-- Changed
      tradeSessionUnsubscribes = []; // <-- Changed
      
      isTradeRequestsLoaded = false; // <--- +++ THIS IS THE FIX +++
    }
  });

  // +++ MODIFIED createCharacter PATCH (FOR TRADE) +++
  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) return alert('Enter a name first.');
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            return alert("That name is already taken. Please choose another.");
          }
        } catch (e) {
          console.error("Name check failed:", e);
          return alert("Error checking name. Please try again.");
        }
        
        originalCreate();
        
        const user = auth.currentUser;
        if (user) {
          await window.savePlayerData();
          window.renderLeaderboards();
          initChatListener(); // Start chat for new player
          initTradeListeners(); // <--- +++ ADDED THIS LINE +++
        }
      };
    }
  })();
  
  // +++ NEW CHAT FUNCTIONS START +++
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false;
  /**
   * Sends a new chat message OR handles a chat command.
   */
  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;

    if (messageText.length === 0) return; // Don't send empty messages

    // Clear the input field *first*
    chatInput.value = '';

    // --- COMMAND HANDLING ---
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; // Command was handled (or failed)
    }

    // --- REGULAR CHAT MESSAGE ---
    if (messageText.length > 256) {
      alert("Message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      alert("You must be logged in and have a character to chat.");
      return;
    }

    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      alert("Failed to send message. Please try again.");
    }
  }

function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;

    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';

    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; // Green for system
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; // Gold for trade
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; // Red for errors
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    
    chatMessagesContainer.prepend(msgElement); // Add to top (which is the visual bottom)
  }

  /**
   * Initializes the real-time listener for the chat.
   */
  function initChatListener() {
    // --- Unsubscribe from old listener if it exists ---
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }

    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;

    // Create a query to get the last 25 messages, ordered by time
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );

    // onSnapshot creates a real-time listener
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      
      let hasAdds = false; // Flag for messages *in this snapshot*

      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          
          // Only add messages if this is *after* the initial load.
          // The initial load is handled by the 'if (!isChatHistoryLoaded)' block.
          if (isChatHistoryLoaded) {
            hasAdds = true; // Mark that we are adding messages
            
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';

            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            
            const text = document.createTextNode(msg.text);

            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            
            // Prepend to show new messages at the top (since container is column-reverse)
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });

      // --- THIS IS THE NEW FIX ---
      // This block runs *only once* on the initial load.
      if (!isChatHistoryLoaded) {
        
        // 1. Mark as loaded *immediately*. This is the critical fix.
        isChatHistoryLoaded = true;
        
        let hadHistoryMessages = false;
        
        // 2. Process the *full snapshot* for the initial history.
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';

            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            
            const text = document.createTextNode(msg.text);

            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            
            chatMessagesContainer.prepend(msgElement);
        });

        // 3. Process the queue.
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; // Clear the queue
        
        // 4. Scroll to bottom (visual top) *once* after all loading.
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        
        // 5. Clean up DOM to prevent overflow from history + queue
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      // After the first load, if new messages came in (`hasAdds` is true)
      // we'll just let them prepend.
      else if (hasAdds) {
        // This is a new message, keep the chatbox trimmed
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        // And scroll to the bottom
        chatMessagesContainer.scrollTop = 0;
      }

    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  // +++ NEW CHAT FUNCTIONS END +++


  // +++ NEW TRADE FUNCTIONS START +++

  // --- State variables for trade ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; // <-- Changed to an array

  /**
   * Adds a message to the local chat UI (not to Firestore).
   * Used for system messages, whispers, and trade notifications.
   */
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;

    if (!isChatHistoryLoaded) {
      // History hasn't loaded, add to queue
      localMessageQueue.push({ text, type });
    } else {
      // History is loaded, add directly to DOM
      _addLocalMessageToDOM(text, type);
      
      // Keep it trimmed
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      // Scroll to bottom (which is visual top for column-reverse)
      chatMessagesContainer.scrollTop = 0;
    }
  }


  /**
   * Handles chat commands (messages starting with '/')
   * Returns true if it was a command, false otherwise
   */
  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;

    // --- +++ NEW ADMIN COMMANDS (TARGETED) +++ ---
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);

        // --- /givegold [playername] [amount] ---
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);

            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }

            // --- Target is self ---
            if (targetName === game.name.toLowerCase()) {
                addGold(amount);
                addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                return true;
            }

            // --- Target is another player ---
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                const newGold = (playerData.gold || 0) + amount;
                
                await updateDoc(doc(db, "players", playerDoc.id), { gold: newGold });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
                
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        
        // --- /giveitem [playername] [Item Name] [amount] ---
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); // Get item name from middle
            
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');

            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; // Stop the command
            }

            // --- Target is self ---
            if (targetName === game.name.toLowerCase()) {
                addItem(formattedName, qty);
                addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                return true;
            }

            // --- Target is another player ---
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                const newInventory = playerData.inventory || {};
                newInventory[formattedName] = (newInventory[formattedName] || 0) + qty;
                
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newInventory });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');

            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        
        // --- /setlevel [playername] [skill] [level] ---
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            
            if (skill !== 'mining') {
                 addLocalChatMessage("Unknown skill. Only 'mining' is supported.", 'error');
                 return true;
            }
            
            const newTotalXP = getTotalXPForLevel(level); // Use the global function
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };

            // --- Target is self ---
            if (targetName === game.name.toLowerCase()) {
                game.mining = newSkillData;
                updateSkillUI();
                addLocalChatMessage(`Admin: Set own Mining level to ${level}.`, 'system');
                return true;
            }
            
            // --- Target is another player ---
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { mining: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s Mining level to ${level}.`, 'system');

            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
    }
    // --- +++ END OF ADMIN COMMANDS +++ ---


    if (messageText.startsWith('/trade ')) {
      const targetName = messageText.substring(7).trim();
      if (targetName.toLowerCase() === game.name.toLowerCase()) {
        addLocalChatMessage("You cannot trade with yourself.", 'error');
        return true;
      }
      if (game.inTrade) {
        addLocalChatMessage("You are already in a trade.", 'error');
        return true;
      }
      addLocalChatMessage(`Sending trade request to ${targetName}...`, 'system');
      await initiateTradeRequest(targetName);
      return true;
    }

    if (messageText.startsWith('/accepttrade ')) {
      const requesterName = messageText.substring(13).trim(); // <-- FIX: Changed 14 to 13
      if (game.inTrade) {
        addLocalChatMessage("You are already in a trade.", 'error');
        return true;
      }
      addLocalChatMessage(`Attempting to accept trade from ${requesterName}...`, 'system');
      await acceptTradeRequest(requesterName);
      return true;
    }
    
    return false; // Not a recognized command
  }

  /**
   * (1) Initiator: Finds a player and creates a 'tradeRequest' doc.
   */
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }

      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();

      // Create the request
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });

      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');

    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }

  /**
   * (2) Accepter: Finds a pending request and creates the 'tradeSession'.
   */
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      
      // Find the player doc for the requester to get their name_lowercase and UID
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);

      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();

      const sixtySecondsAgo = new Date(Date.now() - 60000);

      // 1. Query only on fields validated by security rules (toUid) and status.
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      
      const requestSnapshot = await getDocs(requestQuery);

      // 2. Filter the results in JavaScript to find the specific request
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          
          // Time check removed to fix clock-sync bug
          return data.fromUid === requesterUid; // Just check if it's from the right person
      });

      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }

      const requestDoc = validRequests[0]; // Get the first valid request

      // --- Create the Trade Session ---
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };

      // Use a batch write to create the session AND update the request
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      
      await batch.commit();

      // State is now 'active', the listeners will pick it up and open the window
      // The openTradeWindow() call is handled by the initTradeListeners
      
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }


  /**
   * (3) Listens for new trade requests AND active trade sessions.
   * This is called once on successful login.
   */
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;

    // --- Unsubscribe from old listeners if they exist ---
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); // <-- Changed
    tradeSessionUnsubscribes = []; // <-- Changed

    isTradeRequestsLoaded = false; // <--- +++ 1. RESET THE FLAG

    // --- Listener 1: For new incoming trade requests ---
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    
    tradeRequestUnsubscribe = onSnapshot(requestQuery, (snapshot) => {
      
      snapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          
          // --- THIS IS THE FIX ---
          // Only show messages if this is *NOT* part of the initial load.
          if (isTradeRequestsLoaded) {
            const request = change.doc.data();
            addLocalChatMessage(
              `${request.fromName} sent you a trade request. Type '/accepttrade ${request.fromName}' to accept.`,
              'trade'
            );
          }
          // --- END OF FIX ---
        }
      });

      // --- THIS IS THE SECOND PART OF THE FIX ---
      // After the *first* snapshot has been processed, set the flag to true.
      // Any *future* 'added' events will now be displayed.
      isTradeRequestsLoaded = true;
      // --- END OF FIX ---

    }, (error) => console.error("Trade request listener error:", error));

    // --- Listener 2: For active trade SESSIONS I am part of ---
    // (This part is unchanged)
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) // <-- CHANGED
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) // <-- CHANGED
    );
    
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          // --- This is the original logic for starting a new trade ---
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          // --- +++ THIS IS THE NEW FIX +++ ---
          // This creates a second, more reliable check for a cancellation.
          
          // Check if this cancellation is for the trade we are *currently* in
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    
    tradeSessionUnsubscribes.push( // <-- Changed
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( // <-- Changed
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  
  /**
   * (4) Opens the trade modal and attaches the main session listener.
   */
function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; // Should not happen, but a good check

// --- +++ NEW MINING FIX +++ ---
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }

    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };

    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    game.myTradeRole = myRole; // <-- +++ FIX 2: SAVE THE ROLE +++
    
    // Set UI elements
    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    document.getElementById('tradeMyGoldOffer').value = 0;
    document.getElementById('tradeMyGoldOffer').max = game.gold;

    renderTradeInventory(); // Render my inventory
    renderOfferGrid('tradeMyOfferGrid', {}); // Clear my offer
    renderOfferGrid('tradeTheirOfferGrid', {}); // Clear their offer
    
    modal.style.display = 'flex'; // Show the modal

    // --- Attach the one, powerful listener for this session ---
    if (game.activeTradeListener) game.activeTradeListener(); // Unsub from old one
    
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      
      const data = doc.data();
      
      // --- Check status ---
      if (data.status === 'cancelled') {
        // Show the error message if one exists
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      
      if (data.status === 'completed') {
        // --- +++ THIS IS THE NEW LOGIC +++ ---
        // The trade was verified by executeTrade. Now we apply it.
        
        try {
          // 1. Get final offers
          const myOffer = data[myRole];
          const theirOffer = data[theirRole];

          // 2. Apply changes to local game state
          
          // Apply Gold
          game.gold = (game.gold - myOffer.offerGold) + theirOffer.offerGold;
          if (game.gold < 0) game.gold = 0; // Safety check

          // Remove my offered items
          for (const [item, qty] of Object.entries(myOffer.offerItems)) {
            if (game.inventory[item]) {
              game.inventory[item] -= qty;
              if (game.inventory[item] <= 0) {
                delete game.inventory[item];
              }
            }
          }
          
          // Add their offered items
          for (const [item, qty] of Object.entries(theirOffer.offerItems)) {
            game.inventory[item] = (game.inventory[item] || 0) + qty;
          }

          // 3. Save *my* data (this is allowed by security rules)
          window.savePlayerData();
          
          addLocalChatMessage("Trade complete!", 'trade');
          
        } catch (e) {
          console.error("Error applying trade results:", e);
          addLocalChatMessage("Trade complete, but an error occurred updating your inventory. Please reload.", 'error');
        }
        
        // 4. Close window (this also refreshes UI)
        closeTradeWindow();
        return;
      }
      
      // --- Update Offers ---
      game.myTradeOffer = data[myRole];
      game.theirTradeOffer = data[theirRole];

      // Re-render both offer grids
      renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      
      // Update gold
      // Don't update the input if the user is currently typing in it
      if (document.activeElement !== document.getElementById('tradeMyGoldOffer')) {
         document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
      }
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // --- Update Accept Status ---
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);

      // --- Check for Trade Completion ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        // Both accepted! Disable buttons
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        
        // Only one player (player1) should execute the trade to prevent conflicts
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });

    // --- Attach button click handlers ---
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  
  /**
   * (5) Helper: Renders the player's inventory into the trade modal.
   */
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';
    
    Object.entries(game.inventory).forEach(([name, qty]) => {
      const itemInOffer = game.myTradeOffer.offerItems[name] || 0;
      const qtyAvailable = qty - itemInOffer;
      
      if (qtyAvailable <= 0) return; // All are in the offer

      const slot = document.createElement('div');
      slot.className = 'inv-slot';
      slot.onclick = () => addItemToOffer(name, qtyAvailable); // Pass full available qty
      
      const img = document.createElement('img');
      const imgName = name.toLowerCase().replace(/\s+/g,'_');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slot.appendChild(amt);
      
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
      
      grid.appendChild(slot);
    });
  }

  /**
   * (6) Helper: Renders an offer grid (4x4).
   */
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    
    const itemEntries = Object.entries(items);

    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        
        const img = document.createElement('img');
        const imgName = name.toLowerCase().replace(/\s+/g,'_');
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
        
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  
  /**
   * (7) Helper: Updates the 'accepted' text and color.
   */
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }

  /**
   * (8) Action: Player clicks to add an item to their offer.
   */
  async function addItemToOffer(itemName, maxQty) {
  console.log(`addItemToOffer CALLED: item=${itemName}, maxQty=${maxQty}`);
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      const input = prompt(`How many ${itemName} do you want to offer? (Max: ${maxQty})`, maxQty);
      if (input === null) return; // User cancelled
      qtyToOffer = parseInt(input);
    }
    
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      alert(`You can only offer up to ${maxQty} of this item.`);
      qtyToOffer = maxQty;
    }

    // Check if offer grid is full
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      alert("Your trade offer grid is full (16 unique items).");
      return;
    }

    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    
    // --- +++ FIX 3: USE THE SAVED ROLE +++ ---
    const myRole = game.myTradeRole;
    if (!myRole) return; // Safety check
    
    // --- Create a new *full* offer object ---
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };

    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; // Send the full object
    
    // Reset the *other* player's accepted status too
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      renderTradeInventory(); // Re-render inventory locally
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }

  /**
   * (9) Action: Player clicks to remove an item from their offer.
   */
  /**
   * (9) Action: Player clicks to remove an item from their offer.
   */
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; // <-- TYPO FIXED
    delete newOfferItems[itemName]; // Remove the entire stack
    
    // --- +++ FIX 4: USE THE SAVED ROLE +++ ---
    const myRole = game.myTradeRole;
    if (!myRole) return; // Safety check
    
    // --- Create a new *full* offer object ---
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };

    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; // Send the full object

    // Reset the *other* player's accepted status too
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      renderTradeInventory(); // Re-render inventory locally
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }

  /**
   * (10) Action: Player changes their gold offer.
   */
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    
    // --- +++ FIX 5: USE THE SAVED ROLE +++ ---
    const myRole = game.myTradeRole;
    if (!myRole) return; // Safety check
    
    // --- Create a new *full* offer object ---
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };

    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; // Send the full object
    
    // Reset the *other* player's accepted status too
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }

  /**
   * (11) Action: Player clicks the 'Accept' button.
   */
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; // Prevent double-click
    
    // --- +++ FIX 6: USE THE SAVED ROLE +++ ---
    const myRole = game.myTradeRole;
    if (!myRole) return; // Safety check
    
    // --- Create a new *full* offer object ---
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true // Set this player as accepted
    };

    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; // Send the full object
    
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }

  /**
   * (12) Action: Player clicks the 'Cancel' button.
   */
  async function cancelTrade() {
    // --- Disable buttons immediately ---
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;

    // --- NEW LOGIC: Close locally *first* ---

    // 1. Get the session ID *before* we clear it
    const sessionId = game.activeTradeSessionId;
    
    // 2. Close our *own* window immediately.
    // This is synchronous. It MUST happen *before* any await.
    // This sets game.inTrade = false and unsubscribes the listener.
    closeTradeWindow(); 
    
    // 3. *Now*, tell the server to cancel the trade.
    // The *other* player's listener will pick this up.
    // Our own listener is already detached, so no race condition.
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
        // We don't need to call closeTradeWindow() here,
        // because it was already called.
      }
    }
  }

  /**
   * (13) Action: Closes the trade window and resets state.
   */
  function closeTradeWindow() {
    if (!game.inTrade) return; // <-- +++ ADD THIS LINE +++
    if (game.activeTradeListener) {
      game.activeTradeListener(); // Unsubscribe
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; // <-- +++ FIX 7: CLEAR THE ROLE +++
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    
    // Refresh main game UI
    renderInventoryGrid();
    updateGoldUI();

    // --- +++ NEW MINING FIX +++ ---
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      
      // Check if we are still on the mining screen
      const startBtn = document.getElementById('startMineBtn');
      if (startBtn) {
        startMining();
      }
      // If startBtn doesn't exist, we're not on the mining screen,
      // so we correctly do nothing.
    }
    // --- +++ END FIX +++ ---
  }

  /**
   * (14) The Final Step: Execute the trade using a secure transaction.
   * This is called by the onSnapshot listener when both players have accepted.
   * Only player1 runs this.
   */
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);

        // Read all docs *inside* the transaction
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);

        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }

        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();

        // --- Final safety checks ---
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;

        // Check if players have enough gold
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        
        // Check if players have enough items
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!p1Data.inventory[item] || p1Data.inventory[item] < qty) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!p2Data.inventory[item] || p2Data.inventory[item] < qty) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }

        // --- All checks passed, commit the changes ---
        // We ONLY update the session. The listener will handle the rest.
        transaction.update(sessionRef, { status: 'completed' });
        
        // NO player data is written here.
      });
      
      // Transaction successful! The listener will take over.
      
    } catch (e) {
      console.error("TRADE FAILED:", e);
      // Set trade to cancelled AND add the error message
      // so both players can see why it failed.
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- END OF NEW TRADE FUNCTIONS ---


  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    contentContainer.innerHTML = `
      <div style="text-align:center; margin-top: 20px; color: #fff; opacity: 0.7;">Refreshing...</div>
    `;
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        const totalXp = data.mining?.totalXP || 0; 
        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // +++ MODIFIED DOMContentLoaded +++
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = window.renderLeaderboards;
    }

    // +++ ADDED CHAT LISTENERS +++
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');

    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }

    if (chatInput) {
      // Optional: Allow sending by pressing 'Enter'
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); // Prevents a line break
          sendChatMessage();
        }
      });
    }
  });

  // --- Autosave and Logout functions (Unchanged) ---
  setInterval(() => {
    const user = auth.currentUser;
    if (user) {
      window.savePlayerData();
    }
  }, 30000);

  window.addEventListener('beforeunload', (e) => {
    try {
      const user = auth.currentUser;
      if (user) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // +++ MODIFIED LOGOUT FUNCTION (FOR TRADE) +++
  window.firebaseLogout = async function() {
    try {
      // --- +++ NEW: Cancel active trade on logout +++ ---
      if (game.inTrade && game.activeTradeSessionId) {
        try {
          await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
            status: 'cancelled'
          });
        } catch (e) {
          console.warn("Could not cancel active trade on logout:", e);
        }
        closeTradeWindow();
      }
      // --- +++ End new block +++ ---
      
      await window.savePlayerData();
      await signOut(auth);
      
      // Note: The onAuthStateChanged listener will handle
      // state reset and unsubscribing from listeners.
      
      alert("Logged out."); 
    } catch (e) {
      console.error("Logout failed:", e);
    }
  };
</script>
</body>
</html>