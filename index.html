<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  /* --- ADD THIS LINE --- */
  --panel-noise: linear-gradient(rgba(0,0,0,0.03), rgba(0,0,0,0.03));
  
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}

/* --- NEW MASTER PANEL STYLE --- */
.sidebar, 
.main, 
.chat-panel, 
.trade-content, 
#sessionLockOverlay div, 
#deathOverlay div, 
.settings-modal, 
.game-modal, 
#statsPanel,
#spellsPanel {   /* <--- ADDED THIS */
  /* 1. Original brown color */
  background-color: var(--panel-bg);
  
  /* 2. Subtle noise texture on top */
  background-image: var(--panel-noise);
  
  /* 3. New 3D "Bevel" Border */
  border: 4px solid #453625; /* Fallback */
  border-top-color: #7c644c;    /* Lighter top */
  border-left-color: #7c644c;   /* Lighter left */
  border-bottom-color: #3f2b21; /* Darker bottom */
  border-right-color: #3f2b21;  /* Darker right */
  
  /* 4. Same shadow and radius */
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
}

body {
  margin: 0;
  font-family: "Garamond", serif;
  background: #3f2b21;
  background-image: url('images/brickbackground.png');
  background-size: cover;
  background-attachment: fixed;
  background-position: center center;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;

  /* --- ADD THESE LINES --- */
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none;     /* IE 10+ */
  -moz-user-select: none;    /* Firefox */
  user-select: none;         /* Standard */
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- Panel Row Wrappers --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch;
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- Spacer for Chat Panel --- */
.sidebar-spacer {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0;
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  padding: 16px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

/* +++ ADD THIS NEW RULE HERE +++ */
#leaderboardContent {
  /* This reserves space for 10 rows immediately so the layout doesn't jump */
  min-height: 280px; 
  display: flex;
  flex-direction: column;
}

.char-header { display: flex; justify-content: center; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px;
}

.hp-bar { background: #772222; border-radius: 6px; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

#equipmentTab {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  justify-content: space-between; /* This pushes the button to the bottom */
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { 
  display: grid;
  grid-template-columns: repeat(3, var(--slot-size));
  gap: var(--slot-gap);
  /* All the old flexbox and width properties are gone */
}
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  position: relative; /* <-- THIS IS THE FIX */
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  padding: 0; 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 3501; /* <-- THIS IS THE FIX */
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- Custom Scrollbar --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px;
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Main area --- */
.main {
  flex: 1;
  padding: 18px;
  min-height: 500px; 
  position: relative;

  /* --- NEW: Added flex properties --- */
  display: flex;
  flex-direction: column;
}

.bank-content-wrapper {
  /* This overrides the standard padding from the parent containers (like .main or #mainContentWrapper) */
  padding: 0 10px 10px 10px; /* Adjust top/bottom padding as needed, but reduce left/right */
  width: 100%;
  box-sizing: border-box; /* Crucial for preventing width overflow */
}

#mainContentWrapper {
  flex-grow: 1;
  overflow-y: auto;
  min-height: 0;
  
  /* +++ FIX: Add these two lines to enable height:100% on children +++ */
  display: flex;
  flex-direction: column; 
  
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

#mainContentWrapper::-webkit-scrollbar {
  width: 8px;
}
#mainContentWrapper::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Chat Panel --- */
.chat-panel {
  padding: 18px;
  display: flex; 
  flex-direction: column;
  min-height: 200px;
  flex-shrink: 0;
  flex: 1;
}
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}
#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}

/* --- Action Progress --- */
.progress-container {
  background: #7c644c;
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}

.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }
.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}

.progress-text {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  pointer-events: none; /* Lets clicks pass through */
}

button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

/* --- NEW WARNING POPUP --- */
.warning-popup {
  position: absolute;
  background: rgba(221, 68, 68, 0.9); /* Red background */
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1501; /* Above XP popup */
  transform-origin: center;
  animation: fadeOutWarning 3000ms ease-out forwards; /* 3 second animation */
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
@keyframes fadeOutWarning {
  0% { transform: translateY(0); opacity: 1; }
  80% { transform: translateY(-30px); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}
/* --- END NEW --- */

/* --- Trade Modal --- */
#tradeModal { display: none; }
.trade-content {
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}
.trade-main-area { display: flex; gap: 20px; flex: 1; }
.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}
.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img { width: 30px; height: 30px; }
#tradeInventoryGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}
.trade-offer-layout { display: flex; gap: 20px; }
.trade-offer-box { flex: 1; display: flex; flex-direction: column; }
.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}
#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}
.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}

/* --- Drag & Drop --- */
.inv-slot.dragging {
  opacity: 0.4;
  cursor: grabbing;
}
.inv-slot.drag-over {
  border-color: var(--gold);
  border-style: dashed;
  background: rgba(181, 166, 66, 0.1);
}

/* +++ NEW: SESSION LOCK OVERLAY +++ */
#sessionLockOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#sessionLockOverlay div {
  padding: 30px 40px;
  max-width: 400px;
}
#sessionLockOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}

#deathOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5001; /* Higher than session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#deathOverlay div {
  padding: 30px 40px;
  max-width: 400px;
}
#deathOverlay h2 {
  margin-top: 0;
  color: #ff4d4d; /* Red for death */
}
/* +++ END NEW STYLES +++ */

/* --- NEW: Broadcast Overlay Style --- */
#broadcastOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5002; /* Above death/session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#broadcastOverlay div {
  /* This uses the master panel style */
  padding: 30px 40px;
  max-width: 400px;
}
#broadcastOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}
/* --- END NEW --- */

#combat-main-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#combat-enemy-area {
  flex-basis: 200px; /* Reduced from 220px */
  flex-shrink: 0;
  text-align: center;
  position: relative;
  margin-bottom: 15px;
}

#combat-enemy-img {
  max-height: 150px; /* Reduced from 180px */
  max-width: 100%;
  object-fit: contain;
}

#combat-enemy-hp-bar {
  background: #772222;
  border-radius: 6px;
  /* overflow: hidden; */ /* <-- This is the fix */
  position: relative;
  height: 28px;
  width: 80%;
  max-width: 300px;
  margin: 10px auto 0 auto;
  border: 2px solid #333;
}

#combat-enemy-hp-fill {
  height: 100%;
  background: #d22;
  width: 100%;
  transition: width 0.25s;
}

#combat-enemy-hp-text {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  font-size: 13px;
}

#combat-player-area {
  flex-grow: 1;
  display: flex;
  gap: 20px;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  justify-content: center; /* <-- ADDED THIS to center the buttons */
}


#combat-action-panel {
  /* flex-grow: 1; has been removed */
  display: flex;
  flex-direction: column;
}

#combat-styles {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

#combat-styles button {
  flex: 1;
  padding: 12px;
  border: 2px solid var(--accent);
  background: var(--accent);
  opacity: 0.7;
}

#combat-styles button.active {
  background: var(--accent-hover);
  border-color: var(--gold);
  opacity: 1.0;
}


#combat-main-actions {
  display: flex;
  gap: 10px;
  flex-direction: column; /* Stack buttons */
}

#combat-main-actions button {
  /* flex: 1; removed */
  font-size: 16px;
}
/* --- END: Combat UI Styles --- */

.combat-splat {
  position: absolute;
  right: -40px; /* Moved over to center the new box */
  top: -5px;    /* Moved up slightly */
  font-size: 1.2rem;
  font-weight: bold;
  pointer-events: none;
  z-index: 1600;
  animation: rise 900ms ease-out forwards;
  
  /* --- NEW "BOX" STYLES --- */
  background: rgba(10, 10, 10, 0.75);
  border: 1px solid #000;
  border-radius: 6px;
  padding: 3px 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}

.splat-damage {
  color: #ff4d4d; /* Bright red */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

.splat-block {
  color: #6dafff; /* Bright blue */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

/* --- NEW: Item Context Menu --- */
#itemContextMenu {
  display: none;
  position: fixed;
  z-index: 3000;
  background: var(--panel-bg);
  border: 2px solid #453625;
  border-radius: 6px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  padding: 5px;
  min-width: 100px;
}
.context-menu-btn {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 4px;
  text-align: left;
  cursor: pointer;
  font-weight: 700;
}
.context-menu-btn:hover {
  background: var(--accent-hover);
}
/* --- END: Item Context Menu --- */

#bankGrid, #shopGrid {
  /* Set the number of columns */
  grid-template-columns: repeat(5, var(--slot-size)); 
  
  /* --- CRITICAL FIX: Re-add centering and set min-width on its WRAPPER --- */
  /* This ensures the grid is centered again */
  justify-content: center; 
}
/* --- END NEW RULE --- */

/* --- NEW: Bank UI Styles --- */

#bankContainer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
#bankGoldPanel {
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  /* This will put the input/button group on one side and "Banked Gold" on the other */
  justify-content: space-between; 
  align-items: center;
  flex-wrap: wrap;
  gap: 20px; /* Increased gap a bit for balance */
  margin-top: -10px;
}
#bankGoldPanel > div {
  text-align: center;
}
#bankGoldPanel .gold-display {
  font-size: 18px;
  font-weight: bold;
  color: var(--gold);
}
#bankGoldPanel input {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  width: 120px;
}
#bankGridPanels {
  display: flex;
  gap: 20px;
}
#bankPanel, #bankInventoryPanel {
  flex: 1;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  /* --- CRITICAL FIX: Add min-width to prevent panel from shrinking --- */
  min-width: 400px; 
}
#bankPanel h3, #bankInventoryPanel h3 {
  margin: 0 0 10px 0;
  text-align: center;
}
#bankGridWrap {
  /* flex: 1; <-- REMOVED */
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
  /* 4-row height */
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
}

#shopGridWrap {
  /* This wrap will now auto-size to its content */
  overflow-y: hidden; /* Prevent scrollbar */
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  height: auto !important; /* <-- THIS IS THE FIX */
  padding: var(--slot-gap);
  box-sizing: border-box;
}

#gameModalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4000;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  box-sizing: border-box;
}
.game-modal {
  padding: 20px;
  width: 100%;
  max-width: 450px;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.game-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.game-modal-content {
  font-size: 16px;
  line-height: 1.5;
  margin-bottom: 20px;
}
.game-modal-input {
  width: 100%;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 16px;
  box-sizing: border-box; /* Important */
}
.game-modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

#equipmentStats {
  /* This style is now used by the pop-up panel */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
}
.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 4px;
  font-size: 15px;
}
.stat-row:not(:last-child) {
  border-bottom: 1px solid var(--accent);
}
.stat-label {
  color: #efe3cf;
  font-weight: bold;
}
.stat-value {
  color: var(--gold);
  font-weight: bold;
}
/* --- END: Equipment Stats Display --- */

/* --- NEW: Locked Item/Vein Style --- */
.locked-item {
  opacity: 0.4;
  filter: grayscale(80%);
  cursor: not-allowed !important;
}
.locked-item:hover {
  background: var(--accent) !important; /* Prevents hover effect */
}
/* --- END: Locked Item/Vein Style --- */

.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

/* --- NEW: Smithing Tab Active State --- */
.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

#settingsBtn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: 2px; /* <-- FIX: Changed from 18px */
  width: 22px;
  height: 22px;
  background: transparent; 
  border: 0;
  outline: none;
  border-radius: 6px;
  cursor: pointer;
  padding: 0; 
  box-sizing: border-box;
  z-index: 10;
}
#settingsBtn:hover {
  background: transparent; /* <-- FIX: Keep background transparent on hover */
  opacity: 0.8; /* <-- Add a subtle hover effect instead */
}
#settingsBtn img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none; /* Let clicks pass to the button */
}

.setting-row label {
  font-weight: bold;
  font-size: 16px;
  flex-basis: 110px; /* Give labels a fixed width to align sliders */
  flex-shrink: 0;
}
.setting-mute-btn {
  min-width: 80px; /* Make mute buttons smaller */
  padding: 8px 10px;
  margin-left: 15px; /* Space from slider */
}

/* --- NEW: Settings Modal --- */
#settingsModalOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4500; /* Below session lock, above trade */
  justify-content: center;
  align-items: center;
}
.settings-modal {
  padding: 20px;
  width: 90%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
}
.settings-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
  gap: 15px;
}
.setting-row label {
  font-weight: bold;
  font-size: 16px;
}
.volume-slider {
  flex-grow: 1;
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 12px;
  background: #3f2b21;
  border: 1px solid #453625;
  border-radius: 6px;
  outline: none;
}
.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}
.volume-slider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}

/* --- NEW: Hub Screen Toggler --- */
.hub-screen {
  display: none; /* Hide all hubs by default */
  width: 100%;
  height: 100%;
  flex-direction: column;
}
.hub-screen.active {
  display: flex; /* Show the active one */
}
/* --- END NEW --- */

/* --- NEW: Spells Panel (Mirrors Stats Panel) --- */
#spellsPanel {
  display: flex; /* Always flex so layout works inside */
  visibility: hidden; /* Hidden visually, but keeps the space reserved */
  
  /* This width perfectly matches the .sidebar panel above it */
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  
  /* This height perfectly matches the .chat-panel next to it */
  min-height: 200px; 
  
  /* New layout styles */
  padding: 16px;
  box-sizing: border-box;
  flex-direction: column;
  flex-shrink: 0;
}
#spellsPanelHeader {
  font-size: 18px;
  font-weight: bold;
  color: #fff; /* <-- CHANGED TO WHITE */
  margin: -5px -5px 10px -5px;
  padding: 5px 10px;
  border-bottom: 2px solid var(--accent);
}
#spellsPanelContent {
  /* We can re-use the .stat-row styles here */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
  flex-grow: 1; /* Allow content area to stretch */
}
#spellsPanelFooter {
  display: flex;
  justify-content: space-between; /* To put the autocast text on the left */
  align-items: center;
  margin-top: 15px;
}
/* --- END: Spells Panel --- */

/* --- NEW: Stats Panel --- */
#statsPanel {
  display: flex; /* Always flex */
  visibility: hidden; /* Hidden visually, but keeps the space reserved */
  
  /* This width perfectly matches the .sidebar panel above it */
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  
  /* This height perfectly matches the .chat-panel next to it */
  min-height: 200px; 
  
  /* New layout styles */
  padding: 16px;
  box-sizing: border-box;
  flex-direction: column;
  flex-shrink: 0;
}
#statsPanelHeader {
  font-size: 18px;
  font-weight: bold;
  color: #fff; /* <-- CHANGED TO WHITE */
  margin: -5px -5px 10px -5px;
  padding: 5px 10px;
  border-bottom: 2px solid var(--accent);
}
#statsPanelContent {
  /* We can re-use the .stat-row styles here */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
}
#statsPanelFooter {
  display: flex;
  justify-content: flex-end;
  margin-top: 15px;
}
/* --- END: Stats Panel --- */

/* --- NEW: Updates Panel --- */
#updatesContent {
  /* Set a fixed height to make it scrollable */
  height: 112px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  display: flex; 
  flex-direction: column; /* Normal top-to-bottom flow */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#updatesContent::-webkit-scrollbar { width: 8px; }
#updatesContent::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
#updatesContent::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }
#updatesContent::-webkit-scrollbar-thumb:hover { background: var(--accent-hover); }

.update-message {
  margin-bottom: 8px;
  line-height: 1.4;
  font-size: 13px;
  word-break: break-word;
  /* Add a small border like the leaderboard */
  padding-bottom: 8px;
  border-bottom: 1px dashed rgba(255,255,255,0.1);
}
.update-message:last-child {
  border-bottom: none;
  margin-bottom: 0;
}
.update-message strong {
  color: var(--gold);
  display: block; /* Timestamp on its own line */
  font-size: 12px;
  opacity: 0.8;
  margin-bottom: 3px;
}
/* --- END: Updates Panel --- */

/* --- NEW: Loading Bar --- */
#loading-bar-container {
  width: 100%;
  background: #3f2b21;
  border: 2px solid var(--accent);
  border-radius: 8px;
  padding: 3px;
  margin-top: 15px;
  box-sizing: border-box;
  position: relative;
  height: 28px;
}
#loading-bar-fill {
  width: 0%;
  height: 100%;
  background: var(--gold);
  border-radius: 4px;
  transition: width 0.1s ease-out; /* A fast transition */
}
#loading-progress-percent {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  color: #fff;
  font-weight: bold;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
}
/* --- END: Loading Bar --- */

/* --- NEW: Lottery System Styles --- */
.lottery-window {
  width: 100%;
  max-width: 400px; /* <--- Reduced width to 400px */
  height: 100px;
  background: #2a1a11;
  border: 4px solid #b5a642; /* Gold border */
  border-radius: 8px;
  overflow: hidden; /* Hides the strip */
  position: relative;
  margin: 0 auto;
  box-shadow: inset 0 0 20px #000;
}

.lottery-pointer {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 4px;
  height: 100%;
  background: rgba(255, 215, 0, 0.5); /* Semi-transparent gold line */
  z-index: 10;
  border-left: 1px solid #fff;
  border-right: 1px solid #fff;
}

.lottery-pointer::after {
  content: '';
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 15px solid #fff;
}

.lottery-reel {
  display: flex;
  height: 100%;
  align-items: center;
  transform: translateX(0px);
}

.lottery-slot {
  width: 80px;
  height: 80px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-right: 1px solid rgba(255,255,255,0.1);
  position: relative;
  box-sizing: border-box; /* <--- THIS IS THE FIX */
}

.lottery-slot img {
  width: 60px;
  height: 60px;
  object-fit: contain;
}

.lottery-slot .qty-badge {
  position: absolute;
  bottom: 2px;
  right: 2px;
  background: rgba(0,0,0,0.7);
  color: #fff;
  font-size: 10px;
  padding: 2px 4px;
  border-radius: 4px;
}
/* --- END Lottery Styles --- */

/* --- Quest Styles --- */
.quest-line-card {
  padding: 15px;
  background: rgba(0,0,0,0.2);
  border: 2px solid var(--accent);
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}
.quest-line-card:hover {
  background: rgba(0,0,0,0.3);
  border-color: var(--gold);
}
.quest-line-completed {
  opacity: 0.6;
  border-color: #44aa44;
}
.quest-req-met {
  color: #aaffaa;
}
.quest-req-not-met {
  color: #ffaaaa;
}

/* --- Completed Quest History Styles --- */
.completed-quest-row {
  padding: 6px 10px;
  background: rgba(0,0,0,0.2);
  margin-bottom: 4px;
  border-radius: 4px;
  font-size: 13px;
  color: #aaa; /* Dimmed text */
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-left: 3px solid #44aa44; /* Green accent */
}
.completed-quest-row:last-child {
  margin-bottom: 0;
}

/* --- Specific Fix for Quest Line Hub Layout --- */
#hubQuestLine {
  /* These rules force the hub to stay inside the main panel without expanding it */
  flex-grow: 1;
  height: 0; /* CRITICAL: Forces flex calculation based on space, not content */
  min-height: 0;
  overflow: hidden; 
  display: flex;
  flex-direction: column;
}

/* NEW: The container that holds the text and scrolls */
.quest-scroll-container {
  flex-grow: 1;
  overflow-y: auto;
  padding-right: 10px; /* Prevent text hitting the scrollbar */
  margin-bottom: 10px;
  
  /* Firefox Scrollbar */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

/* Custom Scrollbar Styling */
.quest-scroll-container::-webkit-scrollbar {
  width: 8px;
}
.quest-scroll-container::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.quest-scroll-container::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.quest-scroll-container::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- NEW: Level Up Popup Styles --- */
#levelUpOverlay {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.6);
  z-index: 6000;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  
  /* +++ FADE EFFECT SETTINGS +++ */
  opacity: 0;
  transition: opacity 0.5s ease-in-out;
}

/* Class to toggle visibility */
#levelUpOverlay.visible {
  opacity: 1;
}

.levelup-card {
  position: relative;
  background: var(--panel-bg);
  border: 4px solid var(--gold);
  border-radius: 12px;
  padding: 30px 50px;
  text-align: center;
  box-shadow: 0 0 30px rgba(181, 166, 66, 0.6), inset 0 0 20px rgba(0,0,0,0.5);
  animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  overflow: hidden;
}

/* Festive Sunburst Background */
.levelup-rays {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: 400px; height: 400px;
  background: repeating-conic-gradient(
    from 0deg,
    rgba(255, 215, 0, 0.1) 0deg 20deg,
    transparent 20deg 40deg
  );
  animation: rotateRays 10s linear infinite;
  z-index: 0;
  pointer-events: none;
}

.levelup-content {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.levelup-title {
  font-size: 32px;
  font-weight: bold;
  color: var(--gold);
  text-shadow: 0 2px 4px rgba(0,0,0,0.8);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.levelup-icon-frame {
  width: 80px; height: 80px;
  background: rgba(0,0,0,0.3);
  border: 2px solid var(--accent);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 10px 0;
  box-shadow: 0 0 15px var(--gold);
}

.levelup-icon-frame img {
  width: 64px; height: 64px;
  object-fit: contain;
}

.levelup-text {
  font-size: 20px;
  color: #fff;
  text-shadow: 0 1px 2px #000;
}

.levelup-level {
  font-size: 48px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 10px var(--gold);
}

@keyframes popIn {
  0% { transform: scale(0); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes rotateRays {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

</style>
</head>
<body>

<div id="loadingScreen" style="display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background-color: #3f2b21;
 background-image: url('images/tittle.jpeg'); background-size: contain; background-position: center center; background-repeat: no-repeat; z-index: 10000;">
  <!-- Make the container a bit wider to fit the bar -->
  <div style="text-align: center; color: var(--gold); font-size: 20px; font-weight: bold; width: 300px;">
    Loading assets...
    <!-- NEW Progress Bar Structure -->
    <div id="loading-bar-container">
      <div id="loading-bar-fill"></div>
      <div id="loading-progress-percent">0%</div>
    </div>
    <!-- END Progress Bar -->
  </div>
</div>

<div id="authScreen" style="display:none; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header" style="position: relative;">
          <h2 id="charName">Player</h2>
          <button id="settingsBtn" onmouseenter="showTooltip(event, 'Settings')" onmouseleave="hideTooltip()">
            <img src="images/gearicon.png" alt="Settings">
          </button>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-slot" id="necklace">
                  <img src="images/necklace.png" alt="Necklace">
                </div>
                <div class="equipment-slot" id="helmet">
                  <img src="images/helmet.png" alt="Helmet">
                </div>
                <div class="equipment-slot" id="cape">
                  <img src="images/cape.png" alt="Cape">
                </div>
                <div class="equipment-slot" id="weapon">
                  <img src="images/weapon.png" alt="Weapon">
                </div>
                <div class="equipment-slot" id="chest">
                  <img src="images/chestplate.png" alt="Chest">
                </div>
                <div class="equipment-slot" id="shield">
                  <img src="images/shield.png" alt="Shield">
                </div>
                <div class="equipment-slot" id="ring1">
                  <img src="images/ring.png" alt="Ring 1">
                </div>
                <div class="equipment-slot" id="legs">
                  <img src="images/legs.png" alt="Legs">
                </div>
                <div class="equipment-slot" id="ring2">
                  <img src="images/ring.png" alt="Ring 2">
                </div>
                <div class="equipment-slot" id="arrows">
                  <img src="images/arrows.png" alt="Arrows">
                </div>
                <div class="equipment-slot" id="boots">
                  <img src="images/boots.png" alt="Boots">
                </div>
                <div class="equipment-slot" id="pet">
                  <img src="images/pet.png" alt="Pet">
                </div>
              </div>
            </div>

            <div id="statsButtonContainer" style="display: flex; justify-content: space-between; margin-top: 20px;">
    <button class="primary" id="toggleStatsBtn">Stats</button> <button class="primary" id="toggleSpellsBtn">Spells</button>
</div>
            </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
  <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
    <img src="images/goldpouch.png" alt="Gold" style="width: 40px; height: 40px; object-fit: contain;">
    <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 0px;">0</span>
  </div>
              
</div>
            
          </div>
          
          <div id="skillsTab" style="display:none;">
            </div>
          
        </div>
      </div>

      <div class="main" id="mainArea">

        <div id="mainContentWrapper">
        
          <div id="hubActions" class="hub-screen">
            <div id="actionScreen" style="display: flex; gap: 10px; flex-wrap: wrap;">
              <img id="minesActionIcon" src="images/mines.png" alt="Mines" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="crystalMineActionIcon" src="images/crystalmine.jpeg" alt="Crystal Mine" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="fishingActionIcon" src="images/fishingareasbutton.jpeg" alt="Fishing Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="forestActionIcon" src="images/foresticon.png" alt="Forest" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="blacksmithActionIcon" src="images/blacksmithicon.png" alt="Blacksmith" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="fletchingActionIcon" src="images/fletchingworkbench.png" alt="Fletching" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="kitchenActionIcon" src="images/kitchenbutton.png" alt="Kitchen" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="combatActionIcon" src="images/combatareas.png" alt="Combat Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="shopActionIcon" src="images/shopbutton.png" alt="Shop" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="bankActionIcon" src="images/bankbutton.png" alt="Bank" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="craftingActionIcon" src="images/craftingbenchbutton.png" alt="Crafting" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="elementalForgeActionIcon" src="images/elementalforge.jpeg" alt="Elemental Forge" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="lotteryActionIcon" src="images/lotteryicon.jpeg" alt="Lottery" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain; border: 2px solid var(--gold); border-radius: 8px;">
              <img id="questsActionIcon" src="images/questbuttonicon.jpg" alt="Quests" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="huntingBoardActionIcon" src="images/huntingboard.jpeg" alt="Hunting Board" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
            </div>
          </div>

          <div id="hubQuests" class="hub-screen">
            <h2>Quest Lines</h2>
            <div style="margin-top:8px; color:#efe3cf;">Select a category to view your current task.</div>
            <div id="questLinesContainer" style="margin-top: 20px; display: flex; flex-direction: column; gap: 15px;">
                </div>
            <div class="action-buttons" style="margin-top: 20px;">
              <button id="hubQuests_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>

          <div id="hubHuntingBoard" class="hub-screen">
            <h2>Hunting Board</h2>
            <div style="margin-top:8px; color:#efe3cf;">Accept bounties to earn gold and experience.</div>
            
            <div id="bountyContent" style="margin-top: 20px; display: flex; flex-direction: column; gap: 15px;">
                </div>

            <div class="action-buttons" style="margin-top: 20px;">
              <button id="hubHuntingBoard_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>

          <div id="hubQuestLine" class="hub-screen">
            <h2 id="questLineTitle" style="color: #fff; flex-shrink: 0;">Quest Line Title</h2>
            
            <div class="quest-scroll-container">
                
                <div id="activeQuestContainer" style="margin-top: 15px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 1px solid var(--accent);">
                </div>

                <div id="completedQuestsSection" style="margin-top: 15px; display:none; background: rgba(0,0,0,0.15); padding: 10px; border-radius: 8px;">
                    <div style="color: #888; font-size: 12px; font-weight: bold; margin-bottom: 8px; text-transform: uppercase;">History</div>
                    <div id="completedQuestsList">
                    </div>
                </div>
            
            </div>

            <div class="action-buttons" style="margin-top: 20px; flex-shrink: 0;">
              <button id="questLine_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>

          <div id="hubCrafting" class="hub-screen">
            <h2>Crafting Bench</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to craft.</div>
            <div id="craftingItemsContainer" class="action-buttons" style="margin-top: 14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubCrafting_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>

          <div id="hubElementalForge" class="hub-screen">
            <h2>Elemental Forge</h2>
            <div style="margin-top:8px; color:#efe3cf;">Forge magical stones from crystal shards.</div>
            <div id="elementalForgeItemsContainer" class="action-buttons" style="margin-top: 14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubElementalForge_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubMine" class="hub-screen">
            <h2>Mine</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a vein to mine.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="sandVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/sandvein.jpeg" alt="Sand" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="copperVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coppervein.png" alt="Copper Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="coalVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coalvein.png" alt="Coal Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="ironVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/ironvein.png" alt="Iron Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubMine_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>

          <div id="hubCrystalMine" class="hub-screen">
            <h2>Crystal Mine</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a crystal vein to mine.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="earthCrystalBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/earthcrystalvein.png" alt="Earth Crystal" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="airCrystalBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/aircrystalvein.png" alt="Air Crystal" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="waterCrystalBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/watercrystalvein.png" alt="Water Crystal" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubCrystalMine_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubBlacksmith" class="hub-screen">
            <h2>Blacksmithing</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to smith.</div>
            <div class="tabs" style="margin-top: 14px; margin-bottom: 14px; width: 100%;">
              <button id="smithCopperTab" class="active">Copper</button>
              <button id="smithIronTab">Iron</button>
            </div>
            <div id="smithingItemsContainer" class="action-buttons" style="margin-top: 0; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubBlacksmith_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>

          <div id="hubFletching" class="hub-screen">
            <h2>Fletching</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to fletch.</div>
            <div id="fletchingItemsContainer" class="action-buttons" style="margin-top: 14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubFletching_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubForest" class="hub-screen">
            <h2>Forest</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a tree to chop.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="softwoodTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/softwood.png" alt="Softwood Tree" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="oakTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/oak.png" alt="Oak Tree" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubForest_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubKitchen" class="hub-screen">
            <h2>Kitchen</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose something to cook.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              
              <button id="cookChickenBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedchicken.png" alt="Cooked Chicken" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>

              <button id="cookBeefBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedbeef.png" alt="Cooked Beef" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>

              <button id="cookHerringBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedherring.png" alt="Cooked Herring" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="cookTroutBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedtrout.png" alt="Cooked Trout" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="cookSalmonBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedsalmon.png" alt="Cooked Salmon" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>

            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubKitchen_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubCombat" class="hub-screen">
            <h2>Combat Areas</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fighting.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
              <button id="farmAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0;">
  <img src="images/farm.png" alt="Farm Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
</button>
              <button id="caveAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0; margin-top: 10px;">
  <img src="images/cave.png" alt="Cave Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
</button>
              <button id="hubCombat_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubCave" class="hub-screen">
            <h2>The Cave</h2>
            <div style="margin-top:8px; color:#efe3cf;">A dark, damp cave.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Rat')" 
                   onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Rat (Lvl 1)</div>')"
                   onmouseleave="hideTooltip()">
                <img src="images/ratmonster.jpeg" alt="Rat" style="height: 100px;">
              </div>
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Spider')"
                   onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Spider (Lvl 2)</div>')"
                   onmouseleave="hideTooltip()">
                <img src="images/spidermonster.png" alt="Spider" style="height: 100px;">
              </div>
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Centipede')"
                   onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Centipede (Lvl 5)</div>')"
                   onmouseleave="hideTooltip()">
                <img src="images/centipedemonster.jpeg" alt="Centipede" style="height: 100px;">
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubCave_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          <div id="hubShop" class="hub-screen">
            <h2>General Store</h2>
            
            <div style="display: flex; flex-direction: column; gap: 20px; margin-top: 16px; width: 100%;">
            
              <div style="background:rgba(0,0,0,0.1); border-radius:6px; padding: 10px 15px; display: flex; flex-direction: column;">
                <h3 style="margin:0 0 10px 0; color: var(--gold); text-align: center;">Items for Sale</h3>
                
                <div class="inventory-grid-wrap" id="shopGridWrap">
                  <div class="inventory-grid" id="shopGrid">
                    </div>
                </div>
              </div>
              
            </div>
            
            <div class="action-buttons" style="margin-top:20px;">
              <button id="hubShop_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          <div id="hubBank" class="hub-screen">
            <div id="bankContainer" style="width: 100%;">
              <div class="bank-content-wrapper"> 
                <div id="bankGoldPanel">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="number" id="bankGoldInput" min="0" placeholder="Amount...">
                    <button id="bankDepositGoldBtn" class="primary">Deposit</button>
                    <button id="bankWithdrawGoldBtn" class="primary">Withdraw</button>
                  </div>
                  <div>
                    <div>Banked Gold</div>
                    <div id="bankStoredGold" class="gold-display">0</div>
                  </div>
                </div>
                <div id="bankPanel">
                  <h3>Bank Storage</h3>
                  <div class="inventory-grid-wrap" id="bankGridWrap">
                    <div class="inventory-grid" id="bankGrid"></div>
                  </div>
                </div>
              </div>
              <div class="action-buttons" style="margin-top:0px; align-self: flex-start;">
                <button id="hubBank_ReturnBtn" class="primary" style="background:#666;">Return</button>
              </div>
            </div>
          </div>

          <div id="hubFarm" class="hub-screen">
            <h2>The Farm</h2>
            <div style="margin-top:8px; color:#efe3cf;">A peaceful farm, mostly.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Chicken')"
                   onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Chicken (Lvl 1)</div>')"
                   onmouseleave="hideTooltip()">
                <img src="images/chickenmonster.png" alt="Chicken" style="height: 100px;">
              </div>
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Cow')"
                   onmouseenter="showTooltip(event, '<div style=\'font-weight:bold; color:var(--gold);\'>Cow (Lvl 2)</div>')"
                   onmouseleave="hideTooltip()">
                <img src="images/cowmonster.png" alt="Cow" style="height: 100px;">
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubFarm_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          <div id="hubDynamic" class="hub-screen">
            </div>

          <div id="hubFishingAreas" class="hub-screen">
            <h2>Fishing Areas</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fishing.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
              
              <button id="oceanAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/oceanbutton.png" alt="Ocean Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="riverAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0; margin-top: 10px;">
                <img src="images/riverbutton.jpeg" alt="River Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="hubFishingAreas_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubOcean" class="hub-screen">
            <h2>The Ocean</h2>
            <div style="margin-top:8px; color:#efe3cf;">The vast, open ocean.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div id="fishHerringBtn" style="text-align:center; cursor:pointer;" onclick="openFishHerring()">
                <img src="images/herring.png" alt="Herring" style="height: 100px;">
                
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubOcean_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          <div id="hubRiver" class="hub-screen">
            <h2>The River</h2>
            <div style="margin-top:8px; color:#efe3cf;">A fast-flowing river.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div id="fishTroutBtn" style="text-align:center; cursor:pointer;" onclick="openFishTrout()">
                <img src="images/trout.png" alt="Trout" style="height: 100px;">
              
              </div>
              
              <div id="fishSalmonBtn" style="text-align:center; cursor:pointer;" onclick="openFishSalmon()">
                <img src="images/salmon.png" alt="Salmon" style="height: 100px;">
                
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubRiver_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>

          <div id="hubLottery" class="hub-screen">
            <h2 style="text-align: center; color: var(--gold); text-shadow: 0 0 10px rgba(181, 166, 66, 0.5);">Skillsmith Lottery</h2>
            <div style="margin-top:8px; color:#efe3cf; text-align: center;">
                Pay 10,000 Gold for a chance to win the legendary <strong>Gold Crown</strong>!
                <br><span style="font-size: 12px; color: #aaa;">(Chance: 1 in 2,000)</span>
                <br><span style="font-size: 11px; color: #888; font-style: italic;">** The Gold Crown is a unique, purely cosmetic item and has the same stats as the iron helmet.</span>
            </div>
            
            <div style="margin-top: 30px; margin-bottom: 30px;">
                <div class="lottery-window">
                    <div class="lottery-pointer"></div>
                    <div id="lotteryReel" class="lottery-reel"></div>
                </div>
            </div>

            <div class="action-buttons" style="justify-content: center; gap: 20px;">
                <button id="buyTicketBtn" class="primary" style="background: var(--gold); color: #000; font-size: 18px; padding: 15px 30px;">
                    Buy Ticket (10k Gold)
                </button>
                <button id="hubLottery_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
            <div id="lotteryResultMsg" style="text-align: center; margin-top: 15px; font-weight: bold; font-size: 18px; min-height: 24px;"></div>
          </div>
          
          </div> <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>

        <h3 style="margin: 20px 0 8px 0; font-size: 18px; color: #fff; border-top: 2px solid var(--accent); padding-top: 15px;">Latest Updates</h3>
        <div id="updatesContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading updates...</div>
        </div>
        <div style="height: 24px;"> <div id="saveTimerText" style="visibility: hidden; margin-top: 10px; text-align: right; font-size: 11px; color: #aaffaa; font-weight: bold;">
              Progress Saved!
          </div>
        </div>
        </div>

    </div> 
    
    <div id="bottom-row-chat">

      <div id="statsPanel">
        <div id="statsPanelHeader">Player Stats</div>
        <div id="statsPanelContent">
          <div class="stat-row">
            <span class="stat-label">Physical Damage</span>
            <span class="stat-value" id="stat-phys-dmg-panel">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Magic Damage</span>
            <span class="stat-value" id="stat-magic-dmg-panel">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Armor</span>
            <span class="stat-value" id="stat-armor-panel">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Speed Bonus</span>
            <span class="stat-value" id="stat-speed-panel">0</span>
          </div>
        </div>
        <div id="statsPanelFooter">
          <button id="closeStatsBtn" class="primary" style="background:#666;">Close</button>
        </div>
      </div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div id="spellsPanel"> 
          <div id="spellsPanelHeader">Magic Spells</div>
          <div id="spellsPanelContent">
              <div id="spellsIconsContainer" style="display: flex; gap: 10px; justify-content: center;">
              </div>
          </div>
          <div id="spellsPanelFooter">
              <div id="autocastText" style="font-size: 14px; font-weight: bold; color: var(--gold);">None</div>
              <button id="closeSpellsBtn" class="primary" style="background:#666;">Close</button>
          </div>
      </div>

    </div> 
    
  </div> 
</div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<div id="sessionLockOverlay" style="display: none;">
  <div>
    <h2>Session Active Elsewhere</h2>
    <p>This account is already being played in another tab or browser. To prevent data corruption, this tab has been disabled.</p>
    <button id="takeControlButton" class="primary">Take Control Here</button>
  </div>
</div>

<div id="deathOverlay" style="display: none;">
  <div>
    <h2>You died!</h2>
    <p>You lost all your inventory and gold.</p>
    <button id="reviveBtn" class="primary" onclick="revivePlayer()">Revive</button>
  </div>
</div>

<div id="levelUpOverlay">
  <div class="levelup-card">
    <div class="levelup-rays"></div>
    <div class="levelup-content">
      <div class="levelup-title">Level Up!</div>
      <div class="levelup-icon-frame">
        <img id="levelUpIcon" src="" alt="Skill Icon">
      </div>
      <div class="levelup-text">You reached <span id="levelUpSkillName">Mining</span> Level</div>
      <div class="levelup-level" id="levelUpValue">10</div>
    </div>
  </div>
</div>

<!-- NEW: Settings Modal -->
<div id="settingsModalOverlay">
  <div class="settings-modal">
    <div class="settings-modal-title">Settings</div>
    
    <div class="setting-row">
      <label for="sfxVolumeSlider">Sound Effects</label>
      <input type="range" id="sfxVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="sfxMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="setting-row">
      <label for="musicVolumeSlider">Music</label>
      <input type="range" id="musicVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="musicMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="action-buttons" style="margin-top: 10px; justify-content: flex-end;">
      <button id="closeSettingsBtn" class="primary" style="background:#666;">Close</button>
    </div>
  </div>
</div> <div id="broadcastOverlay" style="display: none; z-index: 5002;"> <div>
    <h2 style="color: var(--gold);">System Update</h2>
    <p id="broadcastMessage" style="font-size: 16px; line-height: 1.5;">
      A new game update is live! Please refresh your browser to continue.
    </p>
    </div>
</div>
<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  settings: { 
    sfxVolume: 0.5, 
    isSfxMuted: false, 
    musicVolume: 0.15,  // <--- Changed this from 0.3
    isMusicMuted: false 
  },
  inventory: [], 
  inventoryCapacity: 39,
  gold: 0,
  // --- NEW BANK PROPERTIES ---
  bank: [],
  bankCapacity: 60, // Example: 80 slots
  bankGold: 0,
  // --- END NEW ---
  equipment: {
    necklace: null, // <-- NEW
    helmet: null,
    cape: null,     // <-- NEW
    weapon: null,
    chest: null,
    shield: null,   // <-- NEW
    ring1: null,    // <-- NEW
    legs: null,     // <-- NEW
    ring2: null,    // <-- NEW
    arrows: null,   // <-- NEW
    boots: null,
    pet: null       // <-- NEW PET SLOT
  },
  mining: { level: 1, xp: 0, totalXP: 0 },
  blacksmith: { level: 1, xp: 0, totalXP: 0 },
  attack: { level: 1, xp: 0, totalXP: 0 }, 
  strength: { level: 1, xp: 0, totalXP: 0 }, 
  defence: { level: 1, xp: 0, totalXP: 0 }, 
  vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY SKILL +++
  cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING SKILL +++
  woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING SKILL +++
  miningActive: false,
  blacksmithingActive: false,
  cookingActive: false,
  woodcuttingActive: false, // +++ NEW WOODCUTTING STATE +++
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, 
  isAdmin: false,
  inCombat: false,
  playerAttackStyle: 'strength', // Default to strength
  currentEnemy: null,
  playerCombatInterval: null,
  enemyCombatInterval: null,
  wasMiningBeforeCombat: false, // Renamed from 'wasMiningBeforeTrade'
  wasSmithingBeforeCombat: false,
  wasWoodcuttingBeforeCombat: false,
  fletching: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW FLETCHING SKILL +++
  fletchingActive: false, // +++ NEW FLETCHING STATE +++
  wasFletchingBeforeCombat: false, // +++ NEW FLETCHING STATE +++

  // +++ NEW CRAFTING SKILL +++
  crafting: { level: 1, xp: 0, totalXP: 0 },
  craftingActive: false,
  wasCraftingBeforeCombat: false,
  
  // +++ NEW RANGED SKILL +++
  ranged: { level: 1, xp: 0, totalXP: 0 },
  
  // +++ NEW FISHING SKILL +++
  fishing: { level: 1, xp: 0, totalXP: 0 },
  fishingActive: false,
  wasFishingBeforeCombat: false,

  // +++ NEW MAGIC SKILL +++
  magic: { level: 1, xp: 0, totalXP: 0 },
  
  // +++ NEW STONE FORGING SKILL +++
  stoneforging: { level: 1, xp: 0, totalXP: 0 },
  stoneforgingActive: false,
  wasStoneForgingBeforeCombat: false,

  // +++ NEW BOUNTY HUNTING SKILL +++
  bountyhunting: { level: 1, xp: 0, totalXP: 0 },
  activeBounty: null, // { target: 'Rat', req: 100, kills: 0 }
  
  // Stores progress: { 'tutorial': { completed: ['tut_1'], activeQuestId: 'tut_2', kills: 0 } }
  questLines: {},
  
  lastSmithingTab: 'copper',
  lastCombatAreaHub: 'hubActions', // +++ NEW +++
  
  // +++ NEW MAGIC STATE +++
  autocastSpell: null, 
  lastAttackTime: 0, // <--- NEW: Tracks the exact time of the last attack
  // +++ END NEW MAGIC STATE +++
  
  // +++ NEW SESSION LOCK +++
  // This is a unique ID for this specific tab
  sessionLockId: (function() {
  let id = sessionStorage.getItem('gameSessionId');
  if (!id) {
    // No ID exists, so this is a new tab. Create one.
    id = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    sessionStorage.setItem('gameSessionId', id);
  }
  // Return the persistent ID for this tab
  return id;
})(),
// +++ END MODIFICATION +++

lockHeartbeat: null,    // This will hold the setInterval ID for the heartbeat
isSessionActive: false, // Is this tab the "master" tab?
isDragging: false,      // Are we currently dragging an item?

inTrade: false,
activeTradeSessionId: null,
activeTradeListener: null, 
myTradeRole: null, 
myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};
// +++ END MODIFICATION +++

game.inventory = new Array(game.inventoryCapacity).fill(null);
game.bank = new Array(game.bankCapacity).fill(null);

// --- NEW: Music Player State ---
const musicPlaylist = [
  'sounds/music/music1.mp3',
  'sounds/music/music2.mp3',
  'sounds/music/music3.mp3',
  'sounds/music/music4.mp3'
];
let currentTrackIndex = 0;
const musicPlayer = new Audio(); 
musicPlayer.loop = false;
let audioAutoplayBlocked = false; // We handle the loop to change tracks
// --- END NEW ---

/**
 * Finds the highest tier tool of a specific type in the player's inventory.
 * @param {('pickaxe'|'axe')} toolType - The type of tool to look for.
 * @returns {number} The tier level (0 for none, 1 for Bronze, 2 for Copper, etc.)
 */
function getBestTool(toolType) {
  const tiers = (toolType === 'pickaxe') ? PICKAXE_TIERS : AXE_TIERS;
  let bestTier = 0;

  for (const slot of game.inventory) {
    if (slot && tiers[slot.name]) {
      if (tiers[slot.name] > bestTier) {
        bestTier = tiers[slot.name];
      }
    }
  }
  return bestTier;
}

/**
 * Updates the music player's volume/mute state from game.settings
 */
function updateMusicPlayerState() {
  if (game.settings.isMusicMuted) {
    musicPlayer.volume = 0;
  } else {
    musicPlayer.volume = game.settings.musicVolume;
  }
}

/**
 * Plays the next track in the playlist.
 */
function playNextTrack() {
  if (musicPlaylist.length === 0) return; 

  currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
  musicPlayer.src = musicPlaylist[currentTrackIndex];

  updateMusicPlayerState(); // Apply current volume settings

  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- NEW "CLICK ANYWHERE" FIX ---
      if (!audioAutoplayBlocked) { // Only add this listener ONCE
        audioAutoplayBlocked = true;

        // Listen for the *first* click or tap anywhere
        const interactionListener = () => {
          resumeMusicAfterInteraction();
          // Clean up this listener so it doesn't run again
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- END NEW ---

    });
  }
}

/**
 * Starts the music playlist for the first time.
 */
function startMusicPlaylist() {
  // Set up the listener for *all future songs*
  musicPlayer.addEventListener('ended', playNextTrack);

  // Set the volume before playing
  updateMusicPlayerState(); 

  // --- NEW: Pick a random song to start ---
  currentTrackIndex = Math.floor(Math.random() * musicPlaylist.length);
  musicPlayer.src = musicPlaylist[currentTrackIndex];
  // --- END NEW ---

  // Manually start the first song (we copy this logic from playNextTrack)
  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- This is the "click anywhere" fix ---
      if (!audioAutoplayBlocked) { 
        audioAutoplayBlocked = true;

        const interactionListener = () => {
          resumeMusicAfterInteraction();
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- End fix ---

    });
  }
}

/**
 * Tries to resume music playback after a user interaction.
 */
function resumeMusicAfterInteraction() {
  // Check if music is supposed to be on but is paused
  if (!game.settings.isMusicMuted && musicPlayer.paused) {
    const resumePromise = musicPlayer.play();

    if (resumePromise !== undefined) {
      resumePromise.then(() => {
        // SUCCESS! Autoplay is now unblocked.
        audioAutoplayBlocked = false; 
      }).catch(e => {
        // Still failed? Oh well.
        console.warn("Could not resume music.", e);
      });
    }
  }
}

const VALID_ITEMS = [
  'Bronze Pickaxe', // +++ NEW +++
  'Bronze Axe',     // +++ NEW +++
  'Copper Pickaxe', // +++ NEW +++
  'Copper Axe',     // +++ NEW +++
  'Iron Pickaxe',   // +++ NEW +++
  'Iron Axe',       // +++ NEW +++
  'Softwood',
  'Oak',
  'Copper Ore',
  'Copper Bar',
  'Copper Chestplate',
  'Copper Shortsword',
  'Copper Helmet', 
  'Copper Boots', 
  'Raw Chicken',
  'Cooked Chicken',
  'Burnt Chicken',
  'Coal Ore',
  'Iron Ore',
  'Iron Bar',
  'Iron Helmet',
  'Iron Chestplate',
  'Iron Boots',
  'Iron Shortsword',
  'Feather', // +++ NEW +++
  'Arrow Shaft', // +++ NEW +++
  'Copper Arrow Tip', // +++ NEW +++
  'Unbound Arrow', // +++ NEW +++
  'Copper Arrow', // +++ NEW +++
  'Copper Platelegs', // +++ NEW +++
  'Iron Platelegs', // +++ NEW +++
  'Silk', // +++ NEW +++
  
  // +++ NEW CLOTH & WIZARD ITEMS +++
  'Cloth',
  'Wizard Hat',
  'Wizard Robe',
  'Wizard Trousers',
  'Wizard Boots',
  
  // +++ NEW CRYSTAL ITEMS +++
  'Earth Crystal Shard',
  'Air Crystal Shard',
  'Water Crystal Shard',
  
  // +++ NEW ELEMENTAL STONES +++
  'Earthstone',
  'Airstone',
  'Waterstone',

  // +++ NEW CRAFTING/FLETCHING ITEMS +++
  'Bow String',
  'Unstrung Softwood Bow',
  'Unstrung Oak Bow',
  'Softwood Bow',
  'Oak Bow',
  
  // +++ NEW LEATHER ITEMS +++
  'Cow Hide',
  'Leather',
  'Leather Hood',
  'Leather Body',
  'Leather Chaps',
  'Leather Boots',
  
  // +++ NEW FISHING ITEMS +++
  'Herring',
  'Trout',
  'Salmon',
  'Fishing Pole',
  'Fishing Bait',

  // +++ NEW COOKED FISH +++
  'Cooked Herring',
  'Burnt Herring',
  'Cooked Trout',
  'Burnt Trout',
  'Cooked Salmon',
  'Burnt Salmon',
  'Beef',
  'Cooked Beef',
  'Burnt Beef',
  'Magic Staff',
  'Gold Crown',
  '1tapper', // +++ NEW ADMIN ITEM +++
  'Pet Spider', // +++ NEW PET +++
  'Rat Tail', // +++ NEW ITEM +++
  'Sand', // +++ NEW +++
  'Empty Vial', // +++ NEW +++
  'Venom' // +++ NEW +++
];

const XP_TABLE = [
  0,        // Level 1
  83,       // Level 2
  174,      // Level 3
  276,      // Level 4
  388,      // Level 5
  512,      // Level 6
  650,      // Level 7
  801,      // Level 8
  969,      // Level 9
  1154,     // Level 10
  1358,     // Level 11
  1584,     // Level 12
  1833,     // Level 13
  2107,     // Level 14
  2411,     // Level 15
  2746,     // Level 16
  3115,     // Level 17
  3523,     // Level 18
  3973,     // Level 19
  4470,     // Level 20
  5018,     // Level 21
  5624,     // Level 22
  6291,     // Level 23
  7028,     // Level 24
  7842,     // Level 25
  8740,     // Level 26
  9730,     // Level 27
  10824,    // Level 28
  12031,    // Level 29
  13363,    // Level 30
  14833,    // Level 31
  16456,    // Level 32
  18247,    // Level 33
  20224,    // Level 34
  22436,    // Level 35
  24898,    // Level 36
  27673,    // Level 37
  30779,    // Level 38
  33648,    // Level 39
  37224,    // Level 40
  41171,    // Level 41
  45542,    // Level 42
  50339,    // Level 43
  55649,    // Level 44
  61512,    // Level 45
  67983,    // Level 46
  75127,    // Level 47
  83014,    // Level 48
  91721,    // Level 49
  101333,   // Level 50
  111945,   // Level 51
  123660,   // Level 52
  136615,   // Level 53
  150872,   // Level 54
  166636,   // Level 55
  184040,   // Level 56
  203254,   // Level 57
  224446,   // Level 58
  247866,   // Level 59
  273742,   // Level 60
  302288,   // Level 61
  333804,   // Level 62
  368599,   // Level 63
  407015,   // Level 64
  449426,   // Level 65
  496254,   // Level 66
  547953,   // Level 67
  605032,   // Level 68
  668051,   // Level 69
  737637,   // Level 70
  814445,   // Level 71
  899252,   // Level 72
  992895,   // Level 73
  1096245,  // Level 74
  1210210,  // Level 75
  1336486,  // Level 76
  1475581,  // Level 77 (Using 1,475,581)
  1629200,  // Level 78 (Using 1,629,200)
  1798808,  // Level 79
  1986068,  // Level 80
  2192818,  // Level 81
  2421027,  // Level 82
  2673114,  // Level 83
  2951373,  // Level 84 (Using 2,951,373)
  3258594,  // Level 85
  3597292,  // Level 86
  3972294,  // Level 87 (Using 3,972,294)
  4385776,  // Level 88
  4842295,  // Level 89
  5346332,  // Level 90 (Using 5,346,332)
  5902831,  // Level 91
  6517253,  // Level 92
  7195629,  // Level 93
  7944614,  // Level 94
  8771588,  // Level 95
  9684577,  // Level 96
  10692629, // Level 97
  11805606, // Level 98
  13034031, // Level 99
  15000000  // Level 100: Custom value
];

// --- NEW: Fishing Level Requirements ---
const HERRING_FISH_LVL = 1;
const TROUT_FISH_LVL = 5;
const SALMON_FISH_LVL = 10;

// --- NEW: Fishing Action Constants ---
const FISHING_TIME_MS = 20000; // 20 seconds per fish

// +++ NEW MAGIC SPELL CONSTANTS +++
const EARTH_BOLT = { name: 'Earth Bolt', level: 1, damage: 2, xp: 5 };
const AIR_BOLT = { name: 'Air Bolt', level: 10, damage: 3, xp: 10 };
const WATER_BOLT = { name: 'Water Bolt', level: 15, damage: 4, xp: 15 };
const SPELL_LIST = [EARTH_BOLT, AIR_BOLT, WATER_BOLT];
// +++ END NEW MAGIC SPELL CONSTANTS +++

const HERRING_FISH_XP = 10;
const TROUT_FISH_XP = 20;
const SALMON_FISH_XP = 35;


const CHESTPLATE_BAR_COST = 10;
const CHESTPLATE_XP = 50; // Defining a standard XP gain for the item

// +++ NEW SHORTSWORD CONSTANTS +++
const SHORTSWORD_BAR_COST = 5;
const SHORTSWORD_XP = 32;
const SHORTSWORD_TIME_MS = 5000;
// +++ END NEW CONSTANTS +++
const HELMET_BAR_COST = 5;
const HELMET_XP = 32; // Same as shortsword
const HELMET_TIME_MS = 5000; // Same as shortsword
// +++ END NEW CONSTANTS +++

// +++ NEW BOOTS CONSTANTS +++
// +++ NEW BOOTS CONSTANTS +++
const BOOTS_BAR_COST = 4;
const BOOTS_XP = 26; // 4 bars (~6.5xp/bar)
const BOOTS_TIME_MS = 4000; // 4 bars (1s/bar)

// +++ NEW PLATELEGS CONSTANTS +++
const COPPER_PLATELEGS_BAR_COST = 6;
const COPPER_PLATELEGS_XP = 39; // 6 bars (~6.5xp/bar)
const COPPER_PLATELEGS_TIME_MS = 6000; // 6 bars (1s/bar)
// +++ END NEW CONSTANTS +++

// --- NEW: Mining Level Requirements ---
const COAL_MINE_LVL = 5;
const IRON_MINE_LVL = 10;

// --- NEW: Coal/Iron Mining Constants ---
const COAL_MINE_TIME_MS = 2000;
const COAL_MINE_XP = 20;
const COAL_MINE_ITEM = 'Coal Ore';

const IRON_MINE_TIME_MS = 3000;
const IRON_MINE_XP = 35;
const IRON_MINE_ITEM = 'Iron Ore';

// --- NEW: Crystal Mining Constants ---
const EARTH_CRYSTAL_LVL = 20;
const EARTH_CRYSTAL_TIME_MS = 4000;
const EARTH_CRYSTAL_XP = 50;
const EARTH_CRYSTAL_ITEM = 'Earth Crystal Shard';

const AIR_CRYSTAL_LVL = 30;
const AIR_CRYSTAL_TIME_MS = 5000;
const AIR_CRYSTAL_XP = 65;
const AIR_CRYSTAL_ITEM = 'Air Crystal Shard';

const WATER_CRYSTAL_LVL = 40;
const WATER_CRYSTAL_TIME_MS = 6000;
const WATER_CRYSTAL_XP = 80;
const WATER_CRYSTAL_ITEM = 'Water Crystal Shard';

const MINE_COOLDOWN_COPPER_MS = 1000; // 1.0s
const MINE_COOLDOWN_COAL_MS = 1500;   // 1.5s
const MINE_COOLDOWN_IRON_MS = 1500;   // 1.5s

// --- NEW: Blacksmith Level Requirements ---
const COPPER_BAR_LVL = 1;
const COPPER_PICKAXE_LVL = 2;
const COPPER_AXE_LVL = 2;
const COPPER_SWORD_LVL = 3;
const BLACKSMITH_COPPER_TIPS_LVL = 4; // +++ NEW +++
const COPPER_BOOTS_LVL = 5;
const COPPER_HELMET_LVL = 6;
const COPPER_PLATELEGS_LVL = 7; // +++ NEW +++
const COPPER_CHEST_LVL = 8;

const IRON_BAR_LVL = 11;
const IRON_PICKAXE_LVL = 12;
const IRON_AXE_LVL = 12;
const IRON_SWORD_LVL = 13;
const IRON_BOOTS_LVL = 15;
const IRON_HELMET_LVL = 16;
const IRON_PLATELEGS_LVL = 17; // +++ NEW +++
const IRON_CHEST_LVL = 18;

// --- NEW: Fletching Level Requirements ---
const FLETCHING_SHAFT_LVL = 1;
const FLETCHING_UNBOUND_LVL = 1;
const FLETCHING_COPPER_ARROW_LVL = 1;
const FLETCHING_UNSTRUNG_SOFTWOOD_LVL = 5; // +++ NEW +++
const FLETCHING_SOFTWOOD_BOW_LVL = 7;      // +++ NEW +++
const FLETCHING_UNSTRUNG_OAK_LVL = 15;     // +++ NEW +++
const FLETCHING_OAK_BOW_LVL = 17;          // +++ NEW +++

// --- NEW: Fletching Crafting Constants ---
const ARROW_SHAFT_WOOD_COST = 4;
const ARROW_SHAFT_YIELD = 10;
const ARROW_SHAFT_XP = 10;
const ARROW_SHAFT_TIME_MS = 3000;

const UNBOUND_ARROW_SHAFT_COST = 10;
const UNBOUND_ARROW_FEATHER_COST = 10;
const UNBOUND_ARROW_YIELD = 10;
const UNBOUND_ARROW_XP = 20;
const UNBOUND_ARROW_TIME_MS = 4000;

const COPPER_ARROW_UNBOUND_COST = 10;
const COPPER_ARROW_TIP_COST = 10;
const COPPER_ARROW_YIELD = 10;
const COPPER_ARROW_XP = 30;
const COPPER_ARROW_TIME_MS = 4000;

// +++ NEW: Bow Fletching Constants +++
const UNSTRUNG_SOFTWOOD_WOOD_COST = 1;
const UNSTRUNG_SOFTWOOD_YIELD = 1;
const UNSTRUNG_SOFTWOOD_XP = 20;
const UNSTRUNG_SOFTWOOD_TIME_MS = 3000;

const UNSTRUNG_OAK_WOOD_COST = 1;
const UNSTRUNG_OAK_YIELD = 1;
const UNSTRUNG_OAK_XP = 35;
const UNSTRUNG_OAK_TIME_MS = 4000;

const SOFTWOOD_BOW_UNSTRUNG_COST = 1;
const SOFTWOOD_BOW_STRING_COST = 1;
const SOFTWOOD_BOW_YIELD = 1;
const SOFTWOOD_BOW_XP = 25;
const SOFTWOOD_BOW_TIME_MS = 3000;

const OAK_BOW_UNSTRUNG_COST = 1;
const OAK_BOW_STRING_COST = 1;
const OAK_BOW_YIELD = 1;
const OAK_BOW_XP = 45;
const OAK_BOW_TIME_MS = 4000;

// --- NEW: Smithing Constants (Arrow Tips) ---
const COPPER_ARROW_TIP_BAR_COST = 4;
const COPPER_ARROW_TIP_YIELD = 10;
const COPPER_ARROW_TIP_XP = 20;
const COPPER_ARROW_TIP_TIME_MS = 3000;

// +++ NEW: Crafting Skill Constants +++
const CRAFTING_BOW_STRING_LVL = 1;
const BOW_STRING_SILK_COST = 2;
const BOW_STRING_YIELD = 1;
const BOW_STRING_XP = 15;
const BOW_STRING_TIME_MS = 2500;

const CRAFTING_EMPTY_VIAL_LVL = 5;
const EMPTY_VIAL_SAND_COST = 10;
const EMPTY_VIAL_COAL_COST = 3;
const EMPTY_VIAL_XP = 40;
const EMPTY_VIAL_TIME_MS = 4000;

// +++ NEW: Sand Mining Constants +++
const SAND_MINE_TIME_MS = 1500; // Fast to mine
const SAND_MINE_XP = 10;
const SAND_MINE_ITEM = 'Sand';
const MINE_COOLDOWN_SAND_MS = 1000;

// +++ NEW: Leather Crafting Constants +++
const CRAFTING_LEATHER_LVL = 1;
const LEATHER_HIDE_COST = 1;
const LEATHER_XP = 5;
const LEATHER_TIME_MS = 1500;

const CRAFTING_LEATHER_HOOD_LVL = 3;
const LEATHER_HOOD_LEATHER_COST = 5; 
const LEATHER_HOOD_XP = 20;
const LEATHER_HOOD_TIME_MS = 3000;

const CRAFTING_LEATHER_BODY_LVL = 7;
const LEATHER_BODY_LEATHER_COST = 10; 
const LEATHER_BODY_XP = 50;
const LEATHER_BODY_TIME_MS = 6000;

const CRAFTING_LEATHER_CHAPS_LVL = 5;
const LEATHER_CHAPS_LEATHER_COST = 10; 
const LEATHER_CHAPS_XP = 30;
const LEATHER_CHAPS_TIME_MS = 4000;

const CRAFTING_LEATHER_BOOTS_LVL = 1;
const LEATHER_BOOTS_LEATHER_COST = 5; 
const LEATHER_BOOTS_XP = 10;
const LEATHER_BOOTS_TIME_MS = 2000;

// +++ NEW: Cloth Crafting Constants +++
const CRAFTING_CLOTH_LVL = 1;
const CLOTH_SILK_COST = 5;
const CLOTH_YIELD = 1;
const CLOTH_XP = 20;
const CLOTH_TIME_MS = 2000;

// +++ NEW: Wizard Gear Crafting Constants +++
const CRAFTING_WIZARD_BOOTS_LVL = 2;
const WIZARD_BOOTS_CLOTH_COST = 5;
const WIZARD_BOOTS_XP = 10;
const WIZARD_BOOTS_TIME_MS = 2000;

const CRAFTING_WIZARD_HAT_LVL = 4;
const WIZARD_HAT_CLOTH_COST = 5;
const WIZARD_HAT_XP = 20;
const WIZARD_HAT_TIME_MS = 3000;

const CRAFTING_WIZARD_TROUSERS_LVL = 6;
const WIZARD_TROUSERS_CLOTH_COST = 10;
const WIZARD_TROUSERS_XP = 30;
const WIZARD_TROUSERS_TIME_MS = 4000;

const CRAFTING_WIZARD_ROBE_LVL = 8;
const WIZARD_ROBE_CLOTH_COST = 10;
const WIZARD_ROBE_XP = 50;
const WIZARD_ROBE_TIME_MS = 6000;

// +++ NEW: Magic Staff Crafting Constants +++
const CRAFTING_MAGIC_STAFF_LVL = 20;
const MAGIC_STAFF_OAK_COST = 10;
const MAGIC_STAFF_EARTH_COST = 10;
const MAGIC_STAFF_AIR_COST = 10;
const MAGIC_STAFF_WATER_COST = 10;
const MAGIC_STAFF_XP = 100;
const MAGIC_STAFF_TIME_MS = 8000;

// --- NEW: Iron Smithing Constants ---
const IRON_BAR_ORE_COST = 1; // 1 Iron Ore
const IRON_BAR_COAL_COST = 2; // 1 Coal Ore
const IRON_BAR_XP = 30;
const IRON_BAR_TIME_MS = 6000;

const IRON_HELMET_BAR_COST = 5;
const IRON_HELMET_XP = 150; 
const IRON_HELMET_TIME_MS = 7000; 

const IRON_CHESTPLATE_BAR_COST = 10;
const IRON_CHESTPLATE_XP = 300; 
const IRON_CHESTPLATE_TIME_MS = 12000; 

const IRON_BOOTS_BAR_COST = 4;
const IRON_BOOTS_XP = 120; 
const IRON_BOOTS_TIME_MS = 6000; 

// +++ NEW PLATELEGS CONSTANTS +++
const IRON_PLATELEGS_BAR_COST = 6;
const IRON_PLATELEGS_XP = 180; // 6 bars (30xp/bar)
const IRON_PLATELEGS_TIME_MS = 9000; // 6 bars (1.5s/bar)
// +++ END NEW CONSTANTS +++ 

const IRON_SHORTSWORD_BAR_COST = 5;
const IRON_SHORTSWORD_XP = 150;
const IRON_SHORTSWORD_TIME_MS = 7000;

// --- NEW: Woodcutting Level Requirements ---
const SOFTWOOD_TREE_LVL = 1;
const OAK_TREE_LVL = 10;

// --- NEW: Woodcutting Chop Constants ---
const SOFTWOOD_CHOP_TIME_MS = 1500;
const SOFTWOOD_CHOP_XP = 15;
const SOFTWOOD_CHOP_ITEM = 'Softwood';

const OAK_CHOP_TIME_MS = 3000;
const OAK_CHOP_XP = 35;
const OAK_CHOP_ITEM = 'Oak';

const CHOP_COOLDOWN_SOFTWOOD_MS = 1000;
const CHOP_COOLDOWN_OAK_MS = 1500;

// --- NEW: Tool Crafting Requirements ---
const COPPER_AXE_BAR_COST = 3;
const COPPER_AXE_WOOD_COST = 2;
const COPPER_AXE_XP = 25;
const COPPER_AXE_TIME_MS = 4000;

const COPPER_PICKAXE_BAR_COST = 4;
const COPPER_PICKAXE_WOOD_COST = 2;
const COPPER_PICKAXE_XP = 30;
const COPPER_PICKAXE_TIME_MS = 4500;

const IRON_AXE_BAR_COST = 3;
const IRON_AXE_WOOD_COST = 2;
const IRON_AXE_XP = 120;
const IRON_AXE_TIME_MS = 6000;

const IRON_PICKAXE_BAR_COST = 4;
const IRON_PICKAXE_WOOD_COST = 2;
const IRON_PICKAXE_XP = 140;
const IRON_PICKAXE_TIME_MS = 6500;

// --- NEW: Tool Tier Definitions ---
const PICKAXE_TIERS = { "Bronze Pickaxe": 1, "Copper Pickaxe": 2, "Iron Pickaxe": 3 };
const AXE_TIERS = { "Bronze Axe": 1, "Copper Axe": 2, "Iron Axe": 3 };

// --- NEW: Central Item Stat Definitions ---
const ITEM_STATS = {
  // --- Copper (Fighter) ---
  'Copper Helmet': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Chestplate': {
    armor: 2,
    armorType: 'fighter'
  },
  'Copper Boots': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Platelegs': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Shortsword': {
    damage: 1,
    styleBonus: 1, // Bonus for 'attack' style
    weaponType: 'melee'
  },
  
  // --- Iron (Fighter) ---
  'Iron Helmet': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Chestplate': {
    armor: 3,
    armorType: 'fighter'
  },
  'Iron Boots': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Platelegs': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Shortsword': {
    damage: 2,
    styleBonus: 1, // Bonus for 'attack' style
    weaponType: 'melee'
  },
  
  // --- Wizard Gear (Magic) ---
  'Wizard Hat': {
    armor: 1,
    armorType: 'magic'
  },
  'Wizard Robe': {
    armor: 2,
    armorType: 'magic'
  },
  'Wizard Trousers': {
    armor: 1,
    armorType: 'magic'
  },
  'Wizard Boots': {
    armor: 0, // Matches leather boots
    armorType: 'magic'
  },

  // --- Leather (Ranged) ---
  'Leather Hood': {
    armor: 1,
    speed: 1,
    armorType: 'ranged'
  },
  'Leather Body': {
    armor: 2,
    speed: 2,
    armorType: 'ranged'
  },
  'Leather Chaps': {
    armor: 1,
    speed: 1,
    armorType: 'ranged'
  },
  'Leather Boots': {
    armor: 0,
    speed: 1,
    armorType: 'ranged'
  },

  // --- Bows (Ranged) ---
  'Softwood Bow': {
    damage: 2,
    speed: 3,
    weaponType: 'ranged',
    twoHanded: true // <--- Added
  },
  'Oak Bow': {
    damage: 3,
    speed: 3,
    weaponType: 'ranged',
    twoHanded: true // <--- Added
  },
  // +++ NEW MAGIC STAFF +++
  'Magic Staff': {
    damage: 1,
    weaponType: 'magic',
    twoHanded: true 
  },
  // +++ NEW GOLD CROWN +++
  'Gold Crown': {
    armor: 2, // Same as Iron Helmet
    armorType: 'fighter'
  },
  // +++ NEW ADMIN WEAPON +++
  '1tapper': {
    damage: 10000, // Massive damage to 1-hit everything
    speed: 25,     // +25 Speed
    weaponType: 'melee'
  },
  // +++ NEW PET SPIDER +++
  'Pet Spider': {
    // No stats, cosmetic only
    type: 'pet'
  }
};
const SHOP_INVENTORY = new Array(20).fill(null);
SHOP_INVENTORY[0] = { name: 'Bronze Pickaxe', price: 10 };
SHOP_INVENTORY[1] = { name: 'Bronze Axe', price: 10 };
SHOP_INVENTORY[2] = { name: 'Fishing Pole', price: 2500 };
SHOP_INVENTORY[3] = { name: 'Fishing Bait', price: 10 };
// You can add more items here like:
// SHOP_INVENTORY[4] = { name: 'Some Item', price: 50 };

// --- NEW: Item Sell Prices ---
const ITEM_SELL_PRICES = {
  'Silk': 2, // +++ NEW +++
  
  // +++ NEW CLOTH & WIZARD ITEMS +++
  'Cloth': 12,
  'Wizard Hat': 30,
  'Wizard Robe': 70,
  'Wizard Trousers': 45,
  'Wizard Boots': 30,
  
  // Ores & Resources
  'Copper Ore': 1,
  'Coal Ore': 2,
  'Iron Ore': 4,
  'Softwood': 1,
  'Oak': 3,
  
  // Bars
  'Copper Bar': 3,
  'Iron Bar': 10,
  
  // Food
  'Raw Chicken': 1,
  'Cooked Chicken': 2,
  'Burnt Chicken': 1,
  'Beef': 2,
  'Cooked Beef': 3,
  'Burnt Beef': 1,
  
  // Bronze Tools (Shop items)
  'Bronze Pickaxe': 4,
  'Bronze Axe': 4,
  
  // Copper Items
  'Copper Pickaxe': 15,
  'Copper Axe': 15,
  'Copper Helmet': 20,
  'Copper Chestplate': 40,
  'Copper Platelegs': 25, // +++ NEW +++
  'Copper Boots': 15,
  'Copper Shortsword': 20,
  
  // Iron Items
  'Iron Pickaxe': 50,
  'Iron Axe': 50,
  'Iron Helmet': 60,
  'Iron Chestplate': 120,
  'Iron Platelegs': 75, // +++ NEW +++
  'Iron Boots': 55,
  'Iron Shortsword': 65,

  // Fletching Items
  'Feather': 1,
  'Arrow Shaft': 1,
  'Copper Arrow Tip': 2,
  'Unbound Arrow': 3,
  'Copper Arrow': 5,

  // +++ NEW CRYSTAL PRICES +++
  'Earth Crystal Shard': 5,
  'Air Crystal Shard': 8,
  'Water Crystal Shard': 12,
  
  // +++ NEW CRAFTING/FLETCHING ITEM SELL PRICES +++
  'Bow String': 3,
  'Unstrung Softwood Bow': 5,
  'Unstrung Oak Bow': 10,
  'Softwood Bow': 10,
  'Oak Bow': 20,
  'Cow Hide': 4,
  'Leather': 6,
  'Leather Hood': 10,
  'Leather Body': 25,
  'Leather Chaps': 15,
  'Leather Boots': 8,
  
  // +++ NEW FISHING PRICES +++
  'Herring': 2,
  'Trout': 4,
  'Salmon': 8,
  
  // +++ NEW COOKED FISH PRICES +++
  'Cooked Herring': 3,
  'Burnt Herring': 1,
  'Cooked Trout': 6,
  'Burnt Trout': 2,
  'Cooked Salmon': 10,
  'Burnt Salmon': 4,
  
  // +++ NEW FISHING REQUIREMENTS SELL PRICES +++
  'Fishing Pole': 1000,
  'Fishing Bait': 4,
  'Magic Staff': 50,
  
  // +++ NEW ELEMENTAL STONE PRICES +++
  'Earthstone': 10,
  'Airstone': 15,
  'Waterstone': 20,
  'Gold Crown': 50000,
  'Gold Bar': 250,   // +++ NEW +++
  'Diamond': 2500,   // +++ NEW +++
  '1tapper': 0,      // +++ ADMIN ITEM (No Value) +++
  'Rat Tail': 3,      // +++ NEW ITEM SELL PRICE +++
  'Sand': 1,
  'Empty Vial': 5,
  'Venom': 15
};
// --- END: Item Sell Prices ---

// --- END: Item Stat Definitions ---

// --- QUEST LINES DATABASE ---
const QUEST_LINES = {
  'tutorial': {
    name: "The Beginning",
    desc: "Learn the basics of survival and combat.",
    quests: [
      {
        id: "tut_1",
        name: "The Foundation",
        desc: "We need to reinforce the camp. Bring me materials to build better defenses.",
        type: 'gather',
        reqItems: [
          { name: 'Copper Ore', qty: 100 },
          { name: 'Softwood', qty: 100 }
        ],
        rewards: { gold: 500 }
      },
      {
        id: "tut_2",
        name: "Feathered Fury",
        desc: "The chickens at the farm are getting aggressive. Thin their numbers.",
        type: 'kill',
        targetEnemy: 'Chicken',
        targetCount: 50,
        reqSkill: { skill: 'attack', level: 10 },
        rewards: { gold: 1000 }
      },
      
      // --- River Bounty (Moved Up) ---
      {
        id: "tut_2_fishing",
        name: "River Bounty",
        desc: "The camp needs food supplies. The river is teeming with Trout.",
        type: 'gather',
        reqItems: [
          { name: 'Trout', qty: 200 }
        ],
        reqSkill: { skill: 'fishing', level: 5 },
        rewards: { gold: 1500 }
      },

      // --- Beefy Business (Cows) ---
      {
        id: "tut_2_cows",
        name: "Beefy Business",
        desc: "The cows have gone mad! Put them to rest before they stampede the camp.",
        type: 'kill',
        targetEnemy: 'Cow',
        targetCount: 30,
        rewards: { gold: 1200 }
      },

      // --- Suit Up (Leather) ---
      {
        id: "tut_2_leather",
        name: "Suit Up",
        desc: "We need armor for our scouts to fight off intruders. Bring me a full set of Leather Armor.",
        type: 'gather',
        reqSkill: { skill: 'crafting', level: 7 },
        reqItems: [
          { name: 'Leather Hood', qty: 1 },
          { name: 'Leather Body', qty: 1 },
          { name: 'Leather Chaps', qty: 1 },
          { name: 'Leather Boots', qty: 1 }
        ],
        rewards: { gold: 2500 }
      },

      {
        id: "tut_3",
        name: "Web of Lies",
        desc: "The cave spiders are spinning webs all over our equipment. Clear them out!",
        type: 'kill',
        targetEnemy: 'Spider',
        targetCount: 100,
        rewards: { 
            gold: 1000, 
            items: [{ name: 'Cooked Herring', qty: 25 }] 
        }
      },
      // +++ NEW QUEST: Vials (Does not consume items) +++
      {
        id: "tut_4",
        name: "Glass Reserves",
        desc: "We need to ensure we have enough glassware for alchemy. Show me you have a stock of Empty Vials.",
        type: 'gather',
        consume: false, // <--- This flag prevents item removal
        reqItems: [
          { name: 'Empty Vial', qty: 100 }
        ],
        rewards: { gold: 2500 }
      },
      // +++ NEW QUEST: Venom (Consumes items) +++
      {
        id: "tut_5",
        name: "Potent Poison",
        desc: "The Centipedes carry a deadly toxin. Bring me their Venom so we can study it.",
        type: 'gather',
        // consume defaults to true
        reqItems: [
          { name: 'Venom', qty: 100 }
        ],
        rewards: { gold: 2500 }
      }
    ]
  }
};

function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) return n.toString();
  if (n < 1000000) return parseFloat((n / 1000).toFixed(2)) + 'k';
  return parseFloat((n / 1000000).toFixed(2)) + 'M';
}

function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  renderEquipment(); // <-- ADD THIS
  backToActions(); 
}

function updateHPUI(){
  // Calculate new maxHP based on Vitality level (1 HP per level starting at Lvl 1)
  game.maxHP = 10 + (game.vitality ? (game.vitality.level - 1) : 0);
  
  // Ensure current HP doesn't exceed max HP after a level up
  game.hp = Math.min(game.hp, game.maxHP); 
  
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}


/**
 * Calculates all player combat stats based on levels and equipment.
 */
function getPlayerCombatStats() {
  // 1. Get equipped weapon type
  let equippedWeaponType = 'melee'; // Default
  if (game.equipment.weapon && ITEM_STATS[game.equipment.weapon.name]) {
    equippedWeaponType = ITEM_STATS[game.equipment.weapon.name].weaponType || 'melee';
  }
  
  // 2. Base Stats from *Equipment Only*
  let equipmentStats = {
    equipmentDamage: 0, // Physical
    equipmentMagicDamage: 0, // +++ NEW +++
    equipmentArmor: 0, 
    equipmentSpeed: 0,
  };

  // 3. Add Equipment Bonuses (with new penalty logic)
  for (const [slotType, item] of Object.entries(game.equipment)) {
    if (item && ITEM_STATS[item.name]) {
      const itemStats = ITEM_STATS[item.name];
      const itemArmorType = itemStats.armorType; // 'fighter', 'ranged', or undefined

      // --- Add Damage (Split by type) ---
      if (itemStats.weaponType === 'magic') {
          // Magic staff damage is now just a token 1 damage which gets added to spell damage
          equipmentStats.equipmentMagicDamage += itemStats.damage || 0;
      } else {
          equipmentStats.equipmentDamage += itemStats.damage || 0;
      }

      // --- Add Armor (no penalty) ---
      let armorBonus = itemStats.armor || 0;
      equipmentStats.equipmentArmor += armorBonus;
      
      // --- Add Speed (with penalty) ---
      let speedBonus = itemStats.speed || 0; // Get the item's base speed

      if (equippedWeaponType === 'melee' && itemArmorType === 'ranged') {
        // *** NEW MELEE PENALTY ***
        // Melee user wearing light armor gets a speed penalty.
        // This flat -3 penalty will add +0.3s to the attack time PER PIECE.
        speedBonus = -3;
        
      } else if (equippedWeaponType === 'ranged' && itemArmorType === 'fighter') {
        // *** NEW HARSH PENALTY ***
        // Ranged user wearing heavy armor gets a HUGE speed penalty.
        // This flat -7.5 penalty will add +0.75s to the attack time PER PIECE.
        speedBonus = -7.5; 
      }
      
      equipmentStats.equipmentSpeed += speedBonus;

      // --- Add Style Bonus (Melee only) ---
      if (itemStats.weaponType === 'melee' && game.playerAttackStyle === 'attack') {
        equipmentStats.equipmentDamage += itemStats.styleBonus || 0;
      }
    }
  }
  
  // 4. Calculate Final Stats (Base + Skills + Equipment)
  const finalStats = {};
  const isRanged = (equippedWeaponType === 'ranged');
  const style = game.playerAttackStyle;

  // --- Define Style Bonuses ---
  let styleDamageBonus = 0;
  let styleArmorBonus = 0;
  let styleAccuracyBonus = 0;
  let offensiveSkillLevel = 0; // This will be Ranged Lvl or Attack Lvl

  if (style === 'aggressive') {
    styleDamageBonus = 2;
    styleAccuracyBonus = -5;
  } else if (style === 'accurate') {
    styleDamageBonus = -1;
    styleAccuracyBonus = 10;
  } else if (style === 'defence') {
    styleDamageBonus = -1;
    styleArmorBonus = 2;
    styleAccuracyBonus = -5;
  }
  
  // --- Damage Calculation ---
  let skillMaxHit = 0;
  
  if (equippedWeaponType === 'magic') {
    // +++ NEW MAGIC FORMULA +++
    skillMaxHit = 1 + Math.floor(game.magic.level / 4);
    offensiveSkillLevel = game.magic.level;
    finalStats.magicDamage = Math.max(1, skillMaxHit + equipmentStats.equipmentMagicDamage);
    finalStats.physicalDamage = 0; // No physical damage with magic
  } else if (isRanged) {
    skillMaxHit = 1 + Math.floor(game.ranged.level / 4);
    offensiveSkillLevel = game.ranged.level;
    finalStats.physicalDamage = Math.max(1, skillMaxHit + equipmentStats.equipmentDamage + styleDamageBonus);
    finalStats.magicDamage = 0;
  } else {
    // Melee
    skillMaxHit = 1 + Math.floor(game.strength.level / 4);
    offensiveSkillLevel = game.attack.level;
    finalStats.physicalDamage = Math.max(1, skillMaxHit + equipmentStats.equipmentDamage + styleDamageBonus);
    finalStats.magicDamage = 0;
  }

  // --- Armor ---
  const skillArmor = Math.floor(game.defence.level / 5);
  finalStats.armor = skillArmor + equipmentStats.equipmentArmor + styleArmorBonus;
  
  // --- Attack Speed ---
  const speedReduction = equipmentStats.equipmentSpeed * 100; // 0.1s per speed point
  finalStats.attackSpeed = Math.max(1200, 4000 - speedReduction); // 4.0s base
  
  // --- Pass offensive skill and accuracy bonus ---
  finalStats.offensiveSkillLevel = offensiveSkillLevel;
  finalStats.accuracyBonus = styleAccuracyBonus;
  
  // Also pass through the equipment-only bonuses for the UI display
  finalStats.equipmentDamage = equipmentStats.equipmentDamage;
  finalStats.equipmentMagicDamage = equipmentStats.equipmentMagicDamage; // +++ NEW +++
  finalStats.equipmentArmor = equipmentStats.equipmentArmor;
  finalStats.equipmentSpeed = equipmentStats.equipmentSpeed;
  
  return finalStats;
}


/**
 * Renders the equipment in both the main sidebar and combat UI.
 */
function renderEquipment() {
  // --- 1. Calculate current stats ---
  const stats = getPlayerCombatStats();
  
  // --- 2. Update the Stats Display (in the new panel) ---
  setText('stat-phys-dmg-panel', `+${stats.equipmentDamage}`);
  setText('stat-magic-dmg-panel', `+${stats.equipmentMagicDamage}`); // +++ NEW +++
  setText('stat-armor-panel', `+${stats.equipmentArmor}`);
  // --- MODIFICATION: Show equipment speed bonus, not final time ---
  const speedBonus = stats.equipmentSpeed;
  const speedText = speedBonus >= 0 ? `+${speedBonus}` : `${speedBonus}`; // Show + sign for positive
  setText('stat-speed-panel', speedText);
  // --- END MODIFICATION ---

  // --- NEW: Add tooltips to the stats panel rows ---
  
  // 1. Get the parent row for each stat
  const dmgRow = document.getElementById('stat-phys-dmg-panel')?.closest('.stat-row');
  const magicDmgRow = document.getElementById('stat-magic-dmg-panel')?.closest('.stat-row'); // +++ NEW +++
  const armorRow = document.getElementById('stat-armor-panel')?.closest('.stat-row');
  const speedRow = document.getElementById('stat-speed-panel')?.closest('.stat-row');

  // 2. Damage Tooltip
  if (dmgRow) {
    const dmgValue = stats.equipmentDamage >= 0 ? `+${stats.equipmentDamage}` : stats.equipmentDamage;
    dmgRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${dmgValue} Physical Damage</div>`);
    dmgRow.onmouseleave = hideTooltip;
  }

  // +++ NEW MAGIC DAMAGE TOOLTIP +++
  if (magicDmgRow) {
    const magicDmgValue = stats.equipmentMagicDamage >= 0 ? `+${stats.equipmentMagicDamage}` : stats.equipmentMagicDamage;
    magicDmgRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${magicDmgValue} Magic Damage</div>`);
    magicDmgRow.onmouseleave = hideTooltip;
  }

  // 3. Armor Tooltip
  if (armorRow) {
    const armorValue = stats.equipmentArmor >= 0 ? `+${stats.equipmentArmor}` : stats.equipmentArmor;
    armorRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${armorValue} Armor</div>`);
    armorRow.onmouseleave = hideTooltip;
  }

  // 4. Speed Tooltip (Shows final attack speed in seconds)
  if (speedRow) {
    const finalSpeedInSeconds = (stats.attackSpeed / 1000).toFixed(1);
    speedRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${finalSpeedInSeconds}s Attack Speed</div>`);
    speedRow.onmouseleave = hideTooltip;
  }
  
  // --- END NEW ---

  // --- 3. Update Equipment Slots & Tooltips ---
  // <-- UPDATED this array with all new slots -->
  const slots = [
    'necklace', 'helmet', 'cape', 
    'weapon', 'chest', 'shield', 
    'ring1', 'legs', 'ring2', 
    'arrows', 'boots', 'pet' // <-- ADDED PET
  ];
  
  // <-- UPDATED this map with existing item images -->
  const itemImageMap = {
    'Copper Helmet': 'copperhelmet',
    'Copper Chestplate': 'copperchestplate',
    'Copper Shortsword': 'coppershortsword',
    'Copper Boots': 'copperboots',
    'Iron Helmet': 'ironhelmet',
    'Iron Chestplate': 'ironchestplate',
    'Iron Shortsword': 'ironshortsword',
    'Iron Boots': 'ironboots',
    'Copper Platelegs': 'copperplatelegs', // +++ NEW +++
    'Iron Platelegs': 'ironplatelegs', // +++ NEW +++

    // +++ NEW BOWS +++
    'Softwood Bow': 'softwoodbow',
    'Oak Bow': 'oakbow',
    
    // +++ NEW ARROWS (THIS IS A FIX) +++
    'Copper Arrow': 'copperarrow',
    // +++ NEW LEATHER +++
    'Leather Hood': 'leatherhood',
    'Leather Body': 'leatherarmor',
    'Leather Chaps': 'leatherpants',
    'Leather Boots': 'leatherboots',
    
    // +++ NEW WIZARD GEAR +++
    'Wizard Hat': 'wizardhat',
    'Wizard Robe': 'wizardrobe',
    'Wizard Trousers': 'wizardtrousers',
    'Wizard Boots': 'wizardboots',
    'Magic Staff': 'magicstaff',
    'Gold Crown': 'goldcrown',
    '1tapper': '1tapper', // +++ NEW +++
    'Pet Spider': 'petspider' // +++ NEW PET IMAGE +++
  };

slots.forEach(slotType => {
    const item = game.equipment[slotType];
    
    // Get the Main Sidebar Slot
    const mainSlotEl = document.getElementById(slotType);
    
    let imgName = '';
    if (item) {
      imgName = itemImageMap[item.name];
    } else {
      // Use placeholder images
      if (slotType === 'helmet') imgName = 'helmet';
      else if (slotType === 'chest') imgName = 'chestplate';
      else if (slotType === 'weapon') imgName = 'weapon';
      else if (slotType === 'boots') imgName = 'boots';
      else if (slotType === 'necklace') imgName = 'necklace';
      else if (slotType === 'cape') imgName = 'cape';
      else if (slotType === 'shield') imgName = 'shield';
      else if (slotType === 'legs') imgName = 'legs';
      else if (slotType === 'ring1') imgName = 'ring';
      else if (slotType === 'ring2') imgName = 'ring';
      else if (slotType === 'arrows') imgName = 'arrows';
      else if (slotType === 'pet') imgName = 'pet'; // <-- NEW PET PLACEHOLDER
    }
    
    // +++ 2H VISUAL LOGIC (Define the variable here) +++
    // Check if this is the shield slot and we have a 2H weapon equipped
    let isTwoHandedBlock = false;
    if (slotType === 'shield' && !item) {
        const weapon = game.equipment.weapon;
        if (weapon && ITEM_STATS[weapon.name] && ITEM_STATS[weapon.name].twoHanded) {
            isTwoHandedBlock = true;
            // Use the weapon's image for the shield slot too
            imgName = itemImageMap[weapon.name]; 
        }
    }

    let imgHtml = `<img src="images/${imgName}.png" alt="${slotType}">`;
    
    // If it's a 2H block, make the image semi-transparent
    if (isTwoHandedBlock) {
        imgHtml = `<img src="images/${imgName}.png" alt="${slotType}" style="opacity: 0.5; filter: grayscale(50%);">`;
    }

    const itemStats = item ? ITEM_STATS[item.name] : null;

    // --- Generate Stat Tooltip HTML ---
    let statsHtml = '';
    if (itemStats) {
      if (itemStats.damage) {
        // +++ FIX: Check weapon type to display correct label +++
        if (itemStats.weaponType === 'magic') {
           statsHtml += `<div style="color:#aaffaa;">+${itemStats.damage} Magic Damage</div>`;
        } else {
           statsHtml += `<div style="color:#aaffaa;">+${itemStats.damage} Physical Damage</div>`;
        }
      }
      if (itemStats.styleBonus) statsHtml += `<div style="color:#aaffaa;">+${itemStats.styleBonus} Physical Damage (if accurate)</div>`;
      if (itemStats.armor) statsHtml += `<div style="color:#aaffaa;">+${itemStats.armor} Armor</div>`;
      if (itemStats.speed) statsHtml += `<div style="color:#aaffaa;">+${itemStats.speed} Speed</div>`;
    }
    
    // --- NEW: Add quantity string for arrows ---
    let qtyHtml = '';
    if (item && slotType === 'arrows') {
        qtyHtml = `<div style="color:#fff;">Amount: ${item.qty.toLocaleString()}</div>`;
    }

    // Update Main Sidebar Slot
    if (mainSlotEl) {
      mainSlotEl.innerHTML = imgHtml; // Set the image first
      
      // --- NEW: Add quantity display for arrows ---
      if (item && slotType === 'arrows' && item.qty > 0) {
          const amt = document.createElement('div');
          amt.className = 'inv-amount';
          amt.innerText = formatAmount(item.qty); 
          mainSlotEl.appendChild(amt);
      }
      
      // +++ 2H CLICK LOGIC +++
      // If clicking the shield slot while holding a 2H weapon, unequip the WEAPON
      if (isTwoHandedBlock) {
         mainSlotEl.onclick = () => unequipItem('weapon');
         mainSlotEl.style.cursor = 'pointer';
      } else {
         mainSlotEl.onclick = () => unequipItem(slotType);
      }
      
      if (item) {
        mainSlotEl.onmouseenter = (evt) => {
          const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
            ${qtyHtml} 
            ${statsHtml}
            <div style="color:#ffaaaa; margin-top: 5px;">Click to unequip...</div>
          `;
          showTooltip(evt, tooltipContent);
        };
        mainSlotEl.onmouseleave = hideTooltip;
      } 
      // +++ 2H TOOLTIP LOGIC +++
      else if (isTwoHandedBlock) {
         mainSlotEl.onmouseenter = (evt) => {
            const weapon = game.equipment.weapon;
            const weaponName = weapon ? weapon.name : 'Weapon';
             const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${weaponName}</div>
            <div style="color:#ccc;">(Occupies Both Hands)</div>
            <div style="color:#ffaaaa; margin-top: 5px;">Click to unequip weapon...</div>
          `;
          showTooltip(evt, tooltipContent);
         };
         mainSlotEl.onmouseleave = hideTooltip;
      }
      else {
        mainSlotEl.onmouseenter = null;
        mainSlotEl.onmouseleave = null;
      }
    }
  });
}

function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount);
  updateGoldUI();
}

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;

  for(let i = 0; i < capacity; i++){
    const slotData = game.inventory[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    if(slotData){
      slot.draggable = true;
      const item = slotData;
      const img = document.createElement('img');
              let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
              if (item.name === 'Copper Bar') imgName = 'copperbar';
              else if (item.name === 'Copper Chestplate') imgName = 'copperchestplate';
              else if (item.name === 'Copper Shortsword') imgName = 'coppershortsword';
              else if (item.name === 'Copper Helmet') imgName = 'copperhelmet';
              else if (item.name === 'Copper Boots') imgName = 'copperboots';
              else if (item.name === 'Raw Chicken') imgName = 'rawchicken';
              else if (item.name === 'Cooked Chicken') imgName = 'cookedchicken';
              else if (item.name === 'Burnt Chicken') imgName = 'burntchicken';
              
              // +++ NEW COOKED FISH IMAGES +++
              else if (item.name === 'Cooked Herring') imgName = 'cookedherring';
              else if (item.name === 'Burnt Herring') imgName = 'burntherring';
              else if (item.name === 'Cooked Trout') imgName = 'cookedtrout';
              else if (item.name === 'Burnt Trout') imgName = 'burnttrout';
              else if (item.name === 'Cooked Salmon') imgName = 'cookedsalmon';
              else if (item.name === 'Burnt Salmon') imgName = 'burntsalmon';
              
              // +++ NEW BEEF IMAGES +++
              else if (item.name === 'Beef') imgName = 'beef';
              else if (item.name === 'Cooked Beef') imgName = 'cookedbeef';
              else if (item.name === 'Burnt Beef') imgName = 'burntbeef';

              // +++ FIX: Add Gold Crown mapping here +++
              else if (item.name === 'Gold Crown') imgName = 'goldcrown'; 
              // +++ END NEW +++

              else if (item.name === 'Coal Ore') imgName = 'coalore';
              else if (item.name === 'Iron Ore') imgName = 'ironore';
              else if (item.name === 'Iron Bar') imgName = 'ironbar';
              else if (item.name === 'Iron Helmet') imgName = 'ironhelmet';
              else if (item.name === 'Iron Chestplate') imgName = 'ironchestplate';
              else if (item.name === 'Iron Boots') imgName = 'ironboots';
              else if (item.name === 'Iron Shortsword') imgName = 'ironshortsword';
              else if (item.name === 'Copper Platelegs') imgName = 'copperplatelegs'; // +++ NEW +++
              else if (item.name === 'Iron Platelegs') imgName = 'ironplatelegs'; // +++ NEW +++
              else if (item.name === 'Softwood') imgName = 'softwood';
              else if (item.name === 'Oak') imgName = 'oak';
              else if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe'; // +++ NEW +++
              else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe'; // +++ NEW +++
              else if (item.name === 'Copper Pickaxe') imgName = 'copperpickaxe'; // +++ NEW +++
              else if (item.name === 'Copper Axe') imgName = 'copperaxe'; // +++ NEW +++
              else if (item.name === 'Iron Pickaxe') imgName = 'ironpickaxe'; // +++ NEW +++
              else if (item.name === 'Iron Axe') imgName = 'ironaxe'; // +++ NEW +++
              else if (item.name === 'Feather') imgName = 'feather'; // +++ NEW +++
              else if (item.name === 'Arrow Shaft') imgName = 'arrowshaft'; // +++ NEW +++
              else if (item.name === 'Copper Arrow Tip') imgName = 'copperarrowtip'; // +++ NEW +++
              else if (item.name === 'Unbound Arrow') imgName = 'unboundarrow'; // +++ NEW +++
              else if (item.name === 'Copper Arrow') imgName = 'copperarrow'; // +++ NEW +++
              else if (item.name === 'Silk') imgName = 'silk'; // +++ NEW +++
              
              // +++ NEW CLOTH & WIZARD ITEMS +++
              else if (item.name === 'Cloth') imgName = 'cloth';
              else if (item.name === 'Wizard Hat') imgName = 'wizardhat';
              else if (item.name === 'Wizard Robe') imgName = 'wizardrobe';
              else if (item.name === 'Wizard Trousers') imgName = 'wizardtrousers';
              else if (item.name === 'Wizard Boots') imgName = 'wizardboots';
              else if (item.name === 'Magic Staff') imgName = 'magicstaff'; // +++ NEW +++
              else if (item.name === 'Pet Spider') imgName = 'petspider'; // +++ NEW PET +++
              else if (item.name === 'Rat Tail') imgName = 'rattail'; // +++ NEW ITEM +++
              else if (item.name === 'Sand') imgName = 'sand'; // +++ NEW +++
              else if (item.name === 'Empty Vial') imgName = 'emptyvial'; // +++ NEW +++
              else if (item.name === 'Venom') imgName = 'venom'; // +++ NEW +++
              
              // +++ NEW CRYSTAL SHARDS +++
              else if (item.name === 'Earth Crystal Shard') imgName = 'earthcrystalshard';
              else if (item.name === 'Air Crystal Shard') imgName = 'aircrystalshard';
              else if (item.name === 'Water Crystal Shard') imgName = 'watercrystalshard';

              // --- THIS IS THE FIX ---
              else if (item.name === 'Bow String') {
                  imgName = 'bowstring';
              } else if (item.name === 'Unstrung Softwood Bow') {
                  imgName = 'unstrungsoftwoodbow';
              } else if (item.name === 'Unstrung Oak Bow') {
                  imgName = 'unstrungoakbow';
              } else if (item.name === 'Softwood Bow') {
                  imgName = 'softwoodbow';
              } else if (item.name === 'Oak Bow') {
                  imgName = 'oakbow';
              }

// +++ NEW LEATHER +++
              else if (item.name === 'Cow Hide') {
                  imgName = 'cowhide';
              } else if (item.name === 'Leather') {
                  imgName = 'leather';
              } else if (item.name === 'Leather Hood') {
                  imgName = 'leatherhood';
              } else if (item.name === 'Leather Body') {
                  imgName = 'leatherarmor';
              } else if (item.name === 'Leather Chaps') {
                  imgName = 'leatherpants';
              } else if (item.name === 'Leather Boots') {
                  imgName = 'leatherboots';
              }

              // +++ NEW FISHING ITEMS +++
              else if (item.name === 'Herring') {
                  imgName = 'herring';
              } else if (item.name === 'Trout') {
                  imgName = 'trout';
              } else if (item.name === 'Salmon') {
                  imgName = 'salmon';
              } else if (item.name === 'Fishing Pole') {
                  imgName = 'fishingpole';
              } else if (item.name === 'Fishing Bait') {
                  imgName = 'fishingbait';
              }

              // --- END OF FIX ---
              img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      let clickAction = '';
      const stats = ITEM_STATS[itemName];

      if (stats) {
        // This is equipable
        if (stats.damage) {
            // +++ FIX: Check weapon type to display correct label +++
            if (stats.weaponType === 'magic') {
                itemStats += `<div style="color:#aaffaa;">+${stats.damage} Magic Damage</div>`;
            } else {
                itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
            }
        }
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to equip...</div>';
      
      } else if (itemName === 'Cooked Chicken') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_CHICKEN_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Herring') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_HERRING_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Trout') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_TROUT_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Salmon') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_SALMON_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Beef') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_BEEF_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
        ${itemStats}
        ${clickAction}
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      
      const itemQty = item.qty; 
      const slotIndex = i; 
      slot.onclick = (event) => {
        handleItemClick(event, itemName, itemQty, slotIndex);
      };
    } else {
      slot.draggable = false;
    }
    grid.appendChild(slot);
  }
}

// =================================================================
// --- 1. REPLACED 'addItem' FUNCTION (non-module script) ---
// This function now correctly handles multiple stacks.
// =================================================================
function addItem(name, qty = 1) {
  let amountToAdd = qty;

  // 1. Try to stack in existing slots first
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      slot.qty += amountToAdd;
      amountToAdd = 0;
      break; // Found a stack, stop looking
    }
  }

  // 2. If items are left (no existing stack found), find an empty slot
  if (amountToAdd > 0) {
    let emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex > -1) {
      game.inventory[emptySlotIndex] = { name: name, qty: amountToAdd };
      amountToAdd = 0;
    } else {
      console.warn(`Inventory full! Could not add ${amountToAdd} ${name}`);
      // Note: We don't return, so the inventory still renders
    }
  }

  if (!game.isDragging) {
    renderInventoryGrid();
  }
}

// =================================================================
// --- 2. REPLACED 'removeItem' FUNCTION (non-module script) ---
// This function now correctly removes from multiple stacks.
// =================================================================
function removeItem(name, qty = 1) {
  let amountToRemove = qty;
  let totalAvailable = 0;

  // 1. First, check if we even have enough across ALL stacks
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      totalAvailable += slot.qty;
    }
  }

  if (totalAvailable < amountToRemove) {
    console.warn(`Tried to remove ${qty} ${name}, but only have ${totalAvailable}`);
    return false; // Not enough items
  }

  // 2. If we have enough, remove them. Iterate backwards is safer.
  for (let i = game.inventory.length - 1; i >= 0; i--) {
    const slot = game.inventory[i];
    if (slot && slot.name === name) {
      if (slot.qty > amountToRemove) {
        // This stack has more than we need
        slot.qty -= amountToRemove;
        amountToRemove = 0;
      } else {
        // This stack will be emptied
        amountToRemove -= slot.qty;
        game.inventory[i] = null; // Empty the slot
      }
    }
    if (amountToRemove === 0) break; // We're done
  }
  
  // +++ FIX: Update UI immediately +++
  renderInventoryGrid();
  
  return true; // Successfully removed
}

/**
 * Checks if the inventory has space for a given item.
 * Returns true if there is an empty slot OR an existing stack of that item.
 * @param {string} itemName - The name of the item to check for.
 * @returns {boolean}
 */
function canReceiveItem(itemName) {
  let hasEmptySlot = false;
  let hasStack = false;

  for (const slot of game.inventory) {
    if (slot === null) {
      hasEmptySlot = true;
      break; // Found an empty slot, we can stop
    }
    if (slot.name === itemName) {
      hasStack = true;
      break; // Found an existing stack, we can stop
    }
  }
  return hasEmptySlot || hasStack;
}
// =================================================================
// --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
// =================================================================

async function handleSellItemClick(itemName, currentQty) {
  if (!game.shopOpen) return;
  
  // --- MODIFIED: Look up sell price in the new map ---
  const sellPrice = ITEM_SELL_PRICES[itemName] || 0;

  if (sellPrice <= 0) {
    await showGameAlert("Cannot Sell", "This shop doesn't buy that item."); // Replaced alert
    return;
  }
  // --- END MODIFICATION ---
  
  let totalQty = 0;
  for (const slot of game.inventory) {
      if(slot && slot.name === itemName) {
          totalQty += slot.qty;
      }
  }

  let qtyToSell = 0;
  if (totalQty === 1) {
    qtyToSell = 1;
  } else {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Sell ${itemName}`, 
      `How many ${itemName} do you want to sell? (You have: ${totalQty}) (Price: ${sellPrice}ea)`, 
      totalQty
    );
    if (input === null) return;
    qtyToSell = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToSell) || qtyToSell <= 0) return;
  if (qtyToSell > totalQty) {
    await showGameAlert("Invalid Amount", "You don't have that many to sell."); // Replaced alert
    return;
  }
  
  const totalGold = qtyToSell * sellPrice;
  
  const confirmed = await showGameConfirm( // <-- USE 'await showGameConfirm'
    "Confirm Sale", 
    `Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`
  );
  
  if (confirmed) {
    if (removeItem(itemName, qtyToSell)) {
        addGold(totalGold);
        hideTooltip(); 
        renderInventoryGrid();
        if (game.inTrade) {
          renderTradeInventory();
        }
        await showGameAlert("Sale Complete", `You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`); // Replaced alert
    } else {
        await showGameAlert("Error", "Something went wrong, the sale did not complete."); // Replaced alert
    }
  }
}

function handleItemClick(event, itemName, itemQty, slotIndex) {
  // Always close any open menu first
  hideItemContextMenu();

  // --- NEW: Define equipable items and their slots ---
  const equipableItems = {
    'Copper Helmet': 'helmet',
    'Copper Chestplate': 'chest',
    'Copper Shortsword': 'weapon',
    'Copper Boots': 'boots',
    'Iron Helmet': 'helmet',
    'Iron Chestplate': 'chest',
    'Iron Shortsword': 'weapon',
    'Iron Boots': 'boots',
    'Copper Platelegs': 'legs', // +++ NEW +++
    'Iron Platelegs': 'legs', // +++ NEW +++
    
    // +++ NEW BOWS +++
    'Softwood Bow': 'weapon',
    'Oak Bow': 'weapon',
    
    // +++ NEW ARROWS (THIS IS THE FIX) +++
    'Copper Arrow': 'arrows',
    // +++ NEW LEATHER +++
    'Leather Hood': 'helmet',
    'Leather Body': 'chest',
    'Leather Chaps': 'legs',
    'Leather Boots': 'boots',
    
    // +++ NEW WIZARD GEAR +++
    'Wizard Hat': 'helmet',
    'Wizard Robe': 'chest',
    'Wizard Trousers': 'legs',
    'Wizard Boots': 'boots',
    'Magic Staff': 'weapon',
    'Gold Crown': 'helmet',
    '1tapper': 'weapon', // +++ NEW +++
    'Pet Spider': 'pet' // +++ NEW PET SLOT +++
  };
  const itemSlotType = equipableItems[itemName];
  // --- END NEW ---

  if (game.shopOpen) {
    // If shop is open, we're selling
    handleSellItemClick(itemName, itemQty);
  } else if (itemSlotType) {
    // --- NEW: This is an equipable item! ---
    // We pass the slot *type* (e.g., 'helmet') and the inventory *index*
    equipItem(itemSlotType, slotIndex);
  } else if (itemName === 'Cooked Chicken' || itemName === 'Cooked Beef' || itemName === 'Cooked Herring' || itemName === 'Cooked Trout' || itemName === 'Cooked Salmon') {
    // Not in shop, not equipable, and it's food. Show eat menu.
    showItemContextMenu(event, itemName);
  }
  // Other items (like ores) do nothing when clicked.
}

// NEW: Shows the right-click-style menu
function showItemContextMenu(event, itemName) {
  const menu = document.getElementById('itemContextMenu');
  let menuContent = '';

  if (itemName === 'Cooked Chicken') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedChicken()">Eat</button>`;
  } else if (itemName === 'Cooked Beef') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedBeef()">Eat</button>`;
  } else if (itemName === 'Cooked Herring') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedHerring()">Eat</button>`;
  } else if (itemName === 'Cooked Trout') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedTrout()">Eat</button>`;
  } else if (itemName === 'Cooked Salmon') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedSalmon()">Eat</button>`;
  }
  
  // We can add other options here later (e.g., "Drop")
  
  if (menuContent) {
    menu.innerHTML = menuContent;
    menu.style.display = 'block';
    
    // Position menu near the cursor
    const rect = document.body.getBoundingClientRect();
    menu.style.left = (event.clientX - rect.left + 5) + 'px';
    menu.style.top = (event.clientY - rect.top + 5) + 'px';

    // Add a one-time listener to close the menu
    // Use setTimeout to skip this current click event
    setTimeout(() => {
      document.addEventListener('click', hideItemContextMenu, { once: true });
    }, 0);
  }
}

// NEW: Hides the item context menu
function hideItemContextMenu() {
  const menu = document.getElementById('itemContextMenu');
  if (menu) menu.style.display = 'none';
  // Remove the listener just in case (though {once: true} should handle it)
  document.removeEventListener('click', hideItemContextMenu);
}

// NEW: The logic for eating the chicken
async function eatCookedChicken() {
  hideItemContextMenu(); // Close the menu

  // Check if HP is full
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }

  // Try to remove the item. If successful, heal the player.
  if (removeItem('Cooked Chicken', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_CHICKEN_HEAL); // <-- Use constant
    updateHPUI();
    
    // --- NEW FIX: Re-render inventory and save ---
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
    // --- END FIX ---

  } else {
    console.warn('Tried to eat Cooked Chicken, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Beef +++
async function eatCookedBeef() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Beef', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_BEEF_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Beef, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Herring +++
async function eatCookedHerring() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Herring', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_HERRING_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Herring, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Trout +++
async function eatCookedTrout() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Trout', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_TROUT_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Trout, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Salmon +++
async function eatCookedSalmon() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Salmon', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_SALMON_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Salmon, but removeItem failed.');
  }
}

/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
async function equipItem(slotType, fromInvIndex) {
  const itemStack = game.inventory[fromInvIndex];
  if (!itemStack) return; // Item doesn't exist

  const stats = ITEM_STATS[itemStack.name];
  const isTwoHanded = stats && stats.twoHanded;

  // --- NEW: Magic Staff Logic ---
  if (slotType === 'weapon' && itemStack.name !== 'Magic Staff') {
    // If unequipping a Magic Staff (by swapping to a sword/bow), reset style but KEEP autocast
    if (game.equipment.weapon && game.equipment.weapon.name === 'Magic Staff') {
      // game.autocastSpell = null; // <-- REMOVED to remember spell
      setAttackStyle('strength', true); 
      if (typeof renderSpellsPanel === 'function') renderSpellsPanel();
    }
  } else if (slotType === 'weapon' && itemStack.name === 'Magic Staff') {
    // If equipping the Magic Staff, set style to magic
    setAttackStyle('magic', true);
  } else if (slotType !== 'weapon' && game.equipment.weapon && game.equipment.weapon.name === 'Magic Staff') {
    // If equipping armor while holding a staff, ensure we stay on magic or reset if needed
    // (For now, we just leave it, but this check prevents accidental resets)
  }
  // --- END NEW ---

  // +++ 2H LOGIC: If equipping a 2H weapon, unequip shield first +++
  if (slotType === 'weapon' && isTwoHanded) {
    if (game.equipment.shield) {
      const success = await unequipItem('shield');
      if (!success) return; // Stop if inventory was full
    }
  }
  
  // +++ 2H LOGIC: If equipping a shield, check if we hold a 2H weapon +++
  if (slotType === 'shield') {
    const currentWeapon = game.equipment.weapon;
    if (currentWeapon && ITEM_STATS[currentWeapon.name] && ITEM_STATS[currentWeapon.name].twoHanded) {
       const success = await unequipItem('weapon');
       if (!success) return; // Stop if inventory was full
    }
  }

  const itemBeingWorn = game.equipment[slotType]; // This is {name, qty} or null


  // --- NEW LOGIC FOR STACKABLE ARROWS ---
  if (slotType === 'arrows') {
    const itemName = itemStack.name;
    
    if (itemBeingWorn && itemBeingWorn.name === itemName) {
      // --- STACKING ---
      // We are wearing the same arrows, so just add to the stack.
      game.equipment[slotType].qty += itemStack.qty; // Add full stack
      game.inventory[fromInvIndex] = null; // Clear inventory slot
    } else {
      // --- SWAPPING ---
      // We are equipping to an empty slot or swapping with different arrows.
      game.equipment[slotType] = { name: itemStack.name, qty: itemStack.qty }; // Equip full stack
      game.inventory[fromInvIndex] = itemBeingWorn; // Put old item (or null) back
    }
  } 
  // --- REGULAR EQUIPMENT LOGIC ---
  else {
    // Check for inventory space *before* equipping
    if (itemBeingWorn) {
      const canStackOnSelf = (itemStack.name === itemBeingWorn.name);
      const hasStackingSlot = game.inventory.find(slot => slot && slot.name === itemBeingWorn.name && slot !== itemStack);
      const hasEmptySlot = game.inventory.some(slot => slot === null);
      if (itemStack.qty > 1 && !canStackOnSelf && !hasStackingSlot && !hasEmptySlot) {
        await showGameAlert("Inventory Full", "You have no room to unequip your currently worn item.");
        // Restart combat if we stopped it
        if (wasInCombat) setTimeout(restartPlayerAttackInterval, 50); // <-- Use new function
        return;
      }
    }

    // 1. Create the new single item to wear
    const newItemToEquip = { name: itemStack.name, qty: 1 };
    
    // 2. Put the new item on the character
    game.equipment[slotType] = newItemToEquip;
    
    // 3. Decrement the inventory stack
    itemStack.qty -= 1;

    // 4. Handle the leftovers
    if (itemStack.qty <= 0) {
      // The stack is empty. Put the old item (or null) in its place.
      game.inventory[fromInvIndex] = itemBeingWorn;
    } else if (itemBeingWorn) {
      // The stack is NOT empty. We must add the old item back.
      // Use the "smart" unequip logic: try to stack first, then find empty slot.
      let stacked = false;
      for (const slot of game.inventory) {
        if (slot && slot.name === itemBeingWorn.name) {
          slot.qty += 1;
          stacked = true;
          break;
        }
      }
      if (!stacked) {
        // We already checked for an empty slot, so this is safe.
        const emptySlot = game.inventory.findIndex(s => s === null);
        if (emptySlot !== -1) {
           game.inventory[emptySlot] = itemBeingWorn;
        }
      }
    }
  }
  
  // 5. Re-render everything
  renderEquipment(); // This will update stats
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  

}

/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
async function unequipItem(slotType) {
  const itemToUnequip = game.equipment[slotType];
  if (!itemToUnequip) return true; // Slot is already empty, consider it a success

  // --- NEW: Smart unequip logic ---
  // 1. Try to find an existing stack to add to
  let stacked = false;
  for (const slot of game.inventory) {
    if (slot && slot.name === itemToUnequip.name) {
      slot.qty += itemToUnequip.qty; 
      stacked = true;
      break;
    }
  }

  // 2. If not stacked, find an empty slot
  if (!stacked) {
    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex === -1) {
      // Inventory is full
      await showGameAlert("Inventory Full", "You can't unequip this, your inventory is full.");
      return false; // <--- RETURN FALSE (Failed)
    }
    // Put item in the empty slot
    game.inventory[emptySlotIndex] = itemToUnequip;
  }

  
  // 3. Clear the equipment slot (since item is safely in inventory)
  
  // +++ NEW: Reset style if Magic Staff is unequipped, but KEEP autocast +++
  if (slotType === 'weapon' && itemToUnequip.name === 'Magic Staff') {
    // game.autocastSpell = null; // <-- REMOVED to remember spell
    // Reset style to a physical default so combat doesn't break
    setAttackStyle('strength', true);
    if (typeof renderSpellsPanel === 'function') renderSpellsPanel();
  }
  // +++ END NEW +++
  
  game.equipment[slotType] = null; 
  
  // 4. Re-render everything
  renderEquipment(); 
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  
  return true; // <--- RETURN TRUE (Success)
}

const tooltip = document.getElementById('tooltip');
function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}
function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}
function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){
    // level is the CURRENT level (1-100)
    
    // Safety check for levels beyond the table
    if (level >= XP_TABLE.length) {
        return 0; 
    }

    // XP_TABLE[level] holds the total XP for level + 1
    const xpNeededForNextLevel = XP_TABLE[level]; 
    
    // XP_TABLE[level - 1] holds the total XP for the current level
    const xpAlreadyGained = XP_TABLE[level - 1] || 0; 

    return xpNeededForNextLevel - xpAlreadyGained;
}

function getTotalXPForLevel(level) {
    // level is the level we want the *cumulative* XP for (1-100)

    // The XP_TABLE is 0-indexed: Lvl 1 total XP is at index 0.
    const index = Math.min(level - 1, XP_TABLE.length - 1);

    return XP_TABLE[index] || 0;
}

// +++ NEW MAGIC SPELL FUNCTIONS +++

/**
 * Calculates the spell's damage based on player level and equipment.
 */
function getSpellStats(spell) {
    const magicLevel = game.magic.level;
    
    // Get actual equipped magic damage (which is now just +1 from the staff)
    const playerStats = getPlayerCombatStats();
    const equipmentMagicDamage = playerStats.equipmentMagicDamage || 0;

    // Formula: (Magic Level / 4) + Equipment Bonus (+1) + Spell Bonus (+2/3/4)
    const baseMaxHit = 1 + Math.floor(magicLevel / 4);
    const maxHit = baseMaxHit + equipmentMagicDamage + spell.damage;
    
    return {
        maxHit: Math.max(1, maxHit),
        xp: spell.xp 
    };
}

/**
 * Opens the Spells modal/panel
 */
function openSpells() {
  const panel = document.getElementById('spellsPanel');
  if (panel) {
    renderSpellsPanel(); // Render content before showing
    panel.style.visibility = (panel.style.visibility === 'visible') ? 'hidden' : 'visible';
  }
}

/**
 * Renders the spell icons in the spell panel.
 */
function renderSpellsPanel() {
    const container = document.getElementById('spellsIconsContainer');
    const autocastTextEl = document.getElementById('autocastText');
    if (!container || !autocastTextEl) return;
    
    container.innerHTML = '';
    const magicLvl = game.magic.level;

    SPELL_LIST.forEach(spell => {
        const isLocked = magicLvl < spell.level;
        const isActive = game.autocastSpell === spell.name;
        const iconWrapper = document.createElement('button');
        
        iconWrapper.id = `spell-btn-${spell.name.replace(/\s+/g, '')}`;
        iconWrapper.className = `primary ${isLocked ? 'locked-item' : ''}`;
        iconWrapper.style.cssText = `
            width: 50px; 
            height: 50px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            padding: 0;
            border: 2px solid ${isActive ? 'var(--gold)' : 'var(--accent)'}; /* Highlight active spell */
            box-shadow: ${isActive ? '0 0 10px var(--gold)' : 'none'};
            transition: all 0.15s ease;
        `;

        // Tooltip Content
        const stats = getSpellStats(spell);
        const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${spell.name}</div>
            ${isLocked ? `<div style="color:#ff8888;">Requires Magic Lvl: ${spell.level}</div>` : `
                <div style="color:#aaffaa;">${spell.damage} Magic Damage</div>
                <div style="color:#fff;">Requires Magic Lvl: ${spell.level}</div>
                <div style="color:#ffaaaa; margin-top: 5px;">Right-click for Autocast...</div>
            `}
        `;

        // Image
        const img = document.createElement('img');
        const imgName = spell.name.toLowerCase().replace(/\s+/g, '');
        img.src = `images/${imgName}.jpeg`;
        img.alt = spell.name;
        img.style.cssText = 'width: 100%; height: 100%; object-fit: contain; pointer-events: none;';
        iconWrapper.appendChild(img);

        // Click Handlers
        if (!isLocked) {
            // Left-Click: Single cast in combat
            iconWrapper.onclick = (e) => {
                // Prevent right-click menu from showing if a spell is cast
                e.preventDefault(); 
                handleSpellClick(spell);
            };
            // Right-Click: Autocast menu
            iconWrapper.oncontextmenu = (e) => {
                e.preventDefault();
                showAutocastContextMenu(e, spell.name);
            };
        }
        
        // FIX: Tooltip handlers moved OUTSIDE the isLocked check
        iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        iconWrapper.onmouseleave = hideTooltip;

        container.appendChild(iconWrapper);
    });
    
    // Update footer text
    autocastTextEl.textContent = game.autocastSpell ? `Autocasting: ${game.autocastSpell}` : 'None';
    autocastTextEl.style.color = game.autocastSpell ? 'var(--gold)' : '#fff';
}

/**
 * Shows the right-click menu for autocasting spells.
 */
function showAutocastContextMenu(event, spellName) {
    const menu = document.getElementById('itemContextMenu');
    let menuContent = '';
    
    if (game.autocastSpell === spellName) {
        menuContent += `<button class="context-menu-btn" onclick="setAutocastSpell(null)">Deactivate Autocast</button>`;
    } else {
        menuContent += `<button class="context-menu-btn" onclick="setAutocastSpell('${spellName}')">Autocast</button>`;
    }

    if (menuContent) {
        menu.innerHTML = menuContent;
        menu.style.display = 'block';
        
        const rect = document.body.getBoundingClientRect();
        // FIX: Subtract 145px to show further left of the cursor
        menu.style.left = (event.clientX - rect.left - 145) + 'px';
        menu.style.top = (event.clientY - rect.top + 5) + 'px';

        setTimeout(() => {
            document.addEventListener('click', hideItemContextMenu, { once: true });
        }, 0);
    }
}

/**
 * Sets the currently active autocast spell.
 */
window.setAutocastSpell = function(spellName) {
    hideItemContextMenu();
    game.autocastSpell = spellName;
    renderSpellsPanel(); // Re-render to update border highlight
    
    // If setting autocast, and currently in combat, try to restart the attack
    if (spellName && game.inCombat) {
        restartPlayerAttackInterval();
    }

    // --- FIX: Save immediately so it persists on refresh ---
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
}

/**
 * Handles a left-click on a spell icon.
 */
function handleSpellClick(spell) {
    if (!game.inCombat || !game.currentEnemy) return;

    // 1. Get current stats to know our attack speed
    const stats = getPlayerCombatStats();
    const now = Date.now();
    // Use the time tracking variable we just added
    const timeSinceLast = now - (game.lastAttackTime || 0);

    // 2. Check Cooldown based on Time, NOT interval existence
    if (timeSinceLast < stats.attackSpeed) {
        // Cooldown active: do nothing, just return silent.
        return; 
    }
    
    // 3. Execute the one-shot attack with the chosen spell
    playerAttackTurn(spell);

    // 4. Reset the automatic loop
    // We clear the pending "idle" check and restart it so you don't double-attack immediately
    if (game.playerCombatInterval) clearTimeout(game.playerCombatInterval);
    
    // Disable Run button briefly (visual cooldown feedback)
    const runBtn = document.getElementById('combat-run-btn');
    if (runBtn) runBtn.disabled = true;

    // Schedule the NEXT auto-turn (or idle check)
    game.playerCombatInterval = setTimeout(() => {
        // Re-enable run button when cooldown finishes
        if (runBtn) runBtn.disabled = false; 
        playerCombatLoop();
    }, stats.attackSpeed);
}

// +++ END NEW MAGIC SPELL FUNCTIONS +++


function updateSkillUI(){
  const skillsTab = document.getElementById('skillsTab');
  if (!skillsTab) return;
  
  // Clear the tab and set up the header/container
  skillsTab.innerHTML = `
    <div id="skillIconsContainer" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; justify-content: center; margin-top: 12px;">
      </div>
  `;

  const container = document.getElementById('skillIconsContainer');

  /**
   * Helper function to create a skill icon with a tooltip
   * @param {string} skillName - The display name (e.g., "Mining")
   * @param {string} skillDataKey - The key in the game object (e.g., "mining")
   * @param {string} iconFileName - The name of the icon file in /images/
   */
  const createSkillIcon = (skillName, skillDataKey, iconFileName) => {
    const data = game[skillDataKey];
    const iconWrapper = document.createElement('button');
    iconWrapper.className = ''; // <-- FIX: Removed 'primary' class
    iconWrapper.style.cssText = `
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 5px; 
      /* padding: 8px 10px; -- REMOVED */
      /* height: 80px; -- REMOVED */
      /* width: 80px; -- REMOVED */
      justify-content: center;
      font-size: 13px;
      background: transparent; /* <-- FIX: No background */
      border: none; /* <-- FIX: No border */
      cursor: pointer; /* <-- Keep this for hover/tooltip */
      transition: all 0.15s ease;
    `;
    
    // --- Create the tooltip content ---
    const nextXP = getNextXP(data.level);
    // Calculate progress percentage, ensuring it doesn't exceed 100%
    const progressPercent = Math.min(100, (data.xp / nextXP) * 100);
    
    const tooltipContent = `
      <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${skillName}</div>
      <div style="font-size: 14px; margin-bottom: 6px;">Level: <span style="font-weight: bold;">${data.level}</span></div>
      <div>XP: ${data.xp.toLocaleString()} / ${nextXP.toLocaleString()}</div>
      <div>(Total XP: ${data.totalXP.toLocaleString()})</div>
      
      <div style="width: 100%; height: 8px; background: #555; border-radius: 4px; margin-top: 8px; border: 1px solid #333;">
        <div style="height: 100%; width: ${progressPercent}%; background: #4caf50; border-radius: 4px; transition: width 0.2s;"></div>
      </div>
    `;

    // Set up hover/tooltip events
    iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
    iconWrapper.onmouseleave = hideTooltip;

    // Create and append icon image
    const img = document.createElement('img');
    img.src = `images/${iconFileName}`;
    img.alt = skillName;
    img.style.cssText = 'width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; pointer-events: none;';
    img.onerror = function(){ this.style.opacity='0.1'; this.style.filter='grayscale(100%)'; }; // Fallback
    iconWrapper.appendChild(img);

    // Append level text
    const levelText = document.createElement('span');
    levelText.innerText = data.level; // <-- FIX: Removed "Lvl "
    levelText.style.fontWeight = 'bold';
    levelText.style.pointerEvents = 'none';
    levelText.style.color = '#fff'; // <-- THIS IS THE FIX
    iconWrapper.appendChild(levelText);

    container.appendChild(iconWrapper);
  };

  // --- Call the function for each of your skills ---
  createSkillIcon('Mining', 'mining', 'miningskillicon.png');
  createSkillIcon('Blacksmith', 'blacksmith', 'blacksmithskillicon.png');
  createSkillIcon('Attack', 'attack', 'attackskillicon.jpeg'); 
  createSkillIcon('Strength', 'strength', 'strengthskillicon.png'); 
  createSkillIcon('Defence', 'defence', 'defenseskillicon.png'); 
  createSkillIcon('Vitality', 'vitality', 'vitalityskillicon.png'); // +++ NEW VITALITY SKILL CALL +++
  createSkillIcon('Cooking', 'cooking', 'cookingskillicon.png'); // +++ NEW COOKING SKILL CALL +++
  createSkillIcon('Woodcutting', 'woodcutting', 'woodcuttingskillicon.jpeg'); // +++ NEW WOODCUTTING SKILL CALL +++
  createSkillIcon('Fletching', 'fletching', 'fletchingskillicon.jpeg'); // +++ NEW FLETCHING SKILL CALL +++
  
  // +++ NEW SKILL ICONS +++
  createSkillIcon('Crafting', 'crafting', 'craftingskillicon.png');
  createSkillIcon('Ranged', 'ranged', 'rangedskillicon.jpeg');
  
  // +++ NEW FISHING SKILL ICON +++
  createSkillIcon('Fishing', 'fishing', 'fishingskillicon.jpeg');
  
  // +++ NEW MAGIC SKILL ICON +++
  createSkillIcon('Magic', 'magic', 'magicskillicon.jpeg');
  // +++ NEW STONE FORGING ICON +++
  createSkillIcon('Stone Forging', 'stoneforging', 'stoneforgingskillicon.jpeg');
  // +++ NEW BOUNTY HUNTING ICON +++
  createSkillIcon('Bounty Hunting', 'bountyhunting', 'bountyhunterskillicon.jpeg');
}

// +++ NEW: Level Up Popup Logic +++
function showLevelUpPopup(skill, newLevel) {
  const overlay = document.getElementById('levelUpOverlay');
  const iconEl = document.getElementById('levelUpIcon');
  const skillNameEl = document.getElementById('levelUpSkillName');
  const levelValEl = document.getElementById('levelUpValue');
  
  // Map internal skill keys to the specific file names provided in updateSkillUI
  const skillIcons = {
    'mining': 'miningskillicon.png',
    'blacksmith': 'blacksmithskillicon.png',
    'attack': 'attackskillicon.jpeg',
    'strength': 'strengthskillicon.png',
    'defence': 'defenseskillicon.png',
    'vitality': 'vitalityskillicon.png',
    'cooking': 'cookingskillicon.png',
    'woodcutting': 'woodcuttingskillicon.jpeg',
    'fletching': 'fletchingskillicon.jpeg',
    'crafting': 'craftingskillicon.png',
    'ranged': 'rangedskillicon.jpeg',
    'fishing': 'fishingskillicon.jpeg',
    'magic': 'magicskillicon.jpeg',
    'stoneforging': 'stoneforgingskillicon.jpeg',
    'bountyhunting': 'bountyhunterskillicon.jpeg'
  };

  // Format Skill Name (capitalize first letter)
  const formattedName = skill.charAt(0).toUpperCase() + skill.slice(1);

  // Update DOM
  if(iconEl) iconEl.src = `images/${skillIcons[skill] || 'gearicon.png'}`;
  if(skillNameEl) skillNameEl.innerText = formattedName;
  if(levelValEl) levelValEl.innerText = newLevel;

  // Play Sound
  playGlobalSound('sounds/soundeffects/levelupsoundeffect.mp3');

  // Show Overlay with Fade Logic
  if(overlay) {
    // 1. Reset state (in case it was fading out)
    overlay.style.display = 'flex';
    
    // Force a reflow so the browser realizes display is now 'flex' before we change opacity
    void overlay.offsetWidth; 
    
    // 2. Fade In
    overlay.classList.add('visible');
    
    // Clear any existing timeout to prevent early closing
    if (game.levelUpTimeout) clearTimeout(game.levelUpTimeout);
    if (game.levelUpFadeTimeout) clearTimeout(game.levelUpFadeTimeout);
    
    // 3. Schedule Fade Out (4.5 seconds visible + 0.5s fade = 5s total)
    game.levelUpTimeout = setTimeout(() => {
        // Trigger CSS Fade Out
        overlay.classList.remove('visible');
        
        // 4. Remove from display after transition completes (0.5s)
        game.levelUpFadeTimeout = setTimeout(() => {
            overlay.style.display = 'none';
        }, 500); // Match CSS transition time
        
    }, 4500);
  }
}



function showItemPopup(text, progressElementId, delay = 0) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.innerHTML = text; // Allow HTML
popup.style.lineHeight = '1.4';
    const bar = document.getElementById(progressElementId);
    if (bar) {
        const barRect = bar.getBoundingClientRect();
        const mainRect = main.getBoundingClientRect();
        const relativeX = barRect.left - mainRect.left;
        const relativeY = barRect.top - mainRect.top;
        popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
        popup.style.top = (relativeY - 30) + 'px';
    } else {
        popup.style.left = '50%';
        popup.style.top = '120px';
        popup.style.transform = 'translateX(-50%)';
    }
    if (delay > 0) {
    setTimeout(() => {
      main.appendChild(popup);
      setTimeout(() => popup.remove(), 850); // 850 to match splat
    }, delay);
  } else {
    main.appendChild(popup);
    setTimeout(() => popup.remove(), 850); // 850 to match splat
  }
}

// --- NEW WARNING POPUP FUNCTION ---
/**
 * Shows a short-lived warning popup in the main area.
 * @param {string} text - The warning message to display.
 */
function showWarningPopup(text) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'warning-popup';
    popup.innerHTML = text;
    
    // Position it in the top-center of the main panel
    popup.style.left = '50%';
    popup.style.top = '60px'; // A bit lower than XP popups
    popup.style.transform = 'translateX(-50%)';
    
    main.appendChild(popup);
    
    // Remove after animation (3s)
    setTimeout(() => popup.remove(), 2950);
}
// --- END NEW ---

function addXP(skill, amount, delay = 0){
  if (!game[skill]) {
      console.warn(`Skill "${skill}" does not exist.`);
      return;
  }
  game[skill].totalXP += amount; 
  game[skill].xp += amount;

  let leveledUp = false; // --- NEW: Add a flag ---
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
    leveledUp = true; // --- NEW: Set the flag ---
  }

  // --- NEW: Check if vitality leveled up and update HP ---
  if (leveledUp && skill === 'vitality') {
    updateHPUI();
  }

  // --- NEW: Trigger Level Up Popup ---
  if (leveledUp) {
      showLevelUpPopup(skill, game[skill].level);
  }
  // --- END NEW ---

  updateSkillUI();
  let barId = '';
  if (skill === 'mining') barId = 'mineProgress';
  if (skill === 'blacksmith') barId = 'smithProgress';
  if (skill === 'woodcutting') barId = 'woodcutProgress';
  if (skill === 'crafting') barId = 'craftProgress'; // +++ NEW +++
  
  // +++ ADDED 'crafting', 'fletching', 'fishing', 'stoneforging' TO THIS LIST +++
  if (skill !== 'blacksmith' && skill !== 'mining' && skill !== 'cooking' && skill !== 'woodcutting' && skill !== 'crafting' && skill !== 'fletching' && skill !== 'fishing' && skill !== 'stoneforging') { // Don't show popup for skilling actions
    if (delay > 0) {
      setTimeout(() => {
        showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
      }, delay);
    } else {
      showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
    }
 }

 }

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

/**
* NEW: A reusable loop to show a cooldown timer in the mining UI.
 * @param {number} timestamp - The current frame's timestamp.
 * @param {number} startTime - The timestamp when the cooldown began.
 * @param {number} duration - The total duration of the cooldown (in ms).
 * @param {string} progressTextId - The ID of the text element (e.g., 'mineProgressText').
 * @param {function} nextLoopFunction - The mining loop to call when finished (e.g., miningLoop).
 */

function miningCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.miningActive) { // Check if stop was pressed
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = Date.now() - startTime; // Use Date.now() for real time
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    // --- COOLDOWN IS COMPLETE ---
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    
    // --- NEW: Calculate "overdue" time ---
    const overdueTime = -remainingMs; // (elapsed - duration)
    const newActionStartTime = Date.now() - overdueTime;
            
    // --- THIS IS THE FIX: Immediately call the next loop ---
    return nextLoopFunction(Date.now(), newActionStartTime);
    
  } else {
    // --- COOLDOWN IN PROGRESS ---
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    // This is now the ONLY setTimeout, for when we are actively waiting
    game.progressFrame = setTimeout(() => 
      miningCooldownLoop(Date.now(), startTime, duration, progressTextId, nextLoopFunction)
    , 16);
  }
}

// --- MODIFIED: Added Session Lock Check ---
async function startMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => miningLoop(Date.now(), Date.now()), 16);
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = Date.now() - startTime; // Use Date.now() for real time

  if (elapsed >= MINE_TIME_MS) {
    // --- ACTION IS COMPLETE ---
    addItem(MINE_ITEM, 1); 
    addXP('mining', MINE_XP); 
    showItemPopup(`+${MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 Copper Ore`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Calculate "overdue" time ---
    const overdueTime = elapsed - MINE_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;
            
    // --- THIS IS THE FIX: Immediately call the cooldown loop ---
    return miningCooldownLoop(Date.now(), newCooldownStartTime, MINE_COOLDOWN_COPPER_MS, 'mineProgressText', miningLoop);
    
  } else {
    // --- ACTION IN PROGRESS ---
    const progress = (elapsed / MINE_TIME_MS) * 100;
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    
    // This is now the ONLY setTimeout
    game.progressFrame = setTimeout(() => miningLoop(Date.now(), startTime), 16);
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame); // <-- MODIFIED
  
  const textEl = document.getElementById('mineProgressText');
  if (textEl) textEl.innerText = '';

  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// +++ NEW CRAFTING FUNCTION BLOCK TO INSERT +++
const CHESTPLATE_TIME_MS = 10000; 

// +++ END NEW CRAFTING FUNCTION +++


// +++ END NEW SHORTSWORD CRAFTING FUNCTION +++

function openCopperHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${HELMET_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn'); 
  showMainScreen('hubDynamic');
}
// +++ END NEW HELMET CRAFTING FUNCTION +++

async function startHelmetCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Helmet')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < HELMET_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${HELMET_BAR_COST} Copper Bars to craft a helmet.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startHelmetBtn');
  const stopBtn = document.getElementById('stopHelmetBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => helmetCraftingLoop(Date.now(), Date.now()), 16);
}

async function helmetCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= HELMET_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < HELMET_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
        return;
    }
    
    removeItem('Copper Bar', HELMET_BAR_COST);
    addItem('Copper Helmet', 1);
    addXP('blacksmith', HELMET_XP);
    showItemPopup(`+${HELMET_XP} Blacksmith XP`, 'helmetProgress', 0);
    showItemPopup(`+1 Copper Helmet`, 'helmetProgress', 450);
    
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - HELMET_TIME_MS;
    const newStartTime = Date.now() - overdueTime;

    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < HELMET_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another helmet.");
        stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
        return;
    }
    
    // --- THIS IS THE FIX: Immediately call self to catch up ---
    return helmetCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / HELMET_TIME_MS) * 100;
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => helmetCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW COPPER BOOTS UI +++
function openCopperBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${BOOTS_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn'); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${BOOTS_BAR_COST} Copper Bars to craft boots.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => bootsCraftingLoop(Date.now(), Date.now()), 16);
}

async function bootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= BOOTS_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Bar', BOOTS_BAR_COST);
    addItem('Copper Boots', 1);
    addXP('blacksmith', BOOTS_XP);
    showItemPopup(`+${BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Copper Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - BOOTS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    
    return bootsCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / BOOTS_TIME_MS) * 100;
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => bootsCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW COPPER PLATELEGS UI +++
function openCopperPlatelegsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Platelegs</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_PLATELEGS_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="platelegsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPlatelegsBtn" class="primary">Start Crafting</button>
      <button id="stopPlatelegsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPlatelegsBtn').onclick = startCopperPlatelegsCrafting;
  document.getElementById('stopPlatelegsBtn').onclick = () => stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); 
  showMainScreen('hubDynamic');
}

async function startCopperPlatelegsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Platelegs')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < COPPER_PLATELEGS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${COPPER_PLATELEGS_BAR_COST} Copper Bars to craft platelegs.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startPlatelegsBtn');
  const stopBtn = document.getElementById('stopPlatelegsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => copperPlatelegsCraftingLoop(Date.now(), Date.now()), 16);
}

async function copperPlatelegsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COPPER_PLATELEGS_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < COPPER_PLATELEGS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_PLATELEGS_BAR_COST);
    addItem('Copper Platelegs', 1);
    addXP('blacksmith', COPPER_PLATELEGS_XP);
    showItemPopup(`+${COPPER_PLATELEGS_XP} Blacksmith XP`, 'platelegsProgress', 0);
    showItemPopup(`+1 Copper Platelegs`, 'platelegsProgress', 450);
    
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COPPER_PLATELEGS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < COPPER_PLATELEGS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more platelegs.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn');
        return;
    }
    
    return copperPlatelegsCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COPPER_PLATELEGS_TIME_MS) * 100;
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => copperPlatelegsCraftingLoop(Date.now(), startTime), 16);
  }
}
// +++ END NEW COPPER PLATELEGS +++

// --- NEW: Iron Bar Crafting Logic ---
async function startIronBarCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Bar')) {
    await showGameAlert("Inventory Full", "You have no room to smith this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalIronOre = 0;
  let totalCoalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
      if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
  }

  if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BAR_ORE_COST} Iron Ore and ${IRON_BAR_COAL_COST} Coal Ore.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironBarCraftingLoop(Date.now(), Date.now()), 16);
}


async function ironBarCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_BAR_TIME_MS) {
    let totalIronOre = 0;
    let totalCoalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
    }
    if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
        await showGameAlert("Out of Materials", "You've run out of ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Ore', IRON_BAR_ORE_COST);
    removeItem('Coal Ore', IRON_BAR_COAL_COST);
    addItem('Iron Bar', 1);
    addXP('blacksmith', IRON_BAR_XP);
    showItemPopup(`+${IRON_BAR_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Iron Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_BAR_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalIronAfter = 0;
    let totalCoalAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronAfter += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalAfter += slot.qty;
    }
    if (totalIronAfter < IRON_BAR_ORE_COST || totalCoalAfter < IRON_BAR_COAL_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    
    return ironBarCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_BAR_TIME_MS) * 100;
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironBarCraftingLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Iron Helmet Crafting Logic ---
async function startIronHelmetCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Helmet')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_HELMET_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_HELMET_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startHelmetBtn');
  const stopBtn = document.getElementById('stopHelmetBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironHelmetCraftingLoop(Date.now(), Date.now()), 16);
}


async function ironHelmetCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_HELMET_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_HELMET_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_HELMET_BAR_COST);
    addItem('Iron Helmet', 1);
    addXP('blacksmith', IRON_HELMET_XP);
    showItemPopup(`+${IRON_HELMET_XP} Blacksmith XP`, 'helmetProgress', 0);
    showItemPopup(`+1 Iron Helmet`, 'helmetProgress', 450);
    
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_HELMET_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_HELMET_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another helmet.");
        stopBlacksmithing();
        return;
    }
    
    return ironHelmetCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_HELMET_TIME_MS) * 100;
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironHelmetCraftingLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Iron Chestplate Crafting Logic ---
async function startIronChestplateCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Chestplate')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_CHESTPLATE_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_CHESTPLATE_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironChestplateCraftingLoop(Date.now(), Date.now()), 16);
}

async function ironChestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_CHESTPLATE_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_CHESTPLATE_BAR_COST);
    addItem('Iron Chestplate', 1);
    addXP('blacksmith', IRON_CHESTPLATE_XP);
    showItemPopup(`+${IRON_CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Iron Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_CHESTPLATE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another chestplate.");
        stopBlacksmithing();
        return;
    }
    
    return ironChestplateCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_CHESTPLATE_TIME_MS) * 100;
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironChestplateCraftingLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Iron Boots Crafting Logic ---
async function startIronBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BOOTS_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironBootsCraftingLoop(Date.now(), Date.now()), 16);
}


async function ironBootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_BOOTS_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_BOOTS_BAR_COST);
    addItem('Iron Boots', 1);
    addXP('blacksmith', IRON_BOOTS_XP);
    showItemPopup(`+${IRON_BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Iron Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_BOOTS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    
    return ironBootsCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_BOOTS_TIME_MS) * 100;
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironBootsCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW IRON PLATELEGS UI +++
function openIronPlatelegsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Iron Platelegs</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_PLATELEGS_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="platelegsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPlatelegsBtn" class="primary">Start Crafting</button>
      <button id="stopPlatelegsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPlatelegsBtn').onclick = startIronPlatelegsCrafting;
  document.getElementById('stopPlatelegsBtn').onclick = () => stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); 
  showMainScreen('hubDynamic');
}

async function startIronPlatelegsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Platelegs')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < IRON_PLATELEGS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_PLATELEGS_BAR_COST} Iron Bars to craft platelegs.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startPlatelegsBtn');
  const stopBtn = document.getElementById('stopPlatelegsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironPlatelegsCraftingLoop(Date.now(), Date.now()), 16);
}

async function ironPlatelegsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_PLATELEGS_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < IRON_PLATELEGS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_PLATELEGS_BAR_COST);
    addItem('Iron Platelegs', 1);
    addXP('blacksmith', IRON_PLATELEGS_XP);
    showItemPopup(`+${IRON_PLATELEGS_XP} Blacksmith XP`, 'platelegsProgress', 0);
    showItemPopup(`+1 Iron Platelegs`, 'platelegsProgress', 450);
    
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_PLATELEGS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < IRON_PLATELEGS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more platelegs.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn');
        return;
    }
    
    return ironPlatelegsCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_PLATELEGS_TIME_MS) * 100;
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironPlatelegsCraftingLoop(Date.now(), startTime), 16);
  }
}
// +++ END NEW IRON PLATELEGS +++

// --- NEW: Iron Shortsword Crafting Logic ---
async function startIronShortswordCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Shortsword')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_SHORTSWORD_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_SHORTSWORD_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironShortswordCraftingLoop(Date.now(), Date.now()), 16);
}


async function ironShortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_SHORTSWORD_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_SHORTSWORD_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_SHORTSWORD_BAR_COST);
    addItem('Iron Shortsword', 1);
    addXP('blacksmith', IRON_SHORTSWORD_XP);
    showItemPopup(`+${IRON_SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Iron Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_SHORTSWORD_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
   
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < IRON_SHORTSWORD_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another shortsword.");
        stopBlacksmithing();
        return;
    }
    
    return ironShortswordCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_SHORTSWORD_TIME_MS) * 100;
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironShortswordCraftingLoop(Date.now(), startTime), 16);
  }
}

const SMITH_TIME_MS = 5000;
const SMITH_XP = 25;
const SMITH_ORE_COST = 2;
const SMITH_BAR_ITEM = 'Copper Bar';

// --- MODIFIED: Added Session Lock Check ---
async function startBlacksmithing() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(SMITH_BAR_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to smith this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Ore') {
          totalOre += slot.qty;
      }
  }

  if (totalOre < SMITH_ORE_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${SMITH_ORE_COST} Copper Ore to smith a bar.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => blacksmithingLoop(Date.now(), Date.now()), 16);
}

async function blacksmithingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= SMITH_TIME_MS) {
    let totalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOre += slot.qty;
        }
    }
    if (totalOre < SMITH_ORE_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Ore', SMITH_ORE_COST);
    addItem(SMITH_BAR_ITEM, 1);
    addXP('blacksmith', SMITH_XP);
    showItemPopup(`+${SMITH_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Copper Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - SMITH_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalOreAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOreAfter += slot.qty;
        }
    }
    if (totalOreAfter < SMITH_ORE_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    
    return blacksmithingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / SMITH_TIME_MS) * 100;
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => blacksmithingLoop(Date.now(), startTime), 16);
  }
}

function stopBlacksmithing(progressId = 'smithProgress', startBtnId = 'startSmithBtn', stopBtnId = 'stopSmithBtn'){
  game.blacksmithingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

const COOK_CHICKEN_TIME_MS = 3000;
const COOK_CHICKEN_XP = 30;
const COOK_CHICKEN_HEAL = 3; // <-- ADD THIS

// --- NEW: Beef Cooking Constants ---
const COOK_BEEF_LVL = 1;
const COOK_BEEF_TIME_MS = 3000;
const COOK_BEEF_XP = 35;
const COOK_BEEF_HEAL = 4; // Heals 4 HP
const COOK_BEEF_ITEM_RAW = 'Beef';
const COOK_BEEF_ITEM_COOKED = 'Cooked Beef';
const COOK_BEEF_ITEM_BURNT = 'Burnt Beef';

// --- NEW: Herring Cooking Constants ---
const COOK_HERRING_LVL = 1;
const COOK_HERRING_TIME_MS = 3000; // Same as chicken
const COOK_HERRING_XP = 30;        // Same as chicken
const COOK_HERRING_HEAL = 3;
const COOK_HERRING_ITEM_RAW = 'Herring';
const COOK_HERRING_ITEM_COOKED = 'Cooked Herring';
const COOK_HERRING_ITEM_BURNT = 'Burnt Herring';

// --- NEW: Trout Cooking Constants ---
const COOK_TROUT_LVL = 5;
const COOK_TROUT_TIME_MS = 3500; // Slightly longer
const COOK_TROUT_XP = 40;        // 4 HP heal
const COOK_TROUT_HEAL = 4;
const COOK_TROUT_ITEM_RAW = 'Trout';
const COOK_TROUT_ITEM_COOKED = 'Cooked Trout';
const COOK_TROUT_ITEM_BURNT = 'Burnt Trout';

// --- NEW: Salmon Cooking Constants ---
const COOK_SALMON_LVL = 10;
const COOK_SALMON_TIME_MS = 3500; // Same as trout
const COOK_SALMON_XP = 45;        // 4 HP heal
const COOK_SALMON_HEAL = 4;
const COOK_SALMON_ITEM_RAW = 'Salmon';
const COOK_SALMON_ITEM_COOKED = 'Cooked Salmon';
const COOK_SALMON_ITEM_BURNT = 'Burnt Salmon';


// --- NEW COOKING FUNCTIONS ---
async function startCookingChicken() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem('Cooked Chicken') && !canReceiveItem('Burnt Chicken')) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // --- Check for Raw Chicken ---
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Raw Chicken') {
          totalRaw += slot.qty;
      }
  }

  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 Raw Chicken to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => cookingChickenLoop(Date.now(), Date.now()), 16);
}

async function cookingChickenLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COOK_CHICKEN_TIME_MS) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", "You've run out of Raw Chicken.");
        stopCookingChicken();
        return;
    }
    
    removeItem('Raw Chicken', 1);
    addXP('cooking', COOK_CHICKEN_XP);
    
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    if (Math.random() * 100 < successRate) {
      addItem('Cooked Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Cooked Chicken`, 'cookProgress', 450);
    } else {
      addItem('Burnt Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Burnt Chicken`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COOK_CHICKEN_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", "You don't have any more Raw Chicken to cook.");
        stopCookingChicken();
        return;
    }
    
    return cookingChickenLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COOK_CHICKEN_TIME_MS) * 100;
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => cookingChickenLoop(Date.now(), startTime), 16);
  }
}

function stopCookingChicken(){
  game.cookingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  const bar = document.getElementById('cookProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCookBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCookBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// +++ NEW: BEEF COOKING UI +++
function openCookBeef(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Beef</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_BEEF_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingBeef;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses same stop function
  showMainScreen('hubDynamic');
}

async function startCookingBeef() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // Check Inventory Space
  if (!canReceiveItem(COOK_BEEF_ITEM_COOKED) && !canReceiveItem(COOK_BEEF_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this.");
    return;
  }
  
  if (game.cookingActive) return;

  // Check for Raw Beef
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_BEEF_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_BEEF_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  document.getElementById('startCookBtn').style.display = 'none';
  document.getElementById('stopCookBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => cookingBeefLoop(Date.now(), Date.now()), 16);
}

async function cookingBeefLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COOK_BEEF_TIME_MS) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_BEEF_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_BEEF_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_BEEF_ITEM_RAW, 1);
    addXP('cooking', COOK_BEEF_XP);
    
    // Burning Formula: Starts at 50% success, reaches 100% at Level 10 (same as Chicken roughly)
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    if (Math.random() * 100 < successRate) {
      addItem(COOK_BEEF_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_BEEF_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_BEEF_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_BEEF_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_BEEF_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_BEEF_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COOK_BEEF_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_BEEF_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_BEEF_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    
    return cookingBeefLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COOK_BEEF_TIME_MS) * 100;
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => cookingBeefLoop(Date.now(), startTime), 16);
  }
}


function openCookChicken(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing(); // Also stop smithing
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Cooking - Chicken</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 Raw Chicken.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingChicken;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// +++ NEW: HERRING COOKING UI +++
function openCookHerring(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Herring</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_HERRING_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingHerring;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: TROUT COOKING UI +++
function openCookTrout(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Trout</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_TROUT_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingTrout;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: SALMON COOKING UI +++
function openCookSalmon(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Salmon</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_SALMON_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingSalmon;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: HERRING COOKING LOGIC +++
async function startCookingHerring() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_HERRING_ITEM_COOKED) && !canReceiveItem(COOK_HERRING_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_HERRING_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_HERRING_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_HERRING_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => cookingHerringLoop(Date.now(), Date.now()), 16);
}

async function cookingHerringLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COOK_HERRING_TIME_MS) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_HERRING_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_HERRING_ITEM_RAW, 1);
    addXP('cooking', COOK_HERRING_XP);
    
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    if (Math.random() * 100 < successRate) {
      addItem(COOK_HERRING_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_HERRING_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_HERRING_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_HERRING_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_HERRING_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_HERRING_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COOK_HERRING_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_HERRING_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    
    return cookingHerringLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COOK_HERRING_TIME_MS) * 100;
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => cookingHerringLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: TROUT COOKING LOGIC +++
async function startCookingTrout() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_TROUT_ITEM_COOKED) && !canReceiveItem(COOK_TROUT_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_TROUT_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_TROUT_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_TROUT_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => cookingTroutLoop(Date.now(), Date.now()), 16);
}

async function cookingTroutLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COOK_TROUT_TIME_MS) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_TROUT_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_TROUT_ITEM_RAW, 1);
    addXP('cooking', COOK_TROUT_XP);
    
    const successRate = Math.min(100, 50 + ((game.cooking.level - 5) * (50/9)));
    
    if (Math.random() * 100 < successRate || game.cooking.level < COOK_TROUT_LVL) {
      addItem(COOK_TROUT_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_TROUT_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_TROUT_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_TROUT_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_TROUT_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_TROUT_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COOK_TROUT_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_TROUT_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    
    return cookingTroutLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COOK_TROUT_TIME_MS) * 100;
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => cookingTroutLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: SALMON COOKING LOGIC +++
async function startCookingSalmon() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_SALMON_ITEM_COOKED) && !canReceiveItem(COOK_SALMON_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_SALMON_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_SALMON_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_SALMON_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => cookingSalmonLoop(Date.now(), Date.now()), 16);
}

async function cookingSalmonLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COOK_SALMON_TIME_MS) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_SALMON_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_SALMON_ITEM_RAW, 1);
    addXP('cooking', COOK_SALMON_XP);
    
    const successRate = Math.min(100, 50 + ((game.cooking.level - 10) * (50/9)));
    
    if (Math.random() * 100 < successRate || game.cooking.level < COOK_SALMON_LVL) {
      addItem(COOK_SALMON_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_SALMON_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_SALMON_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_SALMON_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_SALMON_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_SALMON_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COOK_SALMON_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_SALMON_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    
    return cookingSalmonLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COOK_SALMON_TIME_MS) * 100;
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => cookingSalmonLoop(Date.now(), startTime), 16);
  }
}


function openKitchenHub() {
  showMainScreen('hubKitchen');
}

function openCopperBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 2 Copper Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startBlacksmithing;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// +++ NEW COPPER CHESTPLATE UI +++
function openCopperChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${CHESTPLATE_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER CHESTPLATE UI +++

async function startChestplateCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Chestplate')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < CHESTPLATE_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${CHESTPLATE_BAR_COST} Copper Bars to craft a chestplate.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => chestplateCraftingLoop(Date.now(), Date.now()), 16);
}

async function chestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= CHESTPLATE_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < CHESTPLATE_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
        return;
    }
    
    removeItem('Copper Bar', CHESTPLATE_BAR_COST);
    addItem('Copper Chestplate', 1);
    addXP('blacksmith', CHESTPLATE_XP);
    showItemPopup(`+${CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Copper Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - CHESTPLATE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < CHESTPLATE_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another chestplate.");
        stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
        return;
    }
    
    return chestplateCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / CHESTPLATE_TIME_MS) * 100;
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => chestplateCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW COPPER SHORTSWORD UI +++
function openCopperShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SHORTSWORD_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER SHORTSWORD UI +++

async function startShortswordCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Shortsword')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < SHORTSWORD_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${SHORTSWORD_BAR_COST} Copper Bars to craft a shortsword.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => shortswordCraftingLoop(Date.now(), Date.now()), 16);
}

async function shortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= SHORTSWORD_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < SHORTSWORD_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
        return;
    }
    
    removeItem('Copper Bar', SHORTSWORD_BAR_COST);
    addItem('Copper Shortsword', 1);
    addXP('blacksmith', SHORTSWORD_XP);
    showItemPopup(`+${SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Copper Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - SHORTSWORD_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < SHORTSWORD_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another shortsword.");
        stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
        return;
    }
    
    return shortswordCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / SHORTSWORD_TIME_MS) * 100;
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => shortswordCraftingLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Iron Bar UI ---
function openIronBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startIronBarCrafting;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Helmet UI ---
function openIronHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_HELMET_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startIronHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Chestplate UI ---
function openIronChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startIronChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Boots UI ---
function openIronBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BOOTS_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startIronBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Shortsword UI ---
function openIronShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startIronShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
  }

// +++ NEW: COPPER AXE UI +++
function openCopperAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startCopperAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// This is the logic function, now separate
async function startCopperAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Axe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_AXE_BAR_COST} Copper Bars and ${COPPER_AXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => copperAxeCraftingLoop(Date.now(), Date.now()), 16);
}

async function copperAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COPPER_AXE_TIME_MS) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_AXE_BAR_COST);
    removeItem('Softwood', COPPER_AXE_WOOD_COST);
    addItem('Copper Axe', 1);
    addXP('blacksmith', COPPER_AXE_XP);
    showItemPopup(`+${COPPER_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Copper Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    const overdueTime = elapsed - COPPER_AXE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_AXE_BAR_COST || totalWoodAfter < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    return copperAxeCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COPPER_AXE_TIME_MS) * 100;
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => copperAxeCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: COPPER PICKAXE UI +++
function openCopperPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startCopperPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startCopperPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Pickaxe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_PICKAXE_BAR_COST} Copper Bars and ${COPPER_PICKAXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => copperPickaxeCraftingLoop(Date.now(), Date.now()), 16);
}

async function copperPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COPPER_PICKAXE_TIME_MS) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_PICKAXE_BAR_COST);
    removeItem('Softwood', COPPER_PICKAXE_WOOD_COST);
    addItem('Copper Pickaxe', 1);
    addXP('blacksmith', COPPER_PICKAXE_XP);
    showItemPopup(`+${COPPER_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Copper Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    const overdueTime = elapsed - COPPER_PICKAXE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_PICKAXE_BAR_COST || totalWoodAfter < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    return copperPickaxeCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COPPER_PICKAXE_TIME_MS) * 100;
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => copperPickaxeCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: IRON AXE UI +++
function openIronAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startIronAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Axe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_AXE_BAR_COST} Iron Bars and ${IRON_AXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironAxeCraftingLoop(Date.now(), Date.now()), 16);
}

async function ironAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_AXE_TIME_MS) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_AXE_BAR_COST);
    removeItem('Oak', IRON_AXE_WOOD_COST);
    addItem('Iron Axe', 1);
    addXP('blacksmith', IRON_AXE_XP);
    showItemPopup(`+${IRON_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Iron Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    const overdueTime = elapsed - IRON_AXE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_AXE_BAR_COST || totalWoodAfter < IRON_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    return ironAxeCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_AXE_TIME_MS) * 100;
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironAxeCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: IRON PICKAXE UI +++
function openIronPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startIronPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Pickaxe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_PICKAXE_BAR_COST} Iron Bars and ${IRON_PICKAXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironPickaxeCraftingLoop(Date.now(), Date.now()), 16);
}

async function ironPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_PICKAXE_TIME_MS) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_PICKAXE_BAR_COST);
    removeItem('Oak', IRON_PICKAXE_WOOD_COST);
    addItem('Iron Pickaxe', 1);
    addXP('blacksmith', IRON_PICKAXE_XP);
    showItemPopup(`+${IRON_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Iron Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    const overdueTime = elapsed - IRON_PICKAXE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_PICKAXE_BAR_COST || totalWoodAfter < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    return ironPickaxeCraftingLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / IRON_PICKAXE_TIME_MS) * 100;
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironPickaxeCraftingLoop(Date.now(), startTime), 16);
  }
}

// +++ END NEW COPPER SHORTSWORD UI +++

function openBlacksmithHub() {
  showMainScreen('hubBlacksmith');
}

// +++ NEW: COPPER ARROW TIP UI (Blacksmith) +++
function openSmithCopperArrowTip(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Arrow Tip</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_ARROW_TIP_BAR_COST} Copper Bars. Yields ${COPPER_ARROW_TIP_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="arrowTipProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startArrowTipBtn" class="primary">Start Crafting</button>
      <button id="stopArrowTipBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startArrowTipBtn').onclick = startSmithingCopperArrowTip;
  document.getElementById('stopArrowTipBtn').onclick = () => stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
  showMainScreen('hubDynamic');
}

async function startSmithingCopperArrowTip() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Arrow Tip')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < COPPER_ARROW_TIP_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${COPPER_ARROW_TIP_BAR_COST} Copper Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startArrowTipBtn');
  const stopBtn = document.getElementById('stopArrowTipBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => smithingCopperArrowTipLoop(Date.now(), Date.now()), 16);
}

async function smithingCopperArrowTipLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COPPER_ARROW_TIP_TIME_MS) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < COPPER_ARROW_TIP_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_ARROW_TIP_BAR_COST);
    addItem('Copper Arrow Tip', COPPER_ARROW_TIP_YIELD);
    addXP('blacksmith', COPPER_ARROW_TIP_XP);
    showItemPopup(`+${COPPER_ARROW_TIP_XP} Blacksmith XP`, 'arrowTipProgress', 0);
    showItemPopup(`+${COPPER_ARROW_TIP_YIELD} Copper Arrow Tip`, 'arrowTipProgress', 450);
    
    const bar = document.getElementById('arrowTipProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COPPER_ARROW_TIP_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < COPPER_ARROW_TIP_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more.");
        stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
        return;
    }
    
    return smithingCopperArrowTipLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COPPER_ARROW_TIP_TIME_MS) * 100;
    const bar = document.getElementById('arrowTipProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => smithingCopperArrowTipLoop(Date.now(), startTime), 16);
  }
}
// +++ END: COPPER ARROW TIP UI (Blacksmith) +++


// +++ NEW: FLETCHING HUB FUNCTIONS +++
function openFletchingHub() {
  showMainScreen('hubFletching');
  // Render the items for the hub
  renderFletchingItems();
}

function stopFletching(progressId = 'fletchProgress', startBtnId = 'startFletchBtn', stopBtnId = 'stopFletchBtn'){
  game.fletchingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function renderFletchingItems() {
  const container = document.getElementById('fletchingItemsContainer');
  if (!container) return;
  
  const fletchLvl = game.fletching.level;
  
  const setupFletchButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => {
    const btn = document.getElementById(btnId);
    if (btn) {
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      if (locked) {
        btn.onclick = null;
        // FIX: Added red color to requirement
        const lockedTT = nameHtml + `<div style="color:#ff8888;">Requires Fletching Lvl: ${levelReq}</div>`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  // --- Fletching Level Locks ---
  const shaftLocked = fletchLvl < FLETCHING_SHAFT_LVL;
  const unboundLocked = fletchLvl < FLETCHING_UNBOUND_LVL;
  const copperArrowLocked = fletchLvl < FLETCHING_COPPER_ARROW_LVL;
  const unstrungSoftwoodLocked = fletchLvl < FLETCHING_UNSTRUNG_SOFTWOOD_LVL; // +++ NEW +++
  const softwoodBowLocked = fletchLvl < FLETCHING_SOFTWOOD_BOW_LVL;         // +++ NEW +++
  const unstrungOakLocked = fletchLvl < FLETCHING_UNSTRUNG_OAK_LVL;         // +++ NEW +++
  const oakBowLocked = fletchLvl < FLETCHING_OAK_BOW_LVL;                 // +++ NEW +++
  
  container.innerHTML = `
    <button id="fletchShaftBtn" class="primary ${shaftLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/arrowshaft.png" alt="Arrow Shaft" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchUnboundBtn" class="primary ${unboundLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unboundarrow.png" alt="Unbound Arrow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchCopperArrowBtn" class="primary ${copperArrowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/copperarrow.png" alt="Copper Arrow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    
    <button id="fletchUnstrungSoftwoodBtn" class="primary ${unstrungSoftwoodLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unstrungsoftwoodbow.png" alt="Unstrung Softwood Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchSoftwoodBowBtn" class="primary ${softwoodBowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/softwoodbow.png" alt="Softwood Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchUnstrungOakBtn" class="primary ${unstrungOakLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unstrungoakbow.png" alt="Unstrung Oak Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchOakBowBtn" class="primary ${oakBowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/oakbow.png" alt="Oak Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
  `;
  
  // --- Re-attach listeners for fletching items ---
  setupFletchButton('fletchShaftBtn', shaftLocked, openFletchArrowShaft, FLETCHING_SHAFT_LVL, `Requires: ${ARROW_SHAFT_WOOD_COST} Softwood`, `Arrow Shaft x${ARROW_SHAFT_YIELD}`);
  setupFletchButton('fletchUnboundBtn', unboundLocked, openFletchUnboundArrow, FLETCHING_UNBOUND_LVL, `Requires: ${UNBOUND_ARROW_SHAFT_COST} Arrow Shafts, <br>${UNBOUND_ARROW_FEATHER_COST} Feathers`, `Unbound Arrow x${UNBOUND_ARROW_YIELD}`);
  setupFletchButton('fletchCopperArrowBtn', copperArrowLocked, openFletchCopperArrow, FLETCHING_COPPER_ARROW_LVL, `Requires: ${COPPER_ARROW_UNBOUND_COST} Unbound Arrows, <br>${COPPER_ARROW_TIP_COST} Copper Arrow Tips`, `Copper Arrow x${COPPER_ARROW_YIELD}`);

  // +++ NEW: Bow Listeners +++
  setupFletchButton('fletchUnstrungSoftwoodBtn', unstrungSoftwoodLocked, openFletchUnstrungSoftwoodBow, FLETCHING_UNSTRUNG_SOFTWOOD_LVL, `Requires: ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood`, `Unstrung Softwood Bow x${UNSTRUNG_SOFTWOOD_YIELD}`);
  setupFletchButton('fletchSoftwoodBowBtn', softwoodBowLocked, openFletchSoftwoodBow, FLETCHING_SOFTWOOD_BOW_LVL, `Requires: ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow, <br>${SOFTWOOD_BOW_STRING_COST} Bow String`, `Softwood Bow x${SOFTWOOD_BOW_YIELD}`);
  setupFletchButton('fletchUnstrungOakBtn', unstrungOakLocked, openFletchUnstrungOakBow, FLETCHING_UNSTRUNG_OAK_LVL, `Requires: ${UNSTRUNG_OAK_WOOD_COST} Oak`, `Unstrung Oak Bow x${UNSTRUNG_OAK_YIELD}`);
  setupFletchButton('fletchOakBowBtn', oakBowLocked, openFletchOakBow, FLETCHING_OAK_BOW_LVL, `Requires: ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow, <br>${OAK_BOW_STRING_COST} Bow String`, `Oak Bow x${OAK_BOW_YIELD}`);
}

// --- Arrow Shaft UI & Logic ---
function openFletchArrowShaft(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Arrow Shaft</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${ARROW_SHAFT_WOOD_COST} Softwood. Yields ${ARROW_SHAFT_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingArrowShaft;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingArrowShaft() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Arrow Shaft')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalWood < ARROW_SHAFT_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${ARROW_SHAFT_WOOD_COST} Softwood.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingArrowShaftLoop(Date.now(), Date.now()), 16);
}

async function fletchingArrowShaftLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= ARROW_SHAFT_TIME_MS) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalWood < ARROW_SHAFT_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Softwood.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Softwood', ARROW_SHAFT_WOOD_COST);
    addItem('Arrow Shaft', ARROW_SHAFT_YIELD);
    addXP('fletching', ARROW_SHAFT_XP);
    showItemPopup(`+${ARROW_SHAFT_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${ARROW_SHAFT_YIELD} Arrow Shaft`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - ARROW_SHAFT_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < ARROW_SHAFT_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Softwood to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingArrowShaftLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / ARROW_SHAFT_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingArrowShaftLoop(Date.now(), startTime), 16);
  }
}

// --- Unbound Arrow UI & Logic ---
function openFletchUnboundArrow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unbound Arrow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNBOUND_ARROW_SHAFT_COST} Arrow Shaft, ${UNBOUND_ARROW_FEATHER_COST} Feather. Yields ${UNBOUND_ARROW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnboundArrow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnboundArrow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unbound Arrow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalShafts = 0;
  let totalFeathers = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Arrow Shaft') totalShafts += slot.qty;
      if (slot && slot.name === 'Feather') totalFeathers += slot.qty;
  }

  if (totalShafts < UNBOUND_ARROW_SHAFT_COST || totalFeathers < UNBOUND_ARROW_FEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need ${UNBOUND_ARROW_SHAFT_COST} Arrow Shafts and ${UNBOUND_ARROW_FEATHER_COST} Feathers.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingUnboundArrowLoop(Date.now(), Date.now()), 16);
}

async function fletchingUnboundArrowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= UNBOUND_ARROW_TIME_MS) {
    let totalShafts = 0;
    let totalFeathers = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Arrow Shaft') totalShafts += slot.qty;
        if (slot && slot.name === 'Feather') totalFeathers += slot.qty;
    }
    if (totalShafts < UNBOUND_ARROW_SHAFT_COST || totalFeathers < UNBOUND_ARROW_FEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Arrow Shaft', UNBOUND_ARROW_SHAFT_COST);
    removeItem('Feather', UNBOUND_ARROW_FEATHER_COST);
    addItem('Unbound Arrow', UNBOUND_ARROW_YIELD);
    addXP('fletching', UNBOUND_ARROW_XP);
    showItemPopup(`+${UNBOUND_ARROW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNBOUND_ARROW_YIELD} Unbound Arrow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - UNBOUND_ARROW_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalShaftsAfter = 0;
    let totalFeathersAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Arrow Shaft') totalShaftsAfter += slot.qty;
        if (slot && slot.name === 'Feather') totalFeathersAfter += slot.qty;
    }
    if (totalShaftsAfter < UNBOUND_ARROW_SHAFT_COST || totalFeathersAfter < UNBOUND_ARROW_FEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingUnboundArrowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / UNBOUND_ARROW_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingUnboundArrowLoop(Date.now(), startTime), 16);
  }
}

// --- Copper Arrow UI & Logic ---
function openFletchCopperArrow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Copper Arrow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_ARROW_UNBOUND_COST} Unbound Arrow, ${COPPER_ARROW_TIP_COST} Copper Arrow Tip. Yields ${COPPER_ARROW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingCopperArrow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingCopperArrow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Arrow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnbound = 0;
  let totalTips = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unbound Arrow') totalUnbound += slot.qty;
      if (slot && slot.name === 'Copper Arrow Tip') totalTips += slot.qty;
  }

  if (totalUnbound < COPPER_ARROW_UNBOUND_COST || totalTips < COPPER_ARROW_TIP_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_ARROW_UNBOUND_COST} Unbound Arrows and ${COPPER_ARROW_TIP_COST} Copper Arrow Tips.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingCopperArrowLoop(Date.now(), Date.now()), 16);
}

async function fletchingCopperArrowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COPPER_ARROW_TIME_MS) {
    let totalUnbound = 0;
    let totalTips = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unbound Arrow') totalUnbound += slot.qty;
        if (slot && slot.name === 'Copper Arrow Tip') totalTips += slot.qty;
    }
    if (totalUnbound < COPPER_ARROW_UNBOUND_COST || totalTips < COPPER_ARROW_TIP_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unbound Arrow', COPPER_ARROW_UNBOUND_COST);
    removeItem('Copper Arrow Tip', COPPER_ARROW_TIP_COST);
    addItem('Copper Arrow', COPPER_ARROW_YIELD);
    addXP('fletching', COPPER_ARROW_XP);
    showItemPopup(`+${COPPER_ARROW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${COPPER_ARROW_YIELD} Copper Arrow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - COPPER_ARROW_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalUnboundAfter = 0;
    let totalTipsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unbound Arrow') totalUnboundAfter += slot.qty;
        if (slot && slot.name === 'Copper Arrow Tip') totalTipsAfter += slot.qty;
    }
    if (totalUnboundAfter < COPPER_ARROW_UNBOUND_COST || totalTipsAfter < COPPER_ARROW_TIP_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingCopperArrowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / COPPER_ARROW_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingCopperArrowLoop(Date.now(), startTime), 16);
  }
}
// +++ END: FLETCHING HUB FUNCTIONS +++

// +++ NEW: CRAFTING HUB FUNCTIONS +++
function openCraftingHub() {
  showMainScreen('hubCrafting');
  // Render the items for the hub
  renderCraftingItems();
}

/**
 * Stops the bow string crafting loop (used by other functions)
 */
window.stopCraftingBowString = function(){
  game.craftingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  
  const bar = document.getElementById('craftProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCraftBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCraftBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

/**
 * Renders the items available at the Crafting Bench
 */
function renderCraftingItems() {
  const container = document.getElementById('craftingItemsContainer');
  if (!container) return;
  
  const craftLvl = game.crafting.level;
  
  const setupCraftButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => {
    const btn = document.getElementById(btnId);
    if (btn) {
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      if (locked) {
        btn.onclick = null;
        // FIX: Added red color to requirement
        const lockedTT = nameHtml + `<div style="color:#ff8888;">Requires Crafting Lvl: ${levelReq}</div>`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  // --- Crafting Level Locks ---
  const bowStringLocked = craftLvl < CRAFTING_BOW_STRING_LVL;
  const emptyVialLocked = craftLvl < CRAFTING_EMPTY_VIAL_LVL; // +++ NEW +++
  const leatherLocked = craftLvl < CRAFTING_LEATHER_LVL; // +++ NEW +++
  const leatherBootsLocked = craftLvl < CRAFTING_LEATHER_BOOTS_LVL;
  const leatherHoodLocked = craftLvl < CRAFTING_LEATHER_HOOD_LVL;
  const leatherChapsLocked = craftLvl < CRAFTING_LEATHER_CHAPS_LVL;
  const leatherBodyLocked = craftLvl < CRAFTING_LEATHER_BODY_LVL;
  
  // +++ NEW WIZARD/CLOTH LOCKS +++
  const clothLocked = craftLvl < CRAFTING_CLOTH_LVL;
  const wizardBootsLocked = craftLvl < CRAFTING_WIZARD_BOOTS_LVL;
  const wizardHatLocked = craftLvl < CRAFTING_WIZARD_HAT_LVL;
  const wizardTrousersLocked = craftLvl < CRAFTING_WIZARD_TROUSERS_LVL;
  const wizardRobeLocked = craftLvl < CRAFTING_WIZARD_ROBE_LVL;
  const magicStaffLocked = craftLvl < CRAFTING_MAGIC_STAFF_LVL; // +++ NEW +++

  container.innerHTML = `
    <button id="craftBowStringBtn" class="primary ${bowStringLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/bowstring.png" alt="Bow String" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftEmptyVialBtn" class="primary ${emptyVialLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/emptyvial.png" alt="Empty Vial" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBtn" class="primary ${leatherLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leather.png" alt="Leather" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBootsBtn" class="primary ${leatherBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherboots.png" alt="Leather Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherHoodBtn" class="primary ${leatherHoodLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherhood.png" alt="Leather Hood" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherChapsBtn" class="primary ${leatherChapsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherpants.png" alt="Leather Chaps" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBodyBtn" class="primary ${leatherBodyLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherarmor.png" alt="Leather Body" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    
    <!-- NEW CLOTH & WIZARD ITEMS -->
    <button id="craftClothBtn" class="primary ${clothLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/cloth.png" alt="Cloth" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftWizardBootsBtn" class="primary ${wizardBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/wizardboots.png" alt="Wizard Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftWizardHatBtn" class="primary ${wizardHatLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/wizardhat.png" alt="Wizard Hat" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftWizardTrousersBtn" class="primary ${wizardTrousersLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/wizardtrousers.png" alt="Wizard Trousers" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftWizardRobeBtn" class="primary ${wizardRobeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/wizardrobe.png" alt="Wizard Robe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftMagicStaffBtn" class="primary ${magicStaffLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/magicstaff.png" alt="Magic Staff" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
  `;
  
  // --- Re-attach listeners for crafting items ---
  setupCraftButton('craftBowStringBtn', bowStringLocked, openCraftBowString, CRAFTING_BOW_STRING_LVL, `Requires: ${BOW_STRING_SILK_COST} Silk`, `Bow String x${BOW_STRING_YIELD}`);
  setupCraftButton('craftEmptyVialBtn', emptyVialLocked, openCraftEmptyVial, CRAFTING_EMPTY_VIAL_LVL, `Requires: ${EMPTY_VIAL_SAND_COST} Sand, ${EMPTY_VIAL_COAL_COST} Coal Ore`, `Empty Vial`);
  // +++ NEW/UPDATED LISTENERS +++
  setupCraftButton('craftLeatherBtn', leatherLocked, openCraftLeather, CRAFTING_LEATHER_LVL, `Requires: ${LEATHER_HIDE_COST} Cow Hide`, 'Leather');
  setupCraftButton('craftLeatherBootsBtn', leatherBootsLocked, openCraftLeatherBoots, CRAFTING_LEATHER_BOOTS_LVL, `Requires: ${LEATHER_BOOTS_LEATHER_COST} Leather`, 'Leather Boots');
  setupCraftButton('craftLeatherHoodBtn', leatherHoodLocked, openCraftLeatherHood, CRAFTING_LEATHER_HOOD_LVL, `Requires: ${LEATHER_HOOD_LEATHER_COST} Leather`, 'Leather Hood');
  setupCraftButton('craftLeatherChapsBtn', leatherChapsLocked, openCraftLeatherChaps, CRAFTING_LEATHER_CHAPS_LVL, `Requires: ${LEATHER_CHAPS_LEATHER_COST} Leather`, 'Leather Chaps');
  setupCraftButton('craftLeatherBodyBtn', leatherBodyLocked, openCraftLeatherBody, CRAFTING_LEATHER_BODY_LVL, `Requires: ${LEATHER_BODY_LEATHER_COST} Leather`, 'Leather Body');
  
  // +++ NEW WIZARD/CLOTH LISTENERS +++
  setupCraftButton('craftClothBtn', clothLocked, openCraftCloth, CRAFTING_CLOTH_LVL, `Requires: ${CLOTH_SILK_COST} Silk`, `Cloth x${CLOTH_YIELD}`);
  setupCraftButton('craftWizardBootsBtn', wizardBootsLocked, openCraftWizardBoots, CRAFTING_WIZARD_BOOTS_LVL, `Requires: ${WIZARD_BOOTS_CLOTH_COST} Cloth`, 'Wizard Boots');
  setupCraftButton('craftWizardHatBtn', wizardHatLocked, openCraftWizardHat, CRAFTING_WIZARD_HAT_LVL, `Requires: ${WIZARD_HAT_CLOTH_COST} Cloth`, 'Wizard Hat');
  setupCraftButton('craftWizardTrousersBtn', wizardTrousersLocked, openCraftWizardTrousers, CRAFTING_WIZARD_TROUSERS_LVL, `Requires: ${WIZARD_TROUSERS_CLOTH_COST} Cloth`, 'Wizard Trousers');
  setupCraftButton('craftWizardRobeBtn', wizardRobeLocked, openCraftWizardRobe, CRAFTING_WIZARD_ROBE_LVL, `Requires: ${WIZARD_ROBE_CLOTH_COST} Cloth`, 'Wizard Robe');
  // +++ NEW LISTENER +++
  setupCraftButton('craftMagicStaffBtn', magicStaffLocked, openCraftMagicStaff, CRAFTING_MAGIC_STAFF_LVL, `Requires: 10 Oak, 10 Earth/Air/Water Crystals`, 'Magic Staff');
}

// --- Empty Vial UI & Logic ---
function openCraftEmptyVial(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching(); 
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Empty Vial</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${EMPTY_VIAL_SAND_COST} Sand, ${EMPTY_VIAL_COAL_COST} Coal Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingEmptyVial;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Reuse generic stop
  showMainScreen('hubDynamic');
}

async function startCraftingEmptyVial() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "Session not active.");
    return;
  }
  
  if (!canReceiveItem('Empty Vial')) {
    await showGameAlert("Inventory Full", "Inventory full.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalSand = 0;
  let totalCoal = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Sand') totalSand += slot.qty;
      if (slot && slot.name === 'Coal Ore') totalCoal += slot.qty;
  }

  if (totalSand < EMPTY_VIAL_SAND_COST || totalCoal < EMPTY_VIAL_COAL_COST) {
      await showGameAlert("Not Enough Materials", `You need ${EMPTY_VIAL_SAND_COST} Sand and ${EMPTY_VIAL_COAL_COST} Coal Ore.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingEmptyVialLoop(Date.now(), Date.now()), 16);
}

async function craftingEmptyVialLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= EMPTY_VIAL_TIME_MS) {
    let totalSand = 0;
    let totalCoal = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Sand') totalSand += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoal += slot.qty;
    }
    if (totalSand < EMPTY_VIAL_SAND_COST || totalCoal < EMPTY_VIAL_COAL_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Sand', EMPTY_VIAL_SAND_COST);
    removeItem('Coal Ore', EMPTY_VIAL_COAL_COST);
    addItem('Empty Vial', 1);
    addXP('crafting', EMPTY_VIAL_XP);
    showItemPopup(`+${EMPTY_VIAL_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Empty Vial`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - EMPTY_VIAL_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalSandAfter = 0;
    let totalCoalAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Sand') totalSandAfter += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalAfter += slot.qty;
    }
    if (totalSandAfter < EMPTY_VIAL_SAND_COST || totalCoalAfter < EMPTY_VIAL_COAL_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingEmptyVialLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / EMPTY_VIAL_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingEmptyVialLoop(Date.now(), startTime), 16);
  }
}

// --- Bow String UI & Logic ---
function openCraftBowString(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching(); // Stop other skills
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Bow String</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${BOW_STRING_SILK_COST} Silk. Yields ${BOW_STRING_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingBowString;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Use the global-scoped function
  showMainScreen('hubDynamic');
}

async function startCraftingBowString() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Bow String')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalSilk = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Silk') totalSilk += slot.qty;
  }

  if (totalSilk < BOW_STRING_SILK_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${BOW_STRING_SILK_COST} Silk.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingBowStringLoop(Date.now(), Date.now()), 16);
}

async function craftingBowStringLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= BOW_STRING_TIME_MS) {
    let totalSilk = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilk += slot.qty;
    }
    if (totalSilk < BOW_STRING_SILK_COST) {
        await showGameAlert("Out of Materials", "You've run out of Silk.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Silk', BOW_STRING_SILK_COST);
    addItem('Bow String', BOW_STRING_YIELD);
    addXP('crafting', BOW_STRING_XP);
    showItemPopup(`+${BOW_STRING_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+${BOW_STRING_YIELD} Bow String`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - BOW_STRING_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalSilkAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilkAfter += slot.qty;
    }
    if (totalSilkAfter < BOW_STRING_SILK_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Silk to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingBowStringLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / BOW_STRING_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingBowStringLoop(Date.now(), startTime), 16);
  }
}
// +++ END: CRAFTING HUB FUNCTIONS +++

// +++ NEW: LEATHER CRAFTING FUNCTIONS +++

// --- Leather Boots UI & Logic ---
function openCraftLeatherBoots(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_BOOTS_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherBoots;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Can reuse the same stop function
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherBoots() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_BOOTS_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_BOOTS_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingLeatherBootsLoop(Date.now(), Date.now()), 16);
}

async function craftingLeatherBootsLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= LEATHER_BOOTS_TIME_MS) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_BOOTS_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_BOOTS_LEATHER_COST);
    addItem('Leather Boots', 1);
    addXP('crafting', LEATHER_BOOTS_XP);
    showItemPopup(`+${LEATHER_BOOTS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Boots`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - LEATHER_BOOTS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_BOOTS_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingLeatherBootsLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / LEATHER_BOOTS_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingLeatherBootsLoop(Date.now(), startTime), 16);
  }
}

// --- Leather Hood UI & Logic ---
function openCraftLeatherHood(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Hood</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_HOOD_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherHood;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherHood() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Hood')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_HOOD_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_HOOD_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingLeatherHoodLoop(Date.now(), Date.now()), 16);
}

async function craftingLeatherHoodLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= LEATHER_HOOD_TIME_MS) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_HOOD_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_HOOD_LEATHER_COST);
    addItem('Leather Hood', 1);
    addXP('crafting', LEATHER_HOOD_XP);
    showItemPopup(`+${LEATHER_HOOD_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Hood`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - LEATHER_HOOD_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_HOOD_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingLeatherHoodLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / LEATHER_HOOD_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingLeatherHoodLoop(Date.now(), startTime), 16);
  }
}

// --- Leather Chaps UI & Logic ---
function openCraftLeatherChaps(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Chaps</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_CHAPS_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherChaps;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherChaps() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Chaps')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_CHAPS_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_CHAPS_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingLeatherChapsLoop(Date.now(), Date.now()), 16);
}

async function craftingLeatherChapsLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= LEATHER_CHAPS_TIME_MS) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_CHAPS_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_CHAPS_LEATHER_COST);
    addItem('Leather Chaps', 1);
    addXP('crafting', LEATHER_CHAPS_XP);
    showItemPopup(`+${LEATHER_CHAPS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Chaps`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - LEATHER_CHAPS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_CHAPS_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingLeatherChapsLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / LEATHER_CHAPS_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingLeatherChapsLoop(Date.now(), startTime), 16);
  }
}

// --- Leather Body UI & Logic ---
function openCraftLeatherBody(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Body</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_BODY_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherBody;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherBody() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Body')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_BODY_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_BODY_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingLeatherBodyLoop(Date.now(), Date.now()), 16);
}

async function craftingLeatherBodyLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= LEATHER_BODY_TIME_MS) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_BODY_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_BODY_LEATHER_COST);
    addItem('Leather Body', 1);
    addXP('crafting', LEATHER_BODY_XP);
    showItemPopup(`+${LEATHER_BODY_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Body`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - LEATHER_BODY_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_BODY_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingLeatherBodyLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / LEATHER_BODY_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingLeatherBodyLoop(Date.now(), startTime), 16);
  }
}

// --- Craft Leather (from Hide) UI & Logic ---
function openCraftLeather(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_HIDE_COST} Cow Hide.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeather;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeather() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalHide = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cow Hide') totalHide += slot.qty;
  }

  if (totalHide < LEATHER_HIDE_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_HIDE_COST} Cow Hide.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingLeatherLoop(Date.now(), Date.now()), 16);
}

async function craftingLeatherLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= LEATHER_TIME_MS) {
    let totalHide = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cow Hide') totalHide += slot.qty;
    }
    if (totalHide < LEATHER_HIDE_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cow Hide.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cow Hide', LEATHER_HIDE_COST);
    addItem('Leather', 1);
    addXP('crafting', LEATHER_XP);
    showItemPopup(`+${LEATHER_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - LEATHER_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalHideAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cow Hide') totalHideAfter += slot.qty;
    }
    if (totalHideAfter < LEATHER_HIDE_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cow Hide to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingLeatherLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / LEATHER_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingLeatherLoop(Date.now(), startTime), 16);
  }
}

// +++ END: LEATHER CRAFTING FUNCTIONS +++


// +++ NEW: CLOTH & WIZARD GEAR CRAFTING FUNCTIONS +++

// --- Craft Cloth (from Silk) UI & Logic ---
function openCraftCloth(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Cloth</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${CLOTH_SILK_COST} Silk. Yields ${CLOTH_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingCloth;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Generic stop
  showMainScreen('hubDynamic');
}

async function startCraftingCloth() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Cloth')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalSilk = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Silk') totalSilk += slot.qty;
  }

  if (totalSilk < CLOTH_SILK_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${CLOTH_SILK_COST} Silk.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingClothLoop(Date.now(), Date.now()), 16);
}

async function craftingClothLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= CLOTH_TIME_MS) {
    let totalSilk = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilk += slot.qty;
    }
    if (totalSilk < CLOTH_SILK_COST) {
        await showGameAlert("Out of Materials", "You've run out of Silk.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Silk', CLOTH_SILK_COST);
    addItem('Cloth', CLOTH_YIELD);
    addXP('crafting', CLOTH_XP);
    showItemPopup(`+${CLOTH_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+${CLOTH_YIELD} Cloth`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - CLOTH_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalSilkAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilkAfter += slot.qty;
    }
    if (totalSilkAfter < CLOTH_SILK_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Silk to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingClothLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / CLOTH_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingClothLoop(Date.now(), startTime), 16);
  }
}

// --- Wizard Boots UI & Logic ---
function openCraftWizardBoots(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Wizard Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${WIZARD_BOOTS_CLOTH_COST} Cloth.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingWizardBoots;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingWizardBoots() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Wizard Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalCloth = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
  }

  if (totalCloth < WIZARD_BOOTS_CLOTH_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${WIZARD_BOOTS_CLOTH_COST} Cloth.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingWizardBootsLoop(Date.now(), Date.now()), 16);
}

async function craftingWizardBootsLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= WIZARD_BOOTS_TIME_MS) {
    let totalCloth = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
    }
    if (totalCloth < WIZARD_BOOTS_CLOTH_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cloth.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cloth', WIZARD_BOOTS_CLOTH_COST);
    addItem('Wizard Boots', 1);
    addXP('crafting', WIZARD_BOOTS_XP);
    showItemPopup(`+${WIZARD_BOOTS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Wizard Boots`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - WIZARD_BOOTS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalClothAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalClothAfter += slot.qty;
    }
    if (totalClothAfter < WIZARD_BOOTS_CLOTH_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cloth to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingWizardBootsLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / WIZARD_BOOTS_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingWizardBootsLoop(Date.now(), startTime), 16);
  }
}

// --- Wizard Hat UI & Logic ---
function openCraftWizardHat(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Wizard Hat</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${WIZARD_HAT_CLOTH_COST} Cloth.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingWizardHat;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingWizardHat() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Wizard Hat')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalCloth = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
  }

  if (totalCloth < WIZARD_HAT_CLOTH_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${WIZARD_HAT_CLOTH_COST} Cloth.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingWizardHatLoop(Date.now(), Date.now()), 16);
}

async function craftingWizardHatLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= WIZARD_HAT_TIME_MS) {
    let totalCloth = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
    }
    if (totalCloth < WIZARD_HAT_CLOTH_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cloth.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cloth', WIZARD_HAT_CLOTH_COST);
    addItem('Wizard Hat', 1);
    addXP('crafting', WIZARD_HAT_XP);
    showItemPopup(`+${WIZARD_HAT_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Wizard Hat`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - WIZARD_HAT_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalClothAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalClothAfter += slot.qty;
    }
    if (totalClothAfter < WIZARD_HAT_CLOTH_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cloth to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingWizardHatLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / WIZARD_HAT_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingWizardHatLoop(Date.now(), startTime), 16);
  }
}

// --- Wizard Trousers UI & Logic ---
function openCraftWizardTrousers(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Wizard Trousers</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${WIZARD_TROUSERS_CLOTH_COST} Cloth.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingWizardTrousers;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingWizardTrousers() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Wizard Trousers')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalCloth = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
  }

  if (totalCloth < WIZARD_TROUSERS_CLOTH_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${WIZARD_TROUSERS_CLOTH_COST} Cloth.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingWizardTrousersLoop(Date.now(), Date.now()), 16);
}

async function craftingWizardTrousersLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= WIZARD_TROUSERS_TIME_MS) {
    let totalCloth = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
    }
    if (totalCloth < WIZARD_TROUSERS_CLOTH_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cloth.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cloth', WIZARD_TROUSERS_CLOTH_COST);
    addItem('Wizard Trousers', 1);
    addXP('crafting', WIZARD_TROUSERS_XP);
    showItemPopup(`+${WIZARD_TROUSERS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Wizard Trousers`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - WIZARD_TROUSERS_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalClothAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalClothAfter += slot.qty;
    }
    if (totalClothAfter < WIZARD_TROUSERS_CLOTH_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cloth to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingWizardTrousersLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / WIZARD_TROUSERS_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingWizardTrousersLoop(Date.now(), startTime), 16);
  }
}

// --- Wizard Robe UI & Logic ---
function openCraftWizardRobe(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Wizard Robe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${WIZARD_ROBE_CLOTH_COST} Cloth.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingWizardRobe;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingWizardRobe() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Wizard Robe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalCloth = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
  }

  if (totalCloth < WIZARD_ROBE_CLOTH_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${WIZARD_ROBE_CLOTH_COST} Cloth.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingWizardRobeLoop(Date.now(), Date.now()), 16);
}

async function craftingWizardRobeLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= WIZARD_ROBE_TIME_MS) {
    let totalCloth = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalCloth += slot.qty;
    }
    if (totalCloth < WIZARD_ROBE_CLOTH_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cloth.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cloth', WIZARD_ROBE_CLOTH_COST);
    addItem('Wizard Robe', 1);
    addXP('crafting', WIZARD_ROBE_XP);
    showItemPopup(`+${WIZARD_ROBE_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Wizard Robe`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - WIZARD_ROBE_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalClothAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cloth') totalClothAfter += slot.qty;
    }
    if (totalClothAfter < WIZARD_ROBE_CLOTH_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cloth to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingWizardRobeLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / WIZARD_ROBE_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingWizardRobeLoop(Date.now(), startTime), 16);
  }
}

// +++ NEW: Magic Staff Crafting Functions +++
function openCraftMagicStaff(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Magic Staff</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 10 Oak, 10 Earth Crystal, 10 Air Crystal, 10 Water Crystal.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingMagicStaff;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingMagicStaff() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  if (!canReceiveItem('Magic Staff')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.craftingActive) return;

  let totalOak = 0, totalEarth = 0, totalAir = 0, totalWater = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Oak') totalOak += slot.qty;
      if (slot && slot.name === 'Earth Crystal Shard') totalEarth += slot.qty;
      if (slot && slot.name === 'Air Crystal Shard') totalAir += slot.qty;
      if (slot && slot.name === 'Water Crystal Shard') totalWater += slot.qty;
  }

  if (totalOak < MAGIC_STAFF_OAK_COST || totalEarth < MAGIC_STAFF_EARTH_COST || totalAir < MAGIC_STAFF_AIR_COST || totalWater < MAGIC_STAFF_WATER_COST) {
      await showGameAlert("Not Enough Materials", `You need 10 Oak, 10 Earth, 10 Air, and 10 Water Crystals.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => craftingMagicStaffLoop(Date.now(), Date.now()), 16);
}

async function craftingMagicStaffLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= MAGIC_STAFF_TIME_MS) {
    let totalOak = 0, totalEarth = 0, totalAir = 0, totalWater = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalOak += slot.qty;
        if (slot && slot.name === 'Earth Crystal Shard') totalEarth += slot.qty;
        if (slot && slot.name === 'Air Crystal Shard') totalAir += slot.qty;
        if (slot && slot.name === 'Water Crystal Shard') totalWater += slot.qty;
    }

    if (totalOak < MAGIC_STAFF_OAK_COST || totalEarth < MAGIC_STAFF_EARTH_COST || totalAir < MAGIC_STAFF_AIR_COST || totalWater < MAGIC_STAFF_WATER_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Oak', MAGIC_STAFF_OAK_COST);
    removeItem('Earth Crystal Shard', MAGIC_STAFF_EARTH_COST);
    removeItem('Air Crystal Shard', MAGIC_STAFF_AIR_COST);
    removeItem('Water Crystal Shard', MAGIC_STAFF_WATER_COST);
    
    addItem('Magic Staff', 1);
    addXP('crafting', MAGIC_STAFF_XP);
    showItemPopup(`+${MAGIC_STAFF_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Magic Staff`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    const overdueTime = elapsed - MAGIC_STAFF_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    // Check again for next loop
    let totalOakAfter = 0, totalEarthAfter = 0, totalAirAfter = 0, totalWaterAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalOakAfter += slot.qty;
        if (slot && slot.name === 'Earth Crystal Shard') totalEarthAfter += slot.qty;
        if (slot && slot.name === 'Air Crystal Shard') totalAirAfter += slot.qty;
        if (slot && slot.name === 'Water Crystal Shard') totalWaterAfter += slot.qty;
    }

    if (totalOakAfter < MAGIC_STAFF_OAK_COST || totalEarthAfter < MAGIC_STAFF_EARTH_COST || totalAirAfter < MAGIC_STAFF_AIR_COST || totalWaterAfter < MAGIC_STAFF_WATER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopCraftingBowString();
        return;
    }
    
    return craftingMagicStaffLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / MAGIC_STAFF_TIME_MS) * 100;
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => craftingMagicStaffLoop(Date.now(), startTime), 16);
  }
}

// =================================================================
// +++ NEW: STONE FORGING FUNCTIONS +++
// =================================================================

const STONE_CRAFT_TIME_MS = 3000;
const STONE_CRAFT_XP = 40; 
const STONE_SHARD_COST = 5;

// +++ NEW LEVEL REQUIREMENTS +++
const STONE_FORGE_EARTH_LVL = 1;
const STONE_FORGE_AIR_LVL = 20;
const STONE_FORGE_WATER_LVL = 40;

// +++ NEW BOUNTY HUNTING CONSTANTS +++
const BOUNTY_TIER_1_TARGETS = ['Rat', 'Spider', 'Chicken', 'Cow', 'Centipede'];
const BOUNTY_KILL_XP = 15; // XP gained per kill on a bounty target
const BOUNTY_REWARD_GOLD = 500;
const BOUNTY_REQ_COUNT = 100; // Default kill count

function openElementalForgeHub() {
  showMainScreen('hubElementalForge');
  renderElementalForgeItems();
}

function renderElementalForgeItems() {
  const container = document.getElementById('elementalForgeItemsContainer');
  if (!container) return;

  const sfLvl = game.stoneforging.level;

  // Check locks
  const earthLocked = sfLvl < STONE_FORGE_EARTH_LVL;
  const airLocked = sfLvl < STONE_FORGE_AIR_LVL;
  const waterLocked = sfLvl < STONE_FORGE_WATER_LVL;
  
  container.innerHTML = `
    <button id="forgeEarthstoneBtn" class="primary ${earthLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/earthstone.png" alt="Earthstone" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="forgeAirstoneBtn" class="primary ${airLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/airstone.png" alt="Airstone" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="forgeWaterstoneBtn" class="primary ${waterLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/waterstone.png" alt="Waterstone" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
  `;

  const setupBtn = (id, name, shardsName, func, locked, levelReq) => {
      const btn = document.getElementById(id);
      if(btn) {
        const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>`;
        
        // Set color: Red if locked, White if unlocked
        const reqColor = locked ? '#ff8888' : '#fff';
        const levelHtml = `<div style="color:${reqColor};">Requires Stone Forging Lvl: ${levelReq}</div>`;
        
        if (locked) {
          btn.onclick = null;
          // Locked: Show Name + Red Level Requirement
          btn.onmouseenter = (e) => showTooltip(e, nameHtml + levelHtml);
        } else {
          btn.onclick = func;
          // Unlocked: Show Name + White Level Requirement + Materials
          const materialHtml = `Requires: 5 ${shardsName}`;
          btn.onmouseenter = (e) => showTooltip(e, nameHtml + levelHtml + materialHtml);
        }
        btn.onmouseleave = hideTooltip;
      }
  };

  setupBtn('forgeEarthstoneBtn', 'Earthstone', 'Earth Crystal Shards', () => openForgeStone('Earth'), earthLocked, STONE_FORGE_EARTH_LVL);
  setupBtn('forgeAirstoneBtn', 'Airstone', 'Air Crystal Shards', () => openForgeStone('Air'), airLocked, STONE_FORGE_AIR_LVL);
  setupBtn('forgeWaterstoneBtn', 'Waterstone', 'Water Crystal Shards', () => openForgeStone('Water'), waterLocked, STONE_FORGE_WATER_LVL);
}

function stopStoneForging() {
  game.stoneforgingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  
  const bar = document.getElementById('forgeProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startForgeBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopForgeBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// =================================================================
// +++ NEW: BOUNTY HUNTING FUNCTIONS +++
// =================================================================

function openHuntingBoard() {
  showMainScreen('hubHuntingBoard');
  renderBountyInterface();
}

function renderBountyInterface() {
  const container = document.getElementById('bountyContent');
  if (!container) return;
  container.innerHTML = '';

  if (game.activeBounty) {
    // --- ACTIVE MISSION VIEW ---
    const b = game.activeBounty;
    const isComplete = b.kills >= b.req;
    const statusColor = isComplete ? '#44aa44' : '#efe3cf';
    const statusText = isComplete ? 'MISSION COMPLETE' : 'IN PROGRESS';
    
    const bountyHtml = `
      <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 2px solid ${isComplete ? '#44aa44' : 'var(--accent)'};">
        <h3 style="color: var(--gold); margin-top: 0;">Current Bounty: Kill ${b.target}s</h3>
        <div style="color: ${statusColor}; font-weight: bold; margin-bottom: 10px;">${statusText}</div>
        
        <div style="margin-bottom: 10px;">
           Progress: <span style="color: #fff;">${b.kills} / ${b.req}</span>
        </div>
        <div style="width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
           <div style="width: ${Math.min(100, (b.kills / b.req) * 100)}%; height: 100%; background: var(--gold);"></div>
        </div>
        <div style="margin-top: 15px; font-size: 14px; color: #ccc;">
           Reward: ${BOUNTY_REWARD_GOLD} Gold
        </div>
        
        ${isComplete ? 
          `<button onclick="claimBountyReward()" class="primary" style="margin-top: 15px; background: #44aa44; width: 100%;">Claim Reward</button>` : 
          `<div style="margin-top: 15px; font-style: italic; color: #888;">Return here when the job is done.</div>`
        }
      </div>
    `;
    container.innerHTML = bountyHtml;

  } else {
    // --- SELECT MISSION VIEW ---
    // Currently only Lvl 1 Category
    container.innerHTML = `
      <div onclick="assignBounty(1)" class="quest-line-card" style="text-align: left;">
        <div style="font-size: 18px; font-weight: bold; color: var(--gold);">Level 1 Bounties</div>
        <div style="font-size: 12px; color: #ccc; margin-top: 4px;">Simple tasks for beginners. Rats, Spiders, Chickens, etc.</div>
        <div style="margin-top: 8px; color: #aaffaa;">Click to accept a random mission</div>
      </div>
    `;
  }
}

async function assignBounty(tier) {
  if (!game.isSessionActive) {
    await showGameAlert("Session Error", "Session not active.");
    return;
  }
  
  // Pick random target
  const targets = BOUNTY_TIER_1_TARGETS;
  const randomTarget = targets[Math.floor(Math.random() * targets.length)];
  
  game.activeBounty = {
    target: randomTarget,
    req: BOUNTY_REQ_COUNT,
    kills: 0,
    tier: tier
  };
  
  await showGameAlert("Bounty Accepted", `Your mission: Kill ${BOUNTY_REQ_COUNT} ${randomTarget}s.`);
  
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
  renderBountyInterface();
}

async function claimBountyReward() {
  if (!game.activeBounty || game.activeBounty.kills < game.activeBounty.req) return;
  
  addGold(BOUNTY_REWARD_GOLD);
  playGlobalSound('sounds/soundeffects/levelupsound.mp3');
  
  game.activeBounty = null; // Clear mission
  
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
  
  renderBountyInterface();
  await showGameAlert("Bounty Claimed", `You received ${BOUNTY_REWARD_GOLD} Gold.`);
}

function updateBountyProgress(enemyName, delay = 0) {
  if (game.activeBounty && game.activeBounty.target === enemyName) {
    if (game.activeBounty.kills < game.activeBounty.req) {
      game.activeBounty.kills++;
      
      // Award XP per kill with delay
      // We ensure delay is treated as a number
      addXP('bountyhunting', BOUNTY_KILL_XP, parseInt(delay));
      
      if (typeof window.savePlayerData === 'function') window.savePlayerData();
    }
  }
}

function openForgeStone(type) {
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  stopFishing();
  
  const wrapper = document.getElementById('hubDynamic');
  const shardName = `${type} Crystal Shard`;
  const stoneName = `${type}stone`;

  wrapper.innerHTML = `
    <h2>Forge - ${stoneName}</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 5 ${shardName}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="forgeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startForgeBtn" class="primary">Start Forging</button>
      <button id="stopForgeBtn" class="primary" style="background:#555; display:none;">Stop Forging</button>
      <button onclick="openElementalForgeHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startForgeBtn').onclick = () => startForgingStone(type);
  document.getElementById('stopForgeBtn').onclick = stopStoneForging;
  showMainScreen('hubDynamic');
}

async function startForgingStone(type) {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active.");
    return;
  }
  
  // +++ NEW LEVEL CHECK +++
  let levelReq = 1;
  if (type === 'Earth') levelReq = STONE_FORGE_EARTH_LVL;
  else if (type === 'Air') levelReq = STONE_FORGE_AIR_LVL;
  else if (type === 'Water') levelReq = STONE_FORGE_WATER_LVL;

  if (game.stoneforging.level < levelReq) {
      await showGameAlert("Level Required", `You need Stone Forging Level ${levelReq} to craft this.`);
      return;
  }
  // +++ END NEW +++
  
  const stoneName = `${type}stone`;
  const shardName = `${type} Crystal Shard`;

  if (!canReceiveItem(stoneName)) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  
  if (game.stoneforgingActive) return;

  let totalShards = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === shardName) totalShards += slot.qty;
  }

  if (totalShards < STONE_SHARD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${STONE_SHARD_COST} ${shardName}.`);
      return;
  }
  
  game.stoneforgingActive = true;
  document.getElementById('startForgeBtn').style.display = 'none';
  document.getElementById('stopForgeBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => stoneForgingLoop(Date.now(), Date.now(), type), 16);
}

async function stoneForgingLoop(timestamp, startTime, type) {
  if (!game.stoneforgingActive) return; 
  const elapsed = Date.now() - startTime;

  const stoneName = `${type}stone`;
  const shardName = `${type} Crystal Shard`;

  if (elapsed >= STONE_CRAFT_TIME_MS) {
    let totalShards = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === shardName) totalShards += slot.qty;
    }
    if (totalShards < STONE_SHARD_COST) {
        await showGameAlert("Out of Materials", `You've run out of ${shardName}.`);
        stopStoneForging();
        return;
    }
    
    removeItem(shardName, STONE_SHARD_COST);
    addItem(stoneName, 1);
    addXP('stoneforging', STONE_CRAFT_XP);
    showItemPopup(`+${STONE_CRAFT_XP} Stone Forging XP`, 'forgeProgress', 0);
    showItemPopup(`+1 ${stoneName}`, 'forgeProgress', 450);
    
    document.getElementById('forgeProgress').style.width = '0%';
    
    const overdueTime = elapsed - STONE_CRAFT_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalShardsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === shardName) totalShardsAfter += slot.qty;
    }
    if (totalShardsAfter < STONE_SHARD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough shards to make more.");
        stopStoneForging();
        return;
    }
    
    return stoneForgingLoop(Date.now(), newStartTime, type);

  } else {
    const progress = (elapsed / STONE_CRAFT_TIME_MS) * 100;
    document.getElementById('forgeProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => stoneForgingLoop(Date.now(), startTime, type), 16);
  }
}


// =================================================================
// --- 5. NEW FISHING FUNCTIONS ---
// =================================================================

/**
 * Main function to open the Fishing Areas Hub
 */
function openFishingHub() {
  showMainScreen('hubFishingAreas');
}

/**
 * Opens the Ocean fishing area
 */
function openOceanFishingArea() {
  showMainScreen('hubOcean');
}

/**
 * Opens the River fishing area
 */
function openRiverFishingArea() {
  showMainScreen('hubRiver');
}

/**
 * Generic function to stop any fishing action
 */
function stopFishing(progressId = 'fishProgress', startBtnId = 'startFishBtn', stopBtnId = 'stopFishBtn') {
  game.fishingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// --- Herring (Ocean) UI & Logic ---
function openFishHerring(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Herring</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common ocean fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openOceanFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingHerring;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingHerring() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Herring')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fishingHerringLoop(Date.now(), Date.now()), 16);
}

async function fishingHerringLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= FISHING_TIME_MS) {
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }

    removeItem('Fishing Bait', 1);
    addItem('Herring', 1);
    addXP('fishing', HERRING_FISH_XP);
    showItemPopup(`+${HERRING_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Herring`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    const overdueTime = elapsed - FISHING_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Herring');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    
    return fishingHerringLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / FISHING_TIME_MS) * 100;
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fishingHerringLoop(Date.now(), startTime), 16);
  }
}

// --- Trout (River) UI & Logic ---
function openFishTrout(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Trout</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common river fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openRiverFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingTrout;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingTrout() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Trout')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fishingTroutLoop(Date.now(), Date.now()), 16);
}

async function fishingTroutLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= FISHING_TIME_MS) {
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }

    removeItem('Fishing Bait', 1);
    addItem('Trout', 1);
    addXP('fishing', TROUT_FISH_XP);
    showItemPopup(`+${TROUT_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Trout`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    const overdueTime = elapsed - FISHING_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Trout');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    
    return fishingTroutLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / FISHING_TIME_MS) * 100;
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fishingTroutLoop(Date.now(), startTime), 16);
  }
}

// --- Salmon (River) UI & Logic ---
function openFishSalmon(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Salmon</h2>
    <div style="margin-top:8px; color:#efe3cf;">A large, strong river fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openRiverFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingSalmon;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingSalmon() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Salmon')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fishingSalmonLoop(Date.now(), Date.now()), 16);
}

async function fishingSalmonLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= FISHING_TIME_MS) {
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }

    removeItem('Fishing Bait', 1);
    addItem('Salmon', 1);
    addXP('fishing', SALMON_FISH_XP);
    showItemPopup(`+${SALMON_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Salmon`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    const overdueTime = elapsed - FISHING_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Salmon');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    
    return fishingSalmonLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / FISHING_TIME_MS) * 100;
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fishingSalmonLoop(Date.now(), startTime), 16);
  }
}

// =================================================================
// --- END NEW FISHING FUNCTIONS ---
// =================================================================

// =================================================================
// +++ NEW: QUEST SYSTEM FUNCTIONS (ID BASED) +++
// =================================================================

function openQuestHub() {
  showMainScreen('hubQuests');
  renderQuestLinesList();
}

// Helper: Migrates old "step" data to new "ID" data on the fly
function getQuestProgress(lineId) {
    // Initialize if missing
    if (!game.questLines[lineId]) {
        game.questLines[lineId] = { completed: [], activeQuestId: null, kills: 0 };
    }

    const data = game.questLines[lineId];
    const lineConfig = QUEST_LINES[lineId];

    // --- MIGRATION LOGIC (Step -> IDs) ---
    // FIX: Only run migration if 'completed' array does NOT exist yet.
    // This prevents the game from using the old 'step' value to wipe your new progress on reload.
    if (typeof data.step === 'number' && !data.completed) {
        data.completed = [];
        
        // +++ SPECIFIC PATCH FOR 'TUTORIAL' LINE +++
        if (lineId === 'tutorial') {
            if (data.step >= 1) data.completed.push('tut_1'); // Foundation
            if (data.step >= 2) data.completed.push('tut_2'); // Chickens
            if (data.step >= 3) data.completed.push('tut_3'); // Spiders
        } 
        else {
            for (let i = 0; i < data.step; i++) {
                if (lineConfig.quests[i]) {
                    data.completed.push(lineConfig.quests[i].id);
                }
            }
        }
        
        data.activeQuestId = null; 
    }

    // Always delete the old 'step' from local memory so it doesn't cause issues during this session
    if (typeof data.step !== 'undefined') {
        delete data.step;
    }
    // --- END MIGRATION ---

    // Ensure completed is an array (if it was somehow missing)
    if (!data.completed) data.completed = [];

    // Determine the current active quest
    let firstUnfinished = null;
    for (const q of lineConfig.quests) {
        if (!data.completed.includes(q.id)) {
            firstUnfinished = q;
            break; // Stop at the first missing quest
        }
    }

    // Logic to reset kills if the active quest has changed
    if (firstUnfinished) {
        if (data.activeQuestId !== firstUnfinished.id) {
            data.activeQuestId = firstUnfinished.id;
            data.kills = 0; 
        }
    } else {
        data.activeQuestId = 'COMPLETED';
    }

    return { data, activeQuest: firstUnfinished };
}

function renderQuestLinesList() {
  const container = document.getElementById('questLinesContainer');
  container.innerHTML = '';

  for (const [lineId, lineData] of Object.entries(QUEST_LINES)) {
    const { data, activeQuest } = getQuestProgress(lineId);
    
    const isLineComplete = (data.activeQuestId === 'COMPLETED');
    const totalSteps = lineData.quests.length;
    const completedCount = data.completed.length;

    const div = document.createElement('div');
    div.className = `quest-line-card ${isLineComplete ? 'quest-line-completed' : ''}`;
    
    let statusText = "";
    let color = "#efe3cf";
    
    if (isLineComplete) {
        statusText = "All Quests Completed";
        color = "#44aa44";
    } else {
        // Check if current quest is ready
        if (checkQuestRequirements(lineId)) {
            statusText = `Active: ${activeQuest.name} <span style="color:#aaffaa; font-weight:bold;">(Ready!)</span>`;
            div.style.borderColor = "#44aa44"; 
        } else {
            statusText = `Active: ${activeQuest.name}`;
        }
    }

    div.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-size: 18px; font-weight: bold; color: var(--gold);">${lineData.name}</div>
        <div style="font-size: 14px; color: #aaa;">${completedCount} / ${totalSteps}</div>
      </div>
      <div style="margin-top: 5px; font-size: 14px; color: ${color};">${statusText}</div>
      <div style="font-size: 12px; color: #888; margin-top: 4px;">${lineData.desc}</div>
    `;
    
    div.onclick = () => openQuestLine(lineId);
    container.appendChild(div);
  }
}

function openQuestLine(lineId) {
    showMainScreen('hubQuestLine');
    const lineData = QUEST_LINES[lineId];
    const { data, activeQuest } = getQuestProgress(lineId);
    
    setText('questLineTitle', lineData.name);
    
    // --- 1. RENDER COMPLETED HISTORY ---
    const historySection = document.getElementById('completedQuestsSection');
    const historyList = document.getElementById('completedQuestsList');
    
    // Find specifically WHICH quests are done from the config list order
    // This allows inserted quests to show up correctly as "not done" even if later ones are done (rare edge case)
    // But mostly this list just shows what we have marked as complete.
    const completedQuestsInOrder = lineData.quests.filter(q => data.completed.includes(q.id));

    if (completedQuestsInOrder.length > 0) {
        historySection.style.display = 'block';
        let historyHtml = '';
        completedQuestsInOrder.forEach(q => {
            historyHtml += `
                <div class="completed-quest-row">
                    <span>${q.name}</span>
                    <span style="color:#44aa44; font-weight:bold;"></span>
                </div>
            `;
        });
        historyList.innerHTML = historyHtml;
        historyList.scrollTop = historyList.scrollHeight;
    } else {
        historySection.style.display = 'none';
    }

    const container = document.getElementById('activeQuestContainer');

    // --- 2. CHECK COMPLETION ---
    if (!activeQuest) {
        container.innerHTML = `<div style="text-align:center; color:#44aa44; font-weight:bold; font-size:18px; padding: 20px;">This quest line is complete!</div>`;
        return;
    }

    // --- 3. RENDER ACTIVE QUEST ---
    container.innerHTML = `
        <h3 id="activeQuestName" style="color: var(--gold); margin-top: 0;"></h3>
        <div id="activeQuestDesc" style="font-style: italic; color: #ccc; margin-bottom: 15px;"></div>
        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px;">
            <div style="font-weight: bold; margin-bottom: 5px;">Requirements:</div>
            <div id="activeQuestReqs"></div>
        </div>
        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 10px;">
            <div style="font-weight: bold; margin-bottom: 5px; color: #aaffaa;">Rewards:</div>
            <div id="activeQuestRewards"></div>
        </div>
        <div class="action-buttons" style="margin-top: 20px; justify-content: flex-end;">
            <button id="questCompleteBtn" class="primary" style="background: #44aa44; display: none;">Complete Quest</button>
        </div>
    `;

    const qData = activeQuest;
    setText('activeQuestName', `Current: ${qData.name}`);
    setText('activeQuestDesc', qData.desc);

    // --- REQUIREMENTS ---
    let reqHtml = '';
    if (qData.reqSkill) {
        const currentLvl = game[qData.reqSkill.skill].level;
        const reqLvl = qData.reqSkill.level;
        const met = currentLvl >= reqLvl;
        const color = met ? 'quest-req-met' : 'quest-req-not-met';
        const icon = met ? '' : '';
        reqHtml += `<div class="${color}">${icon} Level ${reqLvl} ${qData.reqSkill.skill}</div>`;
    }

    if (qData.type === 'gather') {
        qData.reqItems.forEach(req => {
            let has = 0;
            for (const slot of game.inventory) if (slot && slot.name === req.name) has += slot.qty;
            const met = has >= req.qty;
            const color = met ? 'quest-req-met' : 'quest-req-not-met';
            const icon = met ? '' : '';
            reqHtml += `<div class="${color}">${icon} ${req.qty} ${req.name}</div>`;
        });
    } else if (qData.type === 'kill') {
        const currentKills = data.kills || 0;
        const target = qData.targetCount;
        const met = currentKills >= target;
        const color = met ? 'quest-req-met' : 'quest-req-not-met';
        const icon = met ? '' : '';
        reqHtml += `<div class="${color}">${icon} Kill ${target} ${qData.targetEnemy}s (Progress: ${currentKills}/${target})</div>`;
    }
    document.getElementById('activeQuestReqs').innerHTML = reqHtml;

    // --- REWARDS ---
    let rewHtml = '';
    if (qData.rewards.gold) rewHtml += `<div style="color:var(--gold);"> ${qData.rewards.gold} Gold</div>`;
    if (qData.rewards.items) {
        qData.rewards.items.forEach(r => {
            rewHtml += `<div style="color:#fff;"> ${r.qty} ${r.name}</div>`;
        });
    }
    document.getElementById('activeQuestRewards').innerHTML = rewHtml;

    // --- BUTTONS ---
    const completeBtn = document.getElementById('questCompleteBtn');
    if (checkQuestRequirements(lineId)) {
        completeBtn.style.display = 'inline-block';
        completeBtn.onclick = () => completeQuest(lineId);
    } else {
        completeBtn.style.display = 'none';
    }
}

function checkQuestRequirements(lineId) {
    const { data, activeQuest } = getQuestProgress(lineId);
    if (!activeQuest) return false; // Line complete
    
    const qData = activeQuest;

    // Check Skill
    if (qData.reqSkill) {
        if (game[qData.reqSkill.skill].level < qData.reqSkill.level) return false;
    }

    if (qData.type === 'gather') {
        for (const req of qData.reqItems) {
            let count = 0;
            for (const slot of game.inventory) {
                if (slot && slot.name === req.name) count += slot.qty;
            }
            if (count < req.qty) return false;
        }
        return true;
    } else if (qData.type === 'kill') {
        return (data.kills || 0) >= qData.targetCount;
    }
    return false;
}

async function completeQuest(lineId) {
    if (!checkQuestRequirements(lineId)) return;
    
    const { data, activeQuest } = getQuestProgress(lineId);
    const qData = activeQuest;
    
    // 1. Deduct Gather Items
    if (qData.type === 'gather') {
        // Only remove items if 'consume' is not explicitly set to false
        if (qData.consume !== false) {
            for (const req of qData.reqItems) {
                removeItem(req.name, req.qty);
            }
        }
    }
    
    // 2. Give Rewards
    if (qData.rewards.gold) addGold(qData.rewards.gold);
    if (qData.rewards.items) {
        qData.rewards.items.forEach(r => addItem(r.name, r.qty));
    }
    
    // 3. Mark Complete (Push ID to array)
    data.completed.push(qData.id);
    data.kills = 0; // Reset kills for next quest
    data.activeQuestId = null; // Force recalculation
    
    playGlobalSound('sounds/soundeffects/levelupsound.mp3'); 
    await showGameAlert("Quest Complete!", `You completed: ${qData.name}`);
    
    if (typeof window.savePlayerData === 'function') window.savePlayerData();
    
    // Refresh view
    openQuestLine(lineId);
}

function updateQuestKillCount(enemyName) {
    let updated = false;
    
    for (const [lineId, lineData] of Object.entries(QUEST_LINES)) {
        const { data, activeQuest } = getQuestProgress(lineId);
        
        if (!activeQuest) continue;
        
        // Is this a kill quest for this enemy?
        if (activeQuest.type === 'kill' && activeQuest.targetEnemy === enemyName) {
            if (data.kills < activeQuest.targetCount) {
                data.kills++;
                updated = true;
            }
        }
    }
    
    if (updated && typeof window.savePlayerData === 'function') window.savePlayerData();
}


// --- Unstrung Softwood Bow UI & Logic ---
function openFletchUnstrungSoftwoodBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unstrung Softwood Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood. Yields ${UNSTRUNG_SOFTWOOD_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnstrungSoftwoodBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnstrungSoftwoodBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unstrung Softwood Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalWood < UNSTRUNG_SOFTWOOD_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingUnstrungSoftwoodBowLoop(Date.now(), Date.now()), 16);
}

async function fletchingUnstrungSoftwoodBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= UNSTRUNG_SOFTWOOD_TIME_MS) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalWood < UNSTRUNG_SOFTWOOD_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Softwood.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Softwood', UNSTRUNG_SOFTWOOD_WOOD_COST);
    addItem('Unstrung Softwood Bow', UNSTRUNG_SOFTWOOD_YIELD);
    addXP('fletching', UNSTRUNG_SOFTWOOD_XP);
    showItemPopup(`+${UNSTRUNG_SOFTWOOD_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNSTRUNG_SOFTWOOD_YIELD} Unstrung Softwood Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - UNSTRUNG_SOFTWOOD_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < UNSTRUNG_SOFTWOOD_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Softwood to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingUnstrungSoftwoodBowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / UNSTRUNG_SOFTWOOD_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingUnstrungSoftwoodBowLoop(Date.now(), startTime), 16);
  }
}

// --- Softwood Bow UI & Logic ---
function openFletchSoftwoodBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Softwood Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow, ${SOFTWOOD_BOW_STRING_COST} Bow String. Yields ${SOFTWOOD_BOW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingSoftwoodBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingSoftwoodBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Softwood Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnstrung = 0;
  let totalStrings = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrung += slot.qty;
      if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
  }

  if (totalUnstrung < SOFTWOOD_BOW_UNSTRUNG_COST || totalStrings < SOFTWOOD_BOW_STRING_COST) {
      await showGameAlert("Not Enough Materials", `You need ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow and ${SOFTWOOD_BOW_STRING_COST} Bow String.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingSoftwoodBowLoop(Date.now(), Date.now()), 16);
}

async function fletchingSoftwoodBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= SOFTWOOD_BOW_TIME_MS) {
    let totalUnstrung = 0;
    let totalStrings = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrung += slot.qty;
        if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
    }
    if (totalUnstrung < SOFTWOOD_BOW_UNSTRUNG_COST || totalStrings < SOFTWOOD_BOW_STRING_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unstrung Softwood Bow', SOFTWOOD_BOW_UNSTRUNG_COST);
    removeItem('Bow String', SOFTWOOD_BOW_STRING_COST);
    addItem('Softwood Bow', SOFTWOOD_BOW_YIELD);
    addXP('fletching', SOFTWOOD_BOW_XP);
    showItemPopup(`+${SOFTWOOD_BOW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${SOFTWOOD_BOW_YIELD} Softwood Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - SOFTWOOD_BOW_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalUnstrungAfter = 0;
    let totalStringsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrungAfter += slot.qty;
        if (slot && slot.name === 'Bow String') totalStringsAfter += slot.qty;
    }
    if (totalUnstrungAfter < SOFTWOOD_BOW_UNSTRUNG_COST || totalStringsAfter < SOFTWOOD_BOW_STRING_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingSoftwoodBowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / SOFTWOOD_BOW_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingSoftwoodBowLoop(Date.now(), startTime), 16);
  }
}

// --- Unstrung Oak Bow UI & Logic ---
function openFletchUnstrungOakBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unstrung Oak Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNSTRUNG_OAK_WOOD_COST} Oak. Yields ${UNSTRUNG_OAK_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnstrungOakBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnstrungOakBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unstrung Oak Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalWood < UNSTRUNG_OAK_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${UNSTRUNG_OAK_WOOD_COST} Oak.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingUnstrungOakBowLoop(Date.now(), Date.now()), 16);
}

async function fletchingUnstrungOakBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= UNSTRUNG_OAK_TIME_MS) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalWood < UNSTRUNG_OAK_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Oak.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Oak', UNSTRUNG_OAK_WOOD_COST);
    addItem('Unstrung Oak Bow', UNSTRUNG_OAK_YIELD);
    addXP('fletching', UNSTRUNG_OAK_XP);
    showItemPopup(`+${UNSTRUNG_OAK_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNSTRUNG_OAK_YIELD} Unstrung Oak Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - UNSTRUNG_OAK_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < UNSTRUNG_OAK_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Oak to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingUnstrungOakBowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / UNSTRUNG_OAK_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingUnstrungOakBowLoop(Date.now(), startTime), 16);
  }
}

// --- Oak Bow UI & Logic ---
function openFletchOakBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Oak Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow, ${OAK_BOW_STRING_COST} Bow String. Yields ${OAK_BOW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingOakBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingOakBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Oak Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnstrung = 0;
  let totalStrings = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrung += slot.qty;
      if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
  }

  if (totalUnstrung < OAK_BOW_UNSTRUNG_COST || totalStrings < OAK_BOW_STRING_COST) {
      await showGameAlert("Not Enough Materials", `You need ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow and ${OAK_BOW_STRING_COST} Bow String.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = setTimeout(() => fletchingOakBowLoop(Date.now(), Date.now()), 16);
}

async function fletchingOakBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= OAK_BOW_TIME_MS) {
    let totalUnstrung = 0;
    let totalStrings = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrung += slot.qty;
        if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
    }
    if (totalUnstrung < OAK_BOW_UNSTRUNG_COST || totalStrings < OAK_BOW_STRING_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unstrung Oak Bow', OAK_BOW_UNSTRUNG_COST);
    removeItem('Bow String', OAK_BOW_STRING_COST);
    addItem('Oak Bow', OAK_BOW_YIELD);
    addXP('fletching', OAK_BOW_XP);
    showItemPopup(`+${OAK_BOW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${OAK_BOW_YIELD} Oak Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    const overdueTime = elapsed - OAK_BOW_TIME_MS;
    const newStartTime = Date.now() - overdueTime;
    
    let totalUnstrungAfter = 0;
    let totalStringsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrungAfter += slot.qty;
        if (slot && slot.name === 'Bow String') totalStringsAfter += slot.qty;
    }
    if (totalUnstrungAfter < OAK_BOW_UNSTRUNG_COST || totalStringsAfter < OAK_BOW_STRING_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    return fletchingOakBowLoop(Date.now(), newStartTime);

  } else {
    const progress = (elapsed / OAK_BOW_TIME_MS) * 100;
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = setTimeout(() => fletchingOakBowLoop(Date.now(), startTime), 16);
  }
}


function renderSmithingItems(metalType) {
  const container = document.getElementById('smithingItemsContainer');
  if (!container) return;
  
  const smithLvl = game.blacksmith.level;
  
  // --- Helper function for locked buttons (moved inside) ---
  const setupSmithButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => { // Added itemName
    const btn = document.getElementById(btnId);
    if (btn) {
      // Create the new tooltip header
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      
      if (locked) {
        btn.onclick = null;
        // Add name to the locked tooltip
        // FIX: Added red color to requirement
        const lockedTT = nameHtml + `<div style="color:#ff8888;">Requires Blacksmith Lvl: ${levelReq}</div>`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        // Add name to the unlocked tooltip
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  if (metalType === 'copper') {
    // --- Copper Level Locks ---
    const copperBarLocked = smithLvl < COPPER_BAR_LVL;
    const copperPickaxeLocked = smithLvl < COPPER_PICKAXE_LVL; // +++ NEW +++
    const copperAxeLocked = smithLvl < COPPER_AXE_LVL;       // +++ NEW +++
    const copperSwordLocked = smithLvl < COPPER_SWORD_LVL;
    const copperBootsLocked = smithLvl < COPPER_BOOTS_LVL;
    const copperHelmetLocked = smithLvl < COPPER_HELMET_LVL;
    const copperPlatelegsLocked = smithLvl < COPPER_PLATELEGS_LVL; // +++ NEW +++
    const copperChestLocked = smithLvl < COPPER_CHEST_LVL;
    const copperTipsLocked = smithLvl < BLACKSMITH_COPPER_TIPS_LVL; // +++ NEW +++
    
    container.innerHTML = `
      <button id="copperBarBtn" class="primary ${copperBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperbar.png" alt="Copper Bar" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperPickaxeBtn" class="primary ${copperPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperpickaxe.png" alt="Copper Pickaxe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperAxeBtn" class="primary ${copperAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperaxe.png" alt="Copper Axe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperShortswordBtn" class="primary ${copperSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/coppershortsword.png" alt="Copper Shortsword" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperBootsBtn" class="primary ${copperBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperboots.png" alt="Copper Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperHelmetBtn" class="primary ${copperHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperhelmet.png" alt="Copper Helmet" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperPlatelegsBtn" class="primary ${copperPlatelegsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperplatelegs.png" alt="Copper Platelegs" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperChestplateBtn" class="primary ${copperChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperchestplate.png" alt="Copper Chestplate" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperArrowTipBtn" class="primary ${copperTipsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperarrowtip.png" alt="Copper Arrow Tip" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for copper items ---
    setupSmithButton('copperBarBtn', copperBarLocked, openCopperBarSmith, COPPER_BAR_LVL, 'Requires: 2 Copper Ore', 'Copper Bar');
    setupSmithButton('copperPickaxeBtn', copperPickaxeLocked, openCopperPickaxeSmith, COPPER_PICKAXE_LVL, `Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood`, 'Copper Pickaxe');
    setupSmithButton('copperAxeBtn', copperAxeLocked, openCopperAxeSmith, COPPER_AXE_LVL, `Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood`, 'Copper Axe');
    setupSmithButton('copperShortswordBtn', copperSwordLocked, openCopperShortswordSmith, COPPER_SWORD_LVL, `Requires: ${SHORTSWORD_BAR_COST} Copper Bars`, 'Copper Shortsword');
    setupSmithButton('copperBootsBtn', copperBootsLocked, openCopperBootsSmith, COPPER_BOOTS_LVL, `Requires: ${BOOTS_BAR_COST} Copper Bars`, 'Copper Boots');
    setupSmithButton('copperHelmetBtn', copperHelmetLocked, openCopperHelmetSmith, COPPER_HELMET_LVL, `Requires: ${HELMET_BAR_COST} Copper Bars`, 'Copper Helmet');
    setupSmithButton('copperPlatelegsBtn', copperPlatelegsLocked, openCopperPlatelegsSmith, COPPER_PLATELEGS_LVL, `Requires: ${COPPER_PLATELEGS_BAR_COST} Copper Bars`, 'Copper Platelegs'); // +++ NEW +++
    setupSmithButton('copperChestplateBtn', copperChestLocked, openCopperChestplateSmith, COPPER_CHEST_LVL, `Requires: ${CHESTPLATE_BAR_COST} Copper Bars`, 'Copper Chestplate');
    setupSmithButton('copperArrowTipBtn', copperTipsLocked, openSmithCopperArrowTip, BLACKSMITH_COPPER_TIPS_LVL, `Requires: ${COPPER_ARROW_TIP_BAR_COST} Copper Bars`, `Copper Arrow Tip x${COPPER_ARROW_TIP_YIELD}`); // +++ NEW +++
    
  } else if (metalType === 'iron') {
    // --- Iron Level Locks ---
    const ironBarLocked = smithLvl < IRON_BAR_LVL;
    const ironPickaxeLocked = smithLvl < IRON_PICKAXE_LVL; // +++ NEW +++
    const ironAxeLocked = smithLvl < IRON_AXE_LVL;       // +++ NEW +++
    const ironSwordLocked = smithLvl < IRON_SWORD_LVL;
    const ironBootsLocked = smithLvl < IRON_BOOTS_LVL;
    const ironHelmetLocked = smithLvl < IRON_HELMET_LVL;
    const ironPlatelegsLocked = smithLvl < IRON_PLATELEGS_LVL; // +++ NEW +++
    const ironChestLocked = smithLvl < IRON_CHEST_LVL;
    
    container.innerHTML = `
      <button id="ironBarBtn" class="primary ${ironBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironbar.png" alt="Iron Bar" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironPickaxeBtn" class="primary ${ironPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironpickaxe.png" alt="Iron Pickaxe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironAxeBtn" class="primary ${ironAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironaxe.png" alt="Iron Axe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironShortswordBtn" class="primary ${ironSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironshortsword.png" alt="Iron Shortsword" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironBootsBtn" class="primary ${ironBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironboots.png" alt="Iron Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironHelmetBtn" class="primary ${ironHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironhelmet.png" alt="Iron Helmet" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironPlatelegsBtn" class="primary ${ironPlatelegsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironplatelegs.png" alt="Iron Platelegs" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironChestplateBtn" class="primary ${ironChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironchestplate.png" alt="Iron Chestplate" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for iron items ---
    setupSmithButton('ironBarBtn', ironBarLocked, openIronBarSmith, IRON_BAR_LVL, `Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore`, 'Iron Bar');
    setupSmithButton('ironPickaxeBtn', ironPickaxeLocked, openIronPickaxeSmith, IRON_PICKAXE_LVL, `Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak`, 'Iron Pickaxe');
    setupSmithButton('ironAxeBtn', ironAxeLocked, openIronAxeSmith, IRON_AXE_LVL, `Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak`, 'Iron Axe');
    setupSmithButton('ironShortswordBtn', ironSwordLocked, openIronShortswordSmith, IRON_SWORD_LVL, `Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars`, 'Iron Shortsword');
    setupSmithButton('ironBootsBtn', ironBootsLocked, openIronBootsSmith, IRON_BOOTS_LVL, `Requires: ${IRON_BOOTS_BAR_COST} Iron Bars`, 'Iron Boots');
    setupSmithButton('ironHelmetBtn', ironHelmetLocked, openIronHelmetSmith, IRON_HELMET_LVL, `Requires: ${IRON_HELMET_BAR_COST} Iron Bars`, 'Iron Helmet');
    setupSmithButton('ironPlatelegsBtn', ironPlatelegsLocked, openIronPlatelegsSmith, IRON_PLATELEGS_LVL, `Requires: ${IRON_PLATELEGS_BAR_COST} Iron Bars`, 'Iron Platelegs'); // +++ NEW +++
    setupSmithButton('ironChestplateBtn', ironChestLocked, openIronChestplateSmith, IRON_CHEST_LVL, `Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars`, 'Iron Chestplate');
  }
}

// --- NEW: Coal Mine UI ---

function openCopperMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Copper Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}




function openCoalMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Coal Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A dark, crumbly coal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCoalMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Sand Mine UI ---
function openSandMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Mine - Sand</h2>
    <div style="margin-top:8px; color:#efe3cf;">A pile of coarse sand.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startSandMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic');
}

async function startSandMining() {
  // Tool Check (Any pickaxe)
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 1) {
    await showGameAlert("Tool Required", "You need at least a Bronze Pickaxe.");
    return;
  }
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "Session not active.");
    return;
  }
  if (!canReceiveItem(SAND_MINE_ITEM)) {
    await showGameAlert("Inventory Full", "Inventory full.");
    return;
  }

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => sandMiningLoop(Date.now(), Date.now()), 16);
}

function sandMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= SAND_MINE_TIME_MS) {
    addItem(SAND_MINE_ITEM, 1);
    addXP('mining', SAND_MINE_XP);
    showItemPopup(`+${SAND_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${SAND_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - SAND_MINE_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;
    
    return miningCooldownLoop(Date.now(), newCooldownStartTime, MINE_COOLDOWN_SAND_MS, 'mineProgressText', sandMiningLoop);
    
  } else {
    const progress = (elapsed / SAND_MINE_TIME_MS) * 100;
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => sandMiningLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Coal Mine Logic ---
async function startCoalMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++
  
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(COAL_MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => coalMiningLoop(Date.now(), Date.now()), 16);
}

function coalMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= COAL_MINE_TIME_MS) {
    addItem(COAL_MINE_ITEM, 1);
    addXP('mining', COAL_MINE_XP);
    showItemPopup(`+${COAL_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${COAL_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - COAL_MINE_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;
    
    // --- THIS IS THE FIX: Immediately call the cooldown loop ---
    return miningCooldownLoop(Date.now(), newCooldownStartTime, MINE_COOLDOWN_COAL_MS, 'mineProgressText', coalMiningLoop);
    
  } else {
    const progress = (elapsed / COAL_MINE_TIME_MS) * 100;
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => coalMiningLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Iron Mine UI ---
function openIronMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Iron Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A sturdy iron vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startIronMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Mine Logic ---
async function startIronMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(IRON_MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => ironMiningLoop(Date.now(), Date.now()), 16);
}

function ironMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= IRON_MINE_TIME_MS) {
    addItem(IRON_MINE_ITEM, 1);
    addXP('mining', IRON_MINE_XP);
    showItemPopup(`+${IRON_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${IRON_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - IRON_MINE_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;

    // --- THIS IS THE FIX: Immediately call the cooldown loop ---
    return miningCooldownLoop(Date.now(), newCooldownStartTime, MINE_COOLDOWN_IRON_MS, 'mineProgressText', ironMiningLoop);
    
  } else {
    const progress = (elapsed / IRON_MINE_TIME_MS) * 100;
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => ironMiningLoop(Date.now(), startTime), 16);
  }
}

function openMineHub() {
  showMainScreen('hubMine');
}

function openCrystalMineHub() {
  showMainScreen('hubCrystalMine');
}

function openEarthCrystalMine() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Mine - Earth Crystal</h2>
    <div style="margin-top:8px; color:#efe3cf;">A glowing earth crystal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openCrystalMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCrystalMining('Earth');
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic');
}

function openAirCrystalMine() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Mine - Air Crystal</h2>
    <div style="margin-top:8px; color:#efe3cf;">A shimmering air crystal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openCrystalMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCrystalMining('Air');
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic');
}

function openWaterCrystalMine() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Mine - Water Crystal</h2>
    <div style="margin-top:8px; color:#efe3cf;">A deep blue water crystal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openCrystalMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCrystalMining('Water');
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic');
}

async function startCrystalMining(type) {
  // Tool Check: Tier 3 (Iron) required
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 3) { 
    await showGameAlert("Tool Required", "You need at least an Iron Pickaxe in your inventory to mine crystal veins.");
    return;
  }

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }

  let item, timeMs, levelReq;
  if (type === 'Earth') { item = EARTH_CRYSTAL_ITEM; timeMs = EARTH_CRYSTAL_TIME_MS; levelReq = EARTH_CRYSTAL_LVL; }
  else if (type === 'Air') { item = AIR_CRYSTAL_ITEM; timeMs = AIR_CRYSTAL_TIME_MS; levelReq = AIR_CRYSTAL_LVL; }
  else if (type === 'Water') { item = WATER_CRYSTAL_ITEM; timeMs = WATER_CRYSTAL_TIME_MS; levelReq = WATER_CRYSTAL_LVL; }

  // --- FIX: Check Level Requirement ---
  if (game.mining.level < levelReq) {
      await showGameAlert("Level Required", `You need Mining Level ${levelReq} to mine ${type} Crystals.`);
      return;
  }
  // --- END FIX ---

  if (!canReceiveItem(item)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  
  // We pass the Type to the loop
  game.progressFrame = setTimeout(() => crystalMiningLoop(Date.now(), Date.now(), type), 16);
}

function crystalMiningLoop(timestamp, startTime, type) {
  if (!game.miningActive) return; 
  const elapsed = Date.now() - startTime;

  let item, timeMs, xp;
  if (type === 'Earth') { item = EARTH_CRYSTAL_ITEM; timeMs = EARTH_CRYSTAL_TIME_MS; xp = EARTH_CRYSTAL_XP; }
  else if (type === 'Air') { item = AIR_CRYSTAL_ITEM; timeMs = AIR_CRYSTAL_TIME_MS; xp = AIR_CRYSTAL_XP; }
  else if (type === 'Water') { item = WATER_CRYSTAL_ITEM; timeMs = WATER_CRYSTAL_TIME_MS; xp = WATER_CRYSTAL_XP; }

  if (elapsed >= timeMs) {
    addItem(item, 1);
    addXP('mining', xp);
    showItemPopup(`+${xp} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${item}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - timeMs;
    const newCooldownStartTime = Date.now() - overdueTime;

    // Re-use existing mining cooldown loop
    // We need to wrap the next call to pass the 'type' argument
    return miningCooldownLoop(Date.now(), newCooldownStartTime, 1500, 'mineProgressText', (ts, st) => crystalMiningLoop(ts, st, type));
    
  } else {
    const progress = (elapsed / timeMs) * 100;
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => crystalMiningLoop(Date.now(), startTime, type), 16);
  }
}

// --- NEW: Woodcutting Hub UI ---
function openForestHub() {
  showMainScreen('hubForest');
}

// --- NEW: Softwood Tree UI ---
function openSoftwoodTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Softwood Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common, pliable tree.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingSoftwood;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Oak Tree UI ---
function openOakTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Oak Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A strong, sturdy oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingOak;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Stop Woodcutting Logic ---
function stopWoodcutting(){
  game.woodcuttingActive = false;
  if(game.progressFrame) clearTimeout(game.progressFrame);
  
  const textEl = document.getElementById('woodcutProgressText');
  if (textEl) textEl.innerText = '';

  const bar = document.getElementById('woodcutProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startChopBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopChopBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// --- NEW: Woodcutting Cooldown Loop ---
function woodcuttingCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.woodcuttingActive) {
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = Date.now() - startTime; // Use Date.now() for real time
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    // --- COOLDOWN IS COMPLETE ---
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    
    const overdueTime = -remainingMs;
    const newActionStartTime = Date.now() - overdueTime;
            
    // --- THIS IS THE FIX: Immediately call the next loop ---
    return nextLoopFunction(Date.now(), newActionStartTime);
    
  } else {
    // --- COOLDOWN IN PROGRESS ---
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    game.progressFrame = setTimeout(() => 
      woodcuttingCooldownLoop(Date.now(), startTime, duration, progressTextId, nextLoopFunction)
    , 16);
  }
}

// --- NEW: Softwood Logic ---
async function startChoppingSoftwood() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(SOFTWOOD_CHOP_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to chop this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => softwoodChoppingLoop(Date.now(), Date.now()), 16);
}

function softwoodChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= SOFTWOOD_CHOP_TIME_MS) {
    addItem(SOFTWOOD_CHOP_ITEM, 1);
    addXP('woodcutting', SOFTWOOD_CHOP_XP);
    showItemPopup(`+${SOFTWOOD_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${SOFTWOOD_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - SOFTWOOD_CHOP_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;
    
    // --- THIS IS THE FIX: Immediately call the cooldown loop ---
    return woodcuttingCooldownLoop(Date.now(), newCooldownStartTime, CHOP_COOLDOWN_SOFTWOOD_MS, 'woodcutProgressText', softwoodChoppingLoop);

  } else {
    const progress = (elapsed / SOFTWOOD_CHOP_TIME_MS) * 100;
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => softwoodChoppingLoop(Date.now(), startTime), 16);
  }
}

// --- NEW: Oak Logic ---
async function startChoppingOak() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(OAK_CHOP_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to chop this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = setTimeout(() => oakChoppingLoop(Date.now(), Date.now()), 16);
}

function oakChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = Date.now() - startTime;

  if (elapsed >= OAK_CHOP_TIME_MS) {
    addItem(OAK_CHOP_ITEM, 1);
    addXP('woodcutting', OAK_CHOP_XP);
    showItemPopup(`+${OAK_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${OAK_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    const overdueTime = elapsed - OAK_CHOP_TIME_MS;
    const newCooldownStartTime = Date.now() - overdueTime;

    // --- THIS IS THE FIX: Immediately call the cooldown loop ---
    return woodcuttingCooldownLoop(Date.now(), newCooldownStartTime, CHOP_COOLDOWN_OAK_MS, 'woodcutProgressText', oakChoppingLoop);

  } else {
    const progress = (elapsed / OAK_CHOP_TIME_MS) * 100;
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = setTimeout(() => oakChoppingLoop(Date.now(), startTime), 16);
  }
}

function openCombatHub() {
  showMainScreen('hubCombat');
  // Preload the assets for the *next* screen
  // (We can't use preloadImages anymore, but this asset is already in the master list)
}

function openFarmCombatArea() {
  game.lastCombatAreaHub = 'hubFarm'; // +++ SET LAST HUB +++
  showMainScreen('hubFarm');
}

// +++ NEW CAVE HUB FUNCTION +++
function openCaveCombatArea() {
  game.lastCombatAreaHub = 'hubCave'; // +++ SET LAST HUB +++
  showMainScreen('hubCave');
}

// NEW: Function to build and open the main combat UI
function openCombatInterface(enemyName) {
  // Stop any skilling
  if (game.miningActive) {
    stopMining();
    game.wasMiningBeforeCombat = true;
  }
  if (game.blacksmithingActive) {
    stopBlacksmithing();
    game.wasSmithingBeforeCombat = true;
  }
  if (game.woodcuttingActive) { // +++ NEW +++
    stopWoodcutting();
    game.wasWoodcuttingBeforeCombat = true;
  }
  if (game.fletchingActive) { // +++ NEW +++
    stopFletching();
    game.wasFletchingBeforeCombat = true;
  }
  if (game.craftingActive) { // +++ NEW +++
    stopCraftingBowString();
    game.wasCraftingBeforeCombat = true;
  }
  
  // +++ NEW FISHING CHECK +++
  if (game.fishingActive) {
    stopFishing();
    game.wasFishingBeforeCombat = true;
  }
  
  // Define our enemy
  if (enemyName === 'Chicken') {
    game.currentEnemy = {
      name: 'Chicken',
      level: 1,
      maxHp: 10,
      currentHp: 10,
      attack: 1, // Low attack level
      strength: 1, // Max hit is 1
      defence: 1, // Low defence
      img: 'images/chickenanim.gif'
    };
  } else if (enemyName === 'Rat') {
    game.currentEnemy = {
      name: 'Rat',
      level: 1,
      maxHp: 10,
      currentHp: 10,
      attack: 1, 
      strength: 1, // Max hit is 1
      defence: 1, 
      img: 'images/ratanim.webp'
    };
  } else if (enemyName === 'Spider') { 
    game.currentEnemy = {
      name: 'Spider',
      level: 2,
      maxHp: 12,
      currentHp: 12,
      attack: 2, 
      strength: 2, // Max hit is 2
      defence: 2, 
      img: 'images/spideranim.gif'
    };
  } else if (enemyName === 'Centipede') {
    game.currentEnemy = {
      name: 'Centipede',
      level: 5,
      maxHp: 20,
      currentHp: 20,
      attack: 5, 
      strength: 5, // Max hit is 5
      defence: 5, 
      img: 'images/centipedeanim.webp'
    };

} else if (enemyName === 'Cow') {
    game.currentEnemy = {
      name: 'Cow',
      level: 2,
      maxHp: 12,
      currentHp: 12,
      attack: 2, 
      strength: 2, // Max hit is 2
      defence: 2, 
      img: 'images/cowanim.webp'
    };

  } else {
    console.error('Unknown enemy:', enemyName);
    return;
  }
  
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  
  // --- This is the new UI layout you described ---
  wrapper.innerHTML = `
    <div id="combat-main-container">
    
      <div id="combat-enemy-area">
        <img id="combat-enemy-img" src="${game.currentEnemy.img}" alt="${game.currentEnemy.name}">
        <div id="combat-enemy-hp-bar">
          <div id="combat-enemy-hp-fill" style="width:100%"></div>
          <div id="combat-enemy-hp-text">10 / 10 HP</div>
        </div>
      </div>
      
      <div id="combat-player-area">
        
        <div id="combat-action-panel">
          <p style="margin: 0 0 10px 0; font-weight: bold;">Combat Style:</p>
          <div id="combat-styles">
            <button id="style-attack" class="primary" onclick="setAttackStyle('attack')">Accurate</button>
            <button id="style-strength" class="primary" onclick="setAttackStyle('strength')">Aggressive</button>
            <button id="style-defence" class="primary" onclick="setAttackStyle('defence')">Defensive</button>
          </div>
          
          
          <div id="combat-main-actions">
            <button id="combat-fight-btn" class="primary" style="background:#900;" onclick="beginCombat()">Fight</button>
            <button id="combat-run-btn" class="primary" style="background:#080; display:none;" onclick="runFromCombat()">Run</button>
            <button id="combat-return-btn" class="primary" style="background:#555;" onclick="returnToCombatArea()">Return</button>
          </div>
          
        </div>
      </div>
    </div>
  `;
  
  // --- THIS IS THE FIX ---
  updateEnemyCombatUI(); // <-- THIS IS THE NEW LINE
  renderEquipment();
  // --- END FIX ---

  // Set the default active style button
  setAttackStyle(game.playerAttackStyle, true); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
function setAttackStyle(style, isInitialization = false) {
  game.playerAttackStyle = style;
  
  // Update button visual state
  const styles = ['attack', 'strength', 'defence'];
  styles.forEach(s => {
    const btn = document.getElementById(`style-${s}`);
    if (btn) {
      if (s === style) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    }
  });
  
  // --- THIS IS THE FIX ---
  // Re-render equipment to update stats (like style bonuses)
  // This will also update the combat UI equipment panel if it's open
  renderEquipment(); 
  // --- END FIX ---

  if (!isInitialization) {
    // Line deleted
  }
}




// NEW: Function to start the combat loops
function beginCombat() {
  if (game.inCombat) return; 
  if (!game.isSessionActive) {
    showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // --- NEW ARROW CHECK ---
  const weapon = game.equipment.weapon;
  const isRanged = (weapon && weapon.name.endsWith('Bow'));
  
  if (isRanged) {
      const arrows = game.equipment.arrows;
      if (!arrows || arrows.qty < 1) {
          showWarningPopup("You don't have any arrows equipped.");
          return; // Stop the fight from starting
      }
  }

  
  game.inCombat = true;
  document.getElementById('combat-fight-btn').style.display = 'none'; 
  document.getElementById('combat-run-btn').style.display = 'block'; 
  document.getElementById('combat-run-btn').disabled = false;
  
  // --- NEW: Calculate stats and set dynamic attack speed ---
  const stats = getPlayerCombatStats();
  
  // Player attacks at their calculated attack speed (Using new Loop)
  game.playerCombatInterval = setTimeout(playerCombatLoop, stats.attackSpeed);
  
  // Enemy (Chicken) attacks every 3.0 seconds
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
}

// NEW: Function to restart ONLY the player's attack interval
function restartPlayerAttackInterval() {
  if (!game.inCombat || !game.currentEnemy) return; 
  
  // 1. Clear pending timeout
  if (game.playerCombatInterval) clearTimeout(game.playerCombatInterval);
  
  // 2. Get new stats
  const stats = getPlayerCombatStats();
  
  // 3. Start the new loop immediately
  game.playerCombatInterval = setTimeout(playerCombatLoop, stats.attackSpeed);
  
  // 4. Re-enable the run button
  const runBtn = document.getElementById('combat-run-btn');
  if (runBtn) runBtn.disabled = false;
}

// NEW: Function to restart combat intervals without resetting the fight
function restartCombatIntervals() {
  if (!game.inCombat || !game.currentEnemy) return; // Should already be in combat
  
  // 1. Clear existing intervals
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  
  // 2. Get new stats
  const stats = getPlayerCombatStats();
  
  // 3. Restart intervals
  game.playerCombatInterval = setInterval(playerAttackTurn, stats.attackSpeed);
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
  
  // 4. Re-enable the run button
  const runBtn = document.getElementById('combat-run-btn');
  if (runBtn) runBtn.disabled = false;
}

// NEW: Function to stop combat
function runFromCombat(playerDied = false) {
  if (!game.inCombat) return; // Can't run if not in a fight
  
  game.inCombat = false;
  
  // Stop the attack loops
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  game.playerCombatInterval = null;
  game.enemyCombatInterval = null;

  const fightBtn = document.getElementById('combat-fight-btn');
  const runBtn = document.getElementById('combat-run-btn');
  const returnBtn = document.getElementById('combat-return-btn');
  
  if (playerDied) {
    // Player is dead, disable all actions
    if (fightBtn) fightBtn.disabled = true;
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'none';
  } else {
    // Player clicked "Run"
    if (fightBtn) fightBtn.style.display = 'block'; // SHOW Fight
    if (fightBtn) fightBtn.disabled = false;
    if (runBtn) runBtn.style.display = 'none'; // HIDE Run
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'block'; // Show return

    // Reset enemy HP
    if (game.currentEnemy) {
        game.currentEnemy.currentHp = game.currentEnemy.maxHp;
        updateEnemyCombatUI();
    }
  }
}

function returnToCombatArea() { // +++ RENAMED FUNCTION +++
  // +++ NEW FIX: Stop combat loops +++
  if (game.inCombat) {
    game.inCombat = false;
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
    game.playerCombatInterval = null;
    game.enemyCombatInterval = null;
  }
  // +++ END FIX +++

  // 1. Go back to the correct combat hub screen
  showMainScreen(game.lastCombatAreaHub); 
  
  // 2. Check if we need to resume skilling
  if (game.wasMiningBeforeCombat) {
    openCopperMine(); // Re-opens the mine UI
    startMining();      // Restarts mining
  } else if (game.wasSmithingBeforeCombat) {
    // This is more complex, might need to know *which* item
    openBlacksmithHub(); // Just return to hub for now
  } else if (game.wasWoodcuttingBeforeCombat) { // +++ NEW +++
    openForestHub(); // Return to Forest hub
  } else if (game.wasFletchingBeforeCombat) { // +++ NEW +++
    openFletchingHub(); // Return to Fletching hub
  } else if (game.wasCraftingBeforeCombat) { // +++ NEW +++
    openCraftingHub(); // Return to Crafting hub
  } else if (game.wasFishingBeforeCombat) { 
    openFishingHub(); // Return to Fishing hub
  } else if (game.wasStoneForgingBeforeCombat) { // +++ NEW +++
    openElementalForgeHub(); // Return to Elemental Forge
  }
  game.wasMiningBeforeCombat = false;
  game.wasSmithingBeforeCombat = false;
  game.wasWoodcuttingBeforeCombat = false; 
  game.wasFletchingBeforeCombat = false; 
  game.wasCraftingBeforeCombat = false; 
  game.wasFishingBeforeCombat = false; 
  game.wasStoneForgingBeforeCombat = false; // +++ NEW +++
}

// NEW: Helper function to update the enemy's HP bar
function updateEnemyCombatUI() {
  if (!game.currentEnemy) return;
  
  const enemy = game.currentEnemy;
  const percent = Math.max(0, (enemy.currentHp / enemy.maxHp) * 100);
  
  const fill = document.getElementById('combat-enemy-hp-fill');
  const text = document.getElementById('combat-enemy-hp-text');
  
  if (fill) fill.style.width = percent + '%';
  if (text) text.textContent = `${enemy.currentHp} / ${enemy.maxHp} HP`;
}

function showDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'flex';
}

/**
 * Hides the death overlay.
 */
function hideDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'none';
}

/**
 * Handles all logic when a player's HP reaches 0.
 */
function handlePlayerDeath() {
  // 1. Wipe inventory
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  renderInventoryGrid();
  
  // 2. Wipe gold
  game.gold = 0;
  updateGoldUI();
  
  // 3. Save the empty state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 4. Show the death modal
  showDeathOverlay();
}

/**
 * Handles the "Revive" button click.
 */
function revivePlayer() {
  // 1. Hide the modal
  hideDeathOverlay();
  
  // 2. Restore HP
  game.hp = game.maxHP;
  updateHPUI();
  
  // 3. Go back to the main hub
  backToActions();
  
  // 4. Save the new HP state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}
// --- END: Death & Revive Functions ---


function showDamageSplat(target, amount, type) {
  let anchorElement = null;
  if (target === 'player') {
    // This finds the player's main hp-bar
    anchorElement = document.getElementById('hpFill').parentElement; 
  } else if (target === 'enemy') {
    anchorElement = document.getElementById('combat-enemy-hp-bar');
  }

  if (!anchorElement) return;

  const splat = document.createElement('div');
  splat.className = 'combat-splat';
  
  if (type === 'damage') {
    splat.classList.add('splat-damage');
    splat.textContent = amount;
  } else { // 'block'
    splat.classList.add('splat-block');
    splat.textContent = '0';
  }
  
  // Randomize horizontal position slightly
  splat.style.right = (Math.floor(Math.random() * 20) - 40) + 'px';
  
  anchorElement.appendChild(splat);
  setTimeout(() => splat.remove(), 850); // Remove just before animation ends
}

/**
 * NEW: Recursive combat loop.
 * Allows gear switching without resetting the current cooldown.
 */
function playerCombatLoop() {
  if (!game.inCombat) return;
  
  // 1. Execute the attack
  playerAttackTurn();
  
  // 2. If still fighting, schedule the NEXT attack based on CURRENT stats
  if (game.inCombat) {
      const stats = getPlayerCombatStats();
      game.playerCombatInterval = setTimeout(playerCombatLoop, stats.attackSpeed);
  }
}

function playerAttackTurn(spellOverride = null) {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- Determine Attack Type and Spell ---
  const weapon = game.equipment.weapon;
  const isRanged = (weapon && weapon.name.endsWith('Bow'));
  const isMagic = (weapon && weapon.name === 'Magic Staff');
  
  let currentSpell = null;
  
  if (spellOverride) {
      currentSpell = spellOverride; // Manual click overrides autocast
  } else if (game.autocastSpell && isMagic) { // <--- FIX: Only autocast if holding staff
      // Find the spell object from the name
      currentSpell = SPELL_LIST.find(s => s.name === game.autocastSpell);
      if (!currentSpell) {
          game.autocastSpell = null; // Autocast spell not found/cleared
          showWarningPopup("Autocast spell cleared.");
      }
  }

  // --- Pre-Attack Checks ---
  if (isRanged) {
      const arrows = game.equipment.arrows;
      if (!arrows || arrows.qty < 1) {
          showWarningPopup("You ran out of arrows!");
          runFromCombat(false); 
          return; 
      }
  } else if (currentSpell && !isMagic) {
      // Trying to cast a spell but not equipped with a magic staff
      showWarningPopup("You need a Magic Staff equipped to cast spells!");
      return;
  } else if (currentSpell && game.magic.level < currentSpell.level) {
      // Should be prevented by UI, but check anyway
      showWarningPopup(`Magic level too low for ${currentSpell.name}!`);
      return;
  }

  // +++ NEW STONE AMMUNITION CHECK +++
  if (currentSpell) {
      let requiredStone = '';
      if (currentSpell.name === 'Earth Bolt') requiredStone = 'Earthstone';
      else if (currentSpell.name === 'Air Bolt') requiredStone = 'Airstone';
      else if (currentSpell.name === 'Water Bolt') requiredStone = 'Waterstone';
      
      // Check inventory for 3 stones (sums up all stacks)
      let stoneCount = 0;
      for (const slot of game.inventory) {
          if (slot && slot.name === requiredStone) stoneCount += slot.qty;
      }
      
      if (stoneCount < 3) {
          showWarningPopup(`Need 3 ${requiredStone} to cast!`);
          return; // Stop cast (miss turn)
      }
      
      // Remove stones
      removeItem(requiredStone, 3);
  }
  // +++ END NEW STONE AMMUNITION CHECK +++

  // If we have a magic staff but no autocast/manual spell, default to doing nothing/waiting.
  // This is how we allow the player to wait for a manual click when they have no autocast selected.
  if (isMagic && !currentSpell && !spellOverride) return; 
  
  // FIX: Removed the check for game.playerCombatInterval. 
  // Spam is now prevented by the Time Check in handleSpellClick.

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- FIX: Record the time of this attack ---
  game.lastAttackTime = Date.now(); 

  // --- 2. Play Attack Sound ---
  if (currentSpell) {
      playGlobalSound('sounds/soundeffects/earthblastsoundeffect.mp3'); // Generic magic sound for now
  } else if (isRanged) {
      playGlobalSound('sounds/soundeffects/arrowsoundeffect.mp3');
  } else {
      playGlobalSound('sounds/soundeffects/swordsoundeffect.mp3');
  }

  // --- 3. Calculate Hit Chance (ALL NEW LOGIC) ---
  const baseHitChance = 70;
  let playerAccuracy = 0;
  
  if (currentSpell) {
      playerAccuracy = game.magic.level; // Uses Magic Level for accuracy
  } else {
      // Uses Ranged or Attack Level
      playerAccuracy = playerStats.offensiveSkillLevel + playerStats.accuracyBonus;
  }
  
  const enemyDefence = game.currentEnemy.defence;
  
  let hitChance = baseHitChance + (playerAccuracy - enemyDefence);
  hitChance = Math.max(10, Math.min(90, hitChance)); 

  if (Math.random() * 100 > hitChance) {
    showDamageSplat('enemy', 0, 'block'); 
    return;
  }
  // --- END NEW HIT CHANCE ---

  // --- 4. Calculate Damage (If Hit) ---
  let maxHit = 0;
  let skillXP = 0;
  let skillName = game.playerAttackStyle; // Default to old melee skill name
  
  if (currentSpell) {
      const spellStats = getSpellStats(currentSpell);
      maxHit = spellStats.maxHit;
      skillXP = currentSpell.xp; // XP based on the spell's static XP, not damage
      skillName = 'magic';
  } else if (playerStats.magicDamage > 0) {
      // This path should only be hit if the weapon type is magic and we weren't
      // able to find a spell. We prevent this from happening earlier.
      maxHit = playerStats.magicDamage;
      skillName = 'magic';

  } else {
    maxHit = playerStats.physicalDamage;
    skillName = isRanged ? 'ranged' : game.playerAttackStyle;
  }
  
  // Damage is a random number from 0 to your max hit
  let damage = Math.floor(Math.random() * (maxHit + 1));
  
  // +++ FIX: CAP DAMAGE TO ENEMY'S REMAINING HP +++
  let damageApplied = Math.min(damage, game.currentEnemy.currentHp);

  if (damageApplied > 0) {
    showDamageSplat('enemy', damageApplied, 'damage'); 
  } else {
    showDamageSplat('enemy', 0, 'block');
  }

  // Apply damage to enemy
  game.currentEnemy.currentHp -= damageApplied;
  updateEnemyCombatUI();
  
  // --- Consume Arrow AFTER shot ---
  if (isRanged) {
      game.equipment.arrows.qty--;
      if (game.equipment.arrows.qty <= 0) {
          game.equipment.arrows = null;
      }
      renderEquipment(); 
  }
  
  // --- 5. Grant XP (MODIFIED) ---
  if (damageApplied > 0) {
    // Magic now behaves exactly like Melee/Ranged (4 XP per damage point)
    let mainXPGained = damageApplied * 4;
    let vitalityXPGained = Math.ceil(mainXPGained / 2);
    
    // REMOVED: The block that gave fixed XP per cast and reduced damage XP.

    addXP('vitality', vitalityXPGained, 450);
    
    // --- SKILL XP LOGIC ---
    if (skillName === 'magic') {
        if (game.playerAttackStyle === 'defence') {
            let defenceXp = Math.floor(mainXPGained / 2);
            let magicXp = Math.ceil(mainXPGained / 2);
            addXP('defence', defenceXp, 0);
            addXP('magic', magicXp, 0);
        } else {
            addXP('magic', mainXPGained, 0);
        }
    } else if (skillName === 'ranged') {
        if (game.playerAttackStyle === 'defence') {
            let defenceXp = Math.floor(mainXPGained / 2);
            let rangedXp = Math.ceil(mainXPGained / 2);
            addXP('defence', defenceXp, 0);
            addXP('ranged', rangedXp, 0);
        } else {
            addXP('ranged', mainXPGained, 0);
        }
    } else {
        // Melee (attack, strength, defence)
        addXP(game.playerAttackStyle, mainXPGained, 0);
    }
  }
  // --- END NEW XP LOGIC ---

  // --- 6. Check for Enemy Death ---
  if (game.currentEnemy.currentHp <= 0) {
    
    // +++ NEW: QUEST KILL UPDATE +++
    updateQuestKillCount(game.currentEnemy.name);
    // +++ END NEW +++

    // +++ NEW: BOUNTY PROGRESS UPDATE +++
    // Delay set to 1350ms to appear immediately following the item drop (900ms)
    updateBountyProgress(game.currentEnemy.name, 1350);
    // +++ END NEW +++

    // ... existing loot logic ...
    if (game.currentEnemy.name === 'Chicken') { 
      addItem('Raw Chicken', 1);
      const featherQty = Math.floor(Math.random() * 5) + 2; 
      addItem('Feather', featherQty);
      
      showItemPopup('+1 Raw Chicken', null, 900);
      showItemPopup(`+${featherQty} Feather`, null, 1350); 
    } else if (game.currentEnemy.name === 'Rat') {
      addItem('Rat Tail', 1);
      showItemPopup(`+1 Rat Tail`, null, 900);
    } else if (game.currentEnemy.name === 'Spider') { 
      const silkQty = Math.floor(Math.random() * 3) + 1; 
      addItem('Silk', silkQty);
      
      showItemPopup(`+${silkQty} Silk`, null, 900);

      // +++ NEW PET DROP LOGIC (1 in 10,000) +++
      if (Math.floor(Math.random() * 10000) === 0) {
          addItem('Pet Spider', 1);
          // Show a distinct popup and chat message
          showItemPopup('<span style="color:#ff4d4d; font-size:16px;">PET DROP!</span>', null, 500);
          if (typeof addLocalChatMessage === 'function') {
             addLocalChatMessage("You received a rare drop: Pet Spider!", "trade"); 
          }
      }
      // +++ END PET DROP LOGIC +++

    } else if (game.currentEnemy.name === 'Centipede') {
      // Check if player has an Empty Vial
      if (removeItem('Empty Vial', 1)) {
          addItem('Venom', 1);
          showItemPopup(`+1 Venom`, null, 900);
          showItemPopup(`<span style="color:#aaa; font-size:12px;">Filled Vial</span>`, null, 1300);
      } else {
          showItemPopup(`No drops.`, null, 900);
      }

    } else if (game.currentEnemy.name === 'Cow') {
      addItem('Cow Hide', 1);
      addItem('Beef', 1); // +++ NEW DROP +++
      const featherQty = Math.floor(Math.random() * 5) + 2; 
      addItem('Feather', featherQty);
      
      showItemPopup('+1 Raw Chicken', null, 900);
      showItemPopup(`+${featherQty} Feather`, null, 1350); 
    } else if (game.currentEnemy.name === 'Spider') { 
      const silkQty = Math.floor(Math.random() * 3) + 1; 
      addItem('Silk', silkQty);
      
      showItemPopup(`+${silkQty} Silk`, null, 900);

      // +++ NEW PET DROP LOGIC (1 in 10,000) +++
      if (Math.floor(Math.random() * 10000) === 0) {
          addItem('Pet Spider', 1);
          // Show a distinct popup and chat message
          showItemPopup('<span style="color:#ff4d4d; font-size:16px;">PET DROP!</span>', null, 500);
          if (typeof addLocalChatMessage === 'function') {
             addLocalChatMessage("You received a rare drop: Pet Spider!", "trade"); 
          }
      }
      // +++ END PET DROP LOGIC +++

    } else if (game.currentEnemy.name === 'Cow') {
      addItem('Cow Hide', 1);
      addItem('Beef', 1); // +++ NEW DROP +++
      showItemPopup(`+1 Cow Hide`, null, 900);
      showItemPopup(`+1 Beef`, null, 1350); // +++ NEW POPUP +++
    }
    
    // --- FIX: Changed maxHP to maxHp (Case sensitive) ---
    game.currentEnemy.currentHp = game.currentEnemy.maxHp;
    updateEnemyCombatUI();
  }
}

// NEW: The Enemy's turn to attack
function enemyAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- 2. Calculate Hit Chance ---
  let hitChance = 25 + (game.currentEnemy.attack - game.defence.level);
  hitChance = Math.max(5, Math.min(50, hitChance)); 
  
  if (Math.random() * 100 > hitChance) {
    showDamageSplat('player', 0, 'block'); // PLAYER MISS
    return;
  }

  // --- 3. Calculate Damage (If Hit) ---
  let maxHit = game.currentEnemy.strength; // Chicken max hit is 1
  let damage = Math.floor(Math.random() * (maxHit + 1)); // Will be 0 or 1

  // --- 4. Apply Damage Reduction ---
  // 'playerStats.armor' is the total armor from skills + equipment
  // The chicken's max hit is 1. We'll make it simple:
  // If player's armor > 0, they have a chance to block.
  // (Armor * 10%) chance to block the hit entirely.
  let armorChance = Math.min(80, playerStats.armor * 10); // Max 80% block chance
  
  if (damage > 0 && (Math.random() * 100 < armorChance)) {
    damage = 0; // Blocked!
  }
  
  if (damage > 0) {
    showDamageSplat('player', damage, 'damage'); // PLAYER HIT
  } else {
    showDamageSplat('player', 0, 'block'); // PLAYER HIT A 0 (or was blocked)
  }
  
  // Apply damage to player
  game.hp -= damage;
  updateHPUI(); 

  // --- 5. Check for Player Death ---
  if (game.hp <= 0) {
    game.hp = 0; 
    updateHPUI();
    runFromCombat(true); 
    handlePlayerDeath();
  }
}

// =================================================================
// +++ NEW: LOTTERY SYSTEM LOGIC +++
// =================================================================
const LOTTERY_COST = 10000;
const SLOT_WIDTH = 80; 
const WINNER_INDEX = 40; 
const TOTAL_SLOTS = 50; 

// =================================================================
// +++ NEW: WEIGHTED LOTTERY SYSTEM +++
// =================================================================

// --- Loot Table with Weights ---
// weight: 100 = Common, 60 = Uncommon, 30 = Rare, 5 = Legendary
const LOTTERY_LOOT = [
    // --- COMMON (Weight: 100) ---
    { name: 'Coal Ore', qty: 1000, weight: 100 },
    { name: 'Copper Ore', qty: 1000, weight: 100 },
    { name: 'Softwood', qty: 1000, weight: 100 },
    { name: 'Feather', qty: 1000, weight: 100 },
    { name: 'Raw Chicken', qty: 1000, weight: 100 },
    
    // --- UNCOMMON (Weight: 60) ---
    { name: 'Fishing Bait', qty: 1000, weight: 60 },
    { name: 'Iron Ore', qty: 1000, weight: 60 },
    { name: 'Gold', qty: 5000, weight: 40 },
    
    // --- RARE (Weight: 30) ---
    { name: 'Iron Bar', qty: 750, weight: 30 },
    { name: 'Oak', qty: 1000, weight: 30 },
    { name: 'Cooked Salmon', qty: 750, weight: 30 },
    { name: 'Gold', qty: 25000, weight: 10 },

    // --- LEGENDARY (Weight: 5) ---
    { name: 'Waterstone', qty: 2000, weight: 20 },     
    { name: 'Airstone', qty: 2000, weight: 20 } 
  ];

// --- Helper to get a weighted random item ---
function getRandomLotteryFiller() {
    // 1. Calculate total weight of all items
    let totalWeight = 0;
    for (const item of LOTTERY_LOOT) {
        // If you forget to add a weight, it defaults to 10
        totalWeight += (item.weight || 10);
    }

    // 2. Pick a random number between 0 and Total Weight
    let random = Math.floor(Math.random() * totalWeight);

    // 3. Find which item corresponds to that random number
    for (const item of LOTTERY_LOOT) {
        const weight = item.weight || 10;
        if (random < weight) {
            return item;
        }
        random -= weight;
    }
    
    // Fallback (should never happen if math is right)
    return LOTTERY_LOOT[0];
}

function openLotteryHub() {
    showMainScreen('hubLottery');
    const reel = document.getElementById('lotteryReel');
    const resultMsg = document.getElementById('lotteryResultMsg');
    const buyBtn = document.getElementById('buyTicketBtn');
    const returnBtn = document.getElementById('hubLottery_ReturnBtn');
    
    reel.style.transition = 'none';
    reel.style.transform = 'translateX(0px)';
    reel.innerHTML = '';
    resultMsg.innerHTML = '';
    buyBtn.disabled = false;
    returnBtn.disabled = false;

    for(let i=0; i<10; i++) {
        let item;
        
        // +++ TEASER LOGIC +++
        if (Math.random() < 0.10) {
            item = { name: 'Gold Crown', qty: 1 };
        } else {
            item = getRandomLotteryFiller();
        }
        
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        
        let imgName = item.name.toLowerCase().replace(/\s+/g, '');
        
        // FIX: Image Mapping
        if (item.name === 'Copper Ore') imgName = 'copper_ore';
        if (item.name === 'Gold') imgName = 'goldpouch'; // <--- Map Gold to the pouch image
        
        slot.innerHTML = `<img src="images/${imgName}.png"><span class="qty-badge">${formatAmount(item.qty)}</span>`;
        
        if (item.name === "Gold Crown") {
            slot.style.background = "radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(0,0,0,0) 70%)";
        }

        reel.appendChild(slot);
    }
}

async function buyLotteryTicket() {
    if (!game.isSessionActive) {
        await showGameAlert("Session Error", "Session not active.");
        return;
    }
    if (game.gold < LOTTERY_COST) {
        await showGameAlert("Too Poor", "You need 10,000 Gold to buy a ticket.");
        return;
    }
    
    // Check inventory space generally.
    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex === -1) {
         await showGameAlert("Inventory Full", "Please make space in your inventory before playing.");
         return;
    }

    // 1. Determine Winner (Internal Math Only)
    let wonItemName = "";
    let wonItemQty = 1;
    
    // --- THE ODDS (1 in 2,000) ---
    const jackpotRoll = Math.floor(Math.random() * 2000) + 1;
    
    if (jackpotRoll === 1) {
        wonItemName = "Gold Crown";
        wonItemQty = 1;
    } else {
        const item = getRandomLotteryFiller();
        wonItemName = item.name;
        wonItemQty = item.qty;
    }

    // 2. Transaction: Take Ticket Cost IMMEDIATELY
    addGold(-LOTTERY_COST);

    // 3. SAVE IMMEDIATELY 
    // The gold is gone. The item has NOT been given yet.
    // If they refresh now, they lose the gold and get nothing.
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData(); 
    }

    // 4. Build the Visual Reel
    const reel = document.getElementById('lotteryReel');
    reel.innerHTML = '';
    
    for(let i=0; i<TOTAL_SLOTS; i++) {
        let itemDisplay;
        
        if (i === WINNER_INDEX) {
            itemDisplay = { name: wonItemName, qty: wonItemQty };
        } else {
            // Filler logic
            if (Math.random() < 0.05) {
                itemDisplay = { name: 'Gold Crown', qty: 1 };
            } else {
                itemDisplay = getRandomLotteryFiller();
            }
        }
        
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        
        let imgName = itemDisplay.name.toLowerCase().replace(/\s+/g, '');

        // Fix specific image names
        if (itemDisplay.name === 'Copper Ore') imgName = 'copper_ore';
        if (itemDisplay.name === 'Gold Crown') imgName = 'goldcrown';
        if (itemDisplay.name === 'Gold') imgName = 'goldpouch'; 
        
        slot.innerHTML = `<img src="images/${imgName}.png"><span class="qty-badge">${formatAmount(itemDisplay.qty)}</span>`;
        
        if (itemDisplay.name === "Gold Crown") {
            slot.style.background = "radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(0,0,0,0) 70%)";
        }
        reel.appendChild(slot);
    }

    // 5. Lock Buttons & Animate
    const buyBtn = document.getElementById('buyTicketBtn');
    const returnBtn = document.getElementById('hubLottery_ReturnBtn');
    buyBtn.disabled = true;
    returnBtn.disabled = true;
    document.getElementById('lotteryResultMsg').innerHTML = '';

    const randomOffset = 0; 
    const containerCenter = document.querySelector('.lottery-window').offsetWidth / 2;
    const winnerCenter = (WINNER_INDEX * SLOT_WIDTH) + (SLOT_WIDTH / 2);
    const scrollPos = -(winnerCenter - containerCenter);

    reel.style.transition = 'none';
    reel.style.transform = 'translateX(0px)';
    reel.offsetHeight; 
    reel.style.transition = 'transform 4s cubic-bezier(0.1, 0.1, 0.1, 1)'; 
    reel.style.transform = `translateX(${scrollPos}px)`;

    // 6. End Event (After Animation Finishes)
    setTimeout(() => {
        // --- AWARD PRIZE HERE ---
        if (wonItemName === 'Gold') {
            addGold(wonItemQty); 
        } else {
            addItem(wonItemName, wonItemQty); 
        }

        // Show Result
        const resultMsg = document.getElementById('lotteryResultMsg');
        if (wonItemName === "Gold Crown") {
            resultMsg.innerHTML = `<span style="color: #ff4d4d; font-size: 22px;">JACKPOT! YOU WON THE GOLD CROWN!</span>`;
            playGlobalSound('sounds/soundeffects/levelupsound.mp3');
        } else {
            resultMsg.innerHTML = `Won: ${wonItemQty.toLocaleString()} ${wonItemName}`;
            playGlobalSound('sounds/soundeffects/inventorysound.mp3');
        }
        
        // Unlock buttons
        buyBtn.disabled = false;
        returnBtn.disabled = false;
        
        // --- SAVE AGAIN ---
        // Save now to lock in the prize.
        if (typeof window.savePlayerData === 'function') {
            window.savePlayerData(); 
        }
        
    }, 4100);
}

function backToActions(){
  showMainScreen('hubActions');
}

function _createModal(title, contentHtml, buttons) {
  // +++ FIX: Force tooltip to hide immediately when a popup opens +++
  if (typeof hideTooltip === 'function') {
    hideTooltip();
  }

  // Return a new promise that we can control
  return new Promise((resolve) => {
    // 1. Create elements
    const overlay = document.createElement('div');
    overlay.id = 'gameModalOverlay';

    const modal = document.createElement('div');
    modal.className = 'game-modal';

    const titleEl = document.createElement('div');
    titleEl.className = 'game-modal-title';
    titleEl.textContent = title;

    const contentEl = document.createElement('div');
    contentEl.className = 'game-modal-content';
    contentEl.innerHTML = contentHtml; // Use innerHTML to allow custom content

    const buttonEl = document.createElement('div');
    buttonEl.className = 'game-modal-buttons';

    // 2. Create buttons
    buttons.forEach(btnConfig => {
      const button = document.createElement('button');
      button.textContent = btnConfig.text;
      button.className = btnConfig.class || 'primary';
      if (btnConfig.style) {
        button.style.background = btnConfig.style;
      }

      // --- MODIFIED ONCLICK LOGIC ---
      button.onclick = () => {
        const inputEl = modal.querySelector('.game-modal-input');
        let resolveValue = btnConfig.value; // Default to the button's value (e.g., null for 'Cancel')

        // If an input exists AND the clicked button was NOT a cancel button (value is not null)
        if (inputEl && btnConfig.value !== null) { 
          resolveValue = inputEl.value; // Resolve with the input's value instead
        }
        
        overlay.remove();
        resolve(resolveValue); // Resolve with either the input value or the button value
      };
      // --- END MODIFICATION ---
      
      buttonEl.appendChild(button);
    });

    // 3. Assemble and append
    modal.appendChild(titleEl);
    modal.appendChild(contentEl);
    modal.appendChild(buttonEl);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Focus the first primary button or input
    const firstButton = modal.querySelector('button.primary');
    const firstInput = modal.querySelector('input');
    if (firstInput) {
      firstInput.focus();
      firstInput.select(); // Also select the text
    } else if (firstButton) {
      firstButton.focus();
    }
  });
}

/**
 * Shows a custom, in-game alert box.
 * Replaces the default browser alert().
 * @param {string} title - The title for the alert.
 * @param {string} message - The message to display.
 */
async function showGameAlert(title, message) {
  const buttons = [
    { text: 'OK', value: 'ok', class: 'primary' }
  ];
  // We await the modal helper. The promise will resolve when 'OK' is clicked.
  await _createModal(title, `<p>${message}</p>`, buttons);
}

async function showGamePrompt(title, message, defaultValue = '') {
  // HTML for the modal's content, including the input field
  const contentHtml = `
    <p>${message}</p>
    <input type="number" class="game-modal-input" value="${defaultValue}" onfocus="this.select();">
  `;
  
  // Buttons: Cancel (value: null) and OK (value: 'ok')
  const buttons = [
    { text: 'Cancel', value: null, class: 'primary', style: '#666' },
    { text: 'OK', value: 'ok', class: 'primary' } // 'ok' is a placeholder, _createModal will grab the input value
  ];

  // Our upgraded _createModal will return the input's value if 'OK' is clicked,
  // or null if 'Cancel' is clicked.
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}

/**
 * Shows a custom, in-game confirmation box (Yes/No).
 * Replaces the default browser confirm().
 * @param {string} title - The title for the confirm box.
 * @param {string} message - The question to ask.
 * @returns {Promise<boolean>} - Resolves true if "Yes" was clicked, false if "No"/"Cancel".
 */
async function showGameConfirm(title, message) {
  const contentHtml = `<p>${message}</p>`;
  
  const buttons = [
    { text: 'No', value: false, class: 'primary', style: '#666' },
    { text: 'Yes', value: true, class: 'primary' } // 'Yes' resolves to true
  ];

  // This will return `true` or `false`
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}


let draggedBankItem = null; // Stores data for bank drag-and-drop

/**
 * Renders the Bank grid UI
 */
function renderBankGrid() {
  const grid = document.getElementById('bankGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  for(let i = 0; i < game.bankCapacity; i++) {
    const slotData = game.bank[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    slot.addEventListener('dragover', handleBankDragOver);
    slot.addEventListener('dragleave', (e) => e.target.closest('.inv-slot').classList.remove('drag-over'));
    slot.addEventListener('drop', handleBankDrop);
    
    if(slotData) {
      const item = slotData;
      
      slot.draggable = true; 
      slot.addEventListener('dragstart', (e) => handleBankWithdrawDragStart(e, item, i));
      slot.addEventListener('dragend', () => {
        draggedBankItem = null;
        game.isDragging = false; 
        const draggingEl = document.querySelector('.inv-slot.dragging');
        if (draggingEl) draggingEl.classList.remove('dragging');
      });
      
      slot.onclick = () => withdrawItem(i); 

      const img = document.createElement('img');
              let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
              if (item.name === 'Copper Bar') imgName = 'copperbar';
              else if (item.name === 'Copper Chestplate') imgName = 'copperchestplate';
              else if (item.name === 'Copper Shortsword') imgName = 'coppershortsword';
              else if (item.name === 'Copper Helmet') imgName = 'copperhelmet';
              else if (item.name === 'Copper Boots') imgName = 'copperboots';
              else if (item.name === 'Raw Chicken') imgName = 'rawchicken';
              else if (item.name === 'Cooked Chicken') imgName = 'cookedchicken';
              else if (item.name === 'Burnt Chicken') imgName = 'burntchicken';
              
              // +++ NEW COOKED FISH IMAGES +++
              else if (item.name === 'Cooked Herring') imgName = 'cookedherring';
              else if (item.name === 'Burnt Herring') imgName = 'burntherring';
              else if (item.name === 'Cooked Trout') imgName = 'cookedtrout';
              else if (item.name === 'Burnt Trout') imgName = 'burnttrout';
              else if (item.name === 'Cooked Salmon') imgName = 'cookedsalmon';
              else if (item.name === 'Burnt Salmon') imgName = 'burntsalmon';
              
              // +++ NEW BEEF IMAGES +++
              else if (item.name === 'Beef') imgName = 'beef';
              else if (item.name === 'Cooked Beef') imgName = 'cookedbeef';
              else if (item.name === 'Burnt Beef') imgName = 'burntbeef';

              // +++ FIX: Add Gold Crown mapping here +++
              else if (item.name === 'Gold Crown') imgName = 'goldcrown'; 
              // +++ END NEW +++

              else if (item.name === 'Coal Ore') imgName = 'coalore';
              else if (item.name === 'Iron Ore') imgName = 'ironore';
              else if (item.name === 'Iron Bar') imgName = 'ironbar';
              else if (item.name === 'Iron Helmet') imgName = 'ironhelmet';
              else if (item.name === 'Iron Chestplate') imgName = 'ironchestplate';
              else if (item.name === 'Iron Boots') imgName = 'ironboots';
              else if (item.name === 'Iron Shortsword') imgName = 'ironshortsword';
              else if (item.name === 'Copper Platelegs') imgName = 'copperplatelegs'; // +++ NEW +++
              else if (item.name === 'Iron Platelegs') imgName = 'ironplatelegs'; // +++ NEW +++
              else if (item.name === 'Softwood') imgName = 'softwood';
              else if (item.name === 'Oak') imgName = 'oak';
              else if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe'; // +++ NEW +++
              else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe'; // +++ NEW +++
              else if (item.name === 'Copper Pickaxe') imgName = 'copperpickaxe'; // +++ NEW +++
              else if (item.name === 'Copper Axe') imgName = 'copperaxe'; // +++ NEW +++
              else if (item.name === 'Iron Pickaxe') imgName = 'ironpickaxe'; // +++ NEW +++
              else if (item.name === 'Iron Axe') imgName = 'ironaxe'; // +++ NEW +++
              else if (item.name === 'Feather') imgName = 'feather'; // +++ NEW +++
              else if (item.name === 'Arrow Shaft') imgName = 'arrowshaft'; // +++ NEW +++
              else if (item.name === 'Copper Arrow Tip') imgName = 'copperarrowtip'; // +++ NEW +++
              else if (item.name === 'Unbound Arrow') imgName = 'unboundarrow'; // +++ NEW +++
              else if (item.name === 'Copper Arrow') imgName = 'copperarrow'; // +++ NEW +++
              else if (item.name === 'Silk') imgName = 'silk'; // +++ NEW +++

              // +++ NEW CLOTH & WIZARD ITEMS +++
              else if (item.name === 'Cloth') imgName = 'cloth';
              else if (item.name === 'Wizard Hat') imgName = 'wizardhat';
              else if (item.name === 'Wizard Robe') imgName = 'wizardrobe';
              else if (item.name === 'Wizard Trousers') imgName = 'wizardtrousers';
              else if (item.name === 'Wizard Boots') imgName = 'wizardboots';
              else if (item.name === 'Magic Staff') imgName = 'magicstaff'; // +++ NEW +++
              else if (item.name === 'Pet Spider') imgName = 'petspider'; // +++ NEW PET +++
              else if (item.name === 'Rat Tail') imgName = 'rattail'; // +++ NEW ITEM +++
              else if (item.name === 'Sand') imgName = 'sand'; // +++ NEW +++
              else if (item.name === 'Empty Vial') imgName = 'emptyvial'; // +++ NEW +++
              else if (item.name === 'Venom') imgName = 'venom'; // +++ NEW +++
              
              // +++ NEW CRYSTAL SHARDS +++
              else if (item.name === 'Earth Crystal Shard') imgName = 'earthcrystalshard';
              else if (item.name === 'Air Crystal Shard') imgName = 'aircrystalshard';
              else if (item.name === 'Water Crystal Shard') imgName = 'watercrystalshard';

              // --- THIS IS THE MISSING BLOCK ---
              else if (item.name === 'Bow String') {
                  imgName = 'bowstring';
              } else if (item.name === 'Unstrung Softwood Bow') {
                  imgName = 'unstrungsoftwoodbow';
              } else if (item.name === 'Unstrung Oak Bow') {
                  imgName = 'unstrungoakbow';
              } else if (item.name === 'Softwood Bow') {
                  imgName = 'softwoodbow';
              } else if (item.name === 'Oak Bow') {
                  imgName = 'oakbow';
              }

// +++ NEW LEATHER +++
              else if (item.name === 'Cow Hide') {
                  imgName = 'cowhide';
              } else if (item.name === 'Leather') {
                  imgName = 'leather';
              } else if (item.name === 'Leather Hood') {
                  imgName = 'leatherhood';
              } else if (item.name === 'Leather Body') {
                  imgName = 'leatherarmor';
              } else if (item.name === 'Leather Chaps') {
                  imgName = 'leatherpants';
              } else if (item.name === 'Leather Boots') {
                  imgName = 'leatherboots';
              }

              // +++ NEW FISHING ITEMS +++
              else if (item.name === 'Herring') {
                  imgName = 'herring';
              } else if (item.name === 'Trout') {
                  imgName = 'trout';
              } else if (item.name === 'Salmon') {
                  imgName = 'salmon';
              } else if (item.name === 'Fishing Pole') {
                  imgName = 'fishingpole';
              } else if (item.name === 'Fishing Bait') {
                  imgName = 'fishingbait';
              }

              // --- END OF FIX ---
              img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      const stats = ITEM_STATS[item.name];
      if (stats) {
        if (stats.damage) itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
        <div>Amount: ${item.qty.toLocaleString()}</div>
        ${itemStats}
        <div style="color:#ffaaaa; margin-top: 5px;">Click or Drag to withdraw...</div>
      `;
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
    }
    grid.appendChild(slot);
  }
}



/**
 * Updates the gold values on the bank screen
 */
function updateBankGoldUI() {
  setText('bankPlayerGold', formatAmount(game.gold));
  setText('bankStoredGold', formatAmount(game.bankGold));
}

/**
 * Main function to open the Bank UI
 */
function openBank() {
  showMainScreen('hubBank');
}
// --- Bank Drag-and-Drop Handlers ---

function handleBankDragStart(e, item, fromIndex) {
  // Store item data for the drop
  draggedBankItem = { item, fromIndex };
  e.dataTransfer.effectAllowed = 'move';
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}

function handleBankDragOver(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  if (targetSlot) {
    targetSlot.classList.add('drag-over');
  }
}

async function handleBankDrop(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  
  if (targetSlot) {
    targetSlot.classList.remove('drag-over');
  }
  
  // Clean up *any* dragging slot, from either grid
  const draggingInvEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
  if (draggingInvEl) draggingInvEl.classList.remove('dragging');
  const draggingBankEl = document.querySelector('#bankGrid .inv-slot.dragging');
  if (draggingBankEl) draggingBankEl.classList.remove('dragging');

  if (!targetSlot || !draggedBankItem) {
     draggedBankItem = null;
     return;
  }

  const toIndex = parseInt(targetSlot.dataset.slotIndex);
  const fromIndex = draggedBankItem.fromIndex;

  // --- NEW LOGIC: Check drag source ---
  if (draggedBankItem.source === 'bank') {
    // === BANK -> BANK internal move ===
    
    if (fromIndex !== toIndex) {
      // --- Get the item data *before* the prompt ---
      const dragItemBeforePrompt = game.bank[fromIndex];
      const dropItem = game.bank[toIndex];

      // --- MODIFIED: Handle Shift-Click to move specific amount ---
      if (e.shiftKey && dragItemBeforePrompt) { 
        
        if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
          await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
        } else {
          const input = await showGamePrompt(
            `Move ${dragItemBeforePrompt.name}`, 
            `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
            "" 
          );

          // --- THIS IS THE FIX ---
          // After the prompt (await) is done, we re-check the bank
            
          if (input === null) {
            // User cancelled
            const originalSlotEl = document.querySelector(`#bankGrid .inv-slot[data-slot-index="${fromIndex}"]`);
            if (originalSlotEl) {
              originalSlotEl.classList.remove('dragging');
            }
          } else {
            // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
            const itemAfterPrompt = game.bank[fromIndex]; // Check game.bank
            
            // Check if the item was consumed or changed
            if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
              // The item was consumed! Abort.
              draggedBankItem = null;
              game.isDragging = false;
              return; // Safely exit
            }
            // --- END EXPLOIT FIX ---
            
            const splitAmount = parseInt(input);

            if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid */ }
            
            // Use the most up-to-date quantity
            else if (splitAmount > itemAfterPrompt.qty) { 
              await showGameAlert("Invalid Amount", "You don't have that many.");
            } 
            
            else if (splitAmount === itemAfterPrompt.qty) { 
              // Full stack move
              if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                dropItem.qty += itemAfterPrompt.qty;
                game.bank[fromIndex] = null;
              } else {
                game.bank[fromIndex] = dropItem;
                game.bank[toIndex] = itemAfterPrompt;
              }
              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
            
            else {
              // This is a valid SPLIT
              if (dropItem) { 
                dropItem.qty += splitAmount;
              } else { 
                game.bank[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
              }
              itemAfterPrompt.qty -= splitAmount; // Use the validated item

              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
          }
        }
      } else {
        // --- BANK SWAP/STACK (No Shift) ---
        // We must re-get the dragItem in case it was consumed
        const dragItem = game.bank[fromIndex]; 
        if (dragItem && dropItem && dragItem.name === dropItem.name) {
          dropItem.qty += dragItem.qty;
          game.bank[fromIndex] = null;
        } else {
          game.bank[fromIndex] = dropItem;
          game.bank[toIndex] = dragItem;
        }
        renderBankGrid();
        if (typeof window.savePlayerData === 'function') savePlayerData();
      }
    }

  } else {
    // === INVENTORY -> BANK deposit (Original Logic) ===
    const depositSuccess = await depositItem(draggedBankItem.item, fromIndex, toIndex);
    
    if (!depositSuccess) {
      // User cancelled deposit, remove 'dragging' class from INVENTORY slot
      const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
      if (originalSlotEl) {
        originalSlotEl.classList.remove('dragging');
      }
    }
  }
  
  draggedBankItem = null;
}

// --- Bank Core Logic ---

function handleBankWithdrawDragStart(e, item, fromBankIndex) {
  // Store item data and the *source* as 'bank'
  draggedBankItem = { item, fromIndex: fromBankIndex, source: 'bank' };
  e.dataTransfer.effectAllowed = 'move';
  game.isDragging = true;
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}


async function depositItem(item, fromInventoryIndex, toBankIndex) {
  if (!item) return;

  const bankSlot = game.bank[toBankIndex];
  
  if (bankSlot && bankSlot.name !== item.name) {
    await showGameAlert("Invalid Slot", "You can't stack different items. Drop on an empty slot or a stack of the same item."); // Replaced alert
    return;
  }

  let qtyToDeposit = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Deposit ${item.name}`,
      `How many ${item.name} do you want to deposit? (You have: ${item.qty})`,
      item.qty
    );
    if (input === null) return false;
    qtyToDeposit = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToDeposit) || qtyToDeposit <= 0) return;
  if (qtyToDeposit > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to deposit."); // Replaced alert
    return;
  }

  game.inventory[fromInventoryIndex].qty -= qtyToDeposit;
  if (game.inventory[fromInventoryIndex].qty <= 0) {
    game.inventory[fromInventoryIndex] = null;
  }

  if (bankSlot) {
    bankSlot.qty += qtyToDeposit;
  } else {
    game.bank[toBankIndex] = { name: item.name, qty: qtyToDeposit };
  }

  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
  return true;
}

async function withdrawItem(fromBankIndex) {
  const item = game.bank[fromBankIndex];
  if (!item) return;

  let qtyToWithdraw = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${item.name}`,
      `How many ${item.name} do you want to withdraw? (Bank has: ${item.qty})`,
      item.qty
    );
    if (input === null) return;
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0) return;
  if (qtyToWithdraw > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to withdraw."); // Replaced alert
    return;
  }
  
  const itemToAdd = { name: item.name, qty: qtyToWithdraw };
  addItem(itemToAdd.name, itemToAdd.qty); 
  
  game.bank[fromBankIndex].qty -= qtyToWithdraw;
  if (game.bank[fromBankIndex].qty <= 0) {
    game.bank[fromBankIndex] = null;
  }
  
  renderBankGrid();
  renderInventoryGrid(); 
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function depositGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.gold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold to deposit."); // <-- USE 'await showGameAlert'
    return;
  }

  game.gold -= amount;
  game.bankGold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function withdrawGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.bankGold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold in your bank."); // <-- USE 'await showGameAlert'
    return;
  }

  game.bankGold -= amount;
  game.gold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function dragWithdrawItem(fromBankIndex, toInventoryIndex) {
  const bankItem = game.bank[fromBankIndex];
  const inventorySlotItem = game.inventory[toInventoryIndex];

  if (!bankItem) return;

  let qtyToWithdraw = bankItem.qty;

  if (bankItem.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${bankItem.name}`,
      `How many ${bankItem.name} do you want to withdraw? (Bank has: ${bankItem.qty})`,
      bankItem.qty
    );
    if (input === null) return; 
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0 || qtyToWithdraw > bankItem.qty) {
    await showGameAlert("Invalid Amount", "Invalid or excessive amount entered."); // Replaced alert
    return;
  }

  if (inventorySlotItem && inventorySlotItem.name === bankItem.name) {
    inventorySlotItem.qty += qtyToWithdraw;
    bankItem.qty -= qtyToWithdraw;
    if (bankItem.qty <= 0) {
      game.bank[fromBankIndex] = null; 
    }

  } else if (inventorySlotItem) {
    if (qtyToWithdraw < bankItem.qty) {
      await showGameAlert("Invalid Action", "You must withdraw the full stack to swap items, or drop onto an empty inventory slot."); // Replaced alert
      return;
    }
    
    game.bank[fromBankIndex] = inventorySlotItem;
    game.inventory[toInventoryIndex] = bankItem;

  } else {
    if (qtyToWithdraw === bankItem.qty) {
        game.inventory[toInventoryIndex] = bankItem;
        game.bank[fromBankIndex] = null; 
    } else {
        game.inventory[toInventoryIndex] = { name: bankItem.name, qty: qtyToWithdraw };
        bankItem.qty -= qtyToWithdraw;
    }
  }
  
  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}
  
// =================================================================
// --- END NEW BANK FUNCTIONS ---
// =================================================================

async function buyShopItem(itemName, price) {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This tab is not active. Please take control to perform actions.");
    return;
  }
  // Check if they can afford at least one
  if (game.gold < price) {
    await showGameAlert("Not Enough Gold", `You need ${price} Gold to buy that.`);
    return;
  }

  // --- NEW: Ask for quantity ---
  const input = await showGamePrompt(
    `Buy ${itemName}`, 
    `How many ${itemName} do you want to buy? (Price: ${price}ea)`, 
    1 // Default value
  );

  if (input === null) return; // User cancelled
  const qtyToBuy = parseInt(input);

  if (isNaN(qtyToBuy) || qtyToBuy <= 0) {
    return; // Invalid number
  }
  // --- END NEW ---

  const totalCost = price * qtyToBuy;
  
  // Check if they have enough gold for the total purchase
  if (game.gold < totalCost) {
    await showGameAlert("Not Enough Gold", `You need ${totalCost} Gold to buy ${qtyToBuy} ${itemName}.`);
    return;
  }

  // Check for inventory space (find existing stack OR an empty slot)
  // Your addItem function is smart, so we just need to make sure
  // it *can* add (i.e., not full with no matching stacks).
  const stackIndex = game.inventory.findIndex(slot => slot && slot.name === itemName);
  const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
  
  if (stackIndex === -1 && emptySlotIndex === -1) {
     await showGameAlert("Inventory Full", "You have no space in your inventory to buy this.");
     return;
  }
  
  addGold(-totalCost);
  addItem(itemName, qtyToBuy); // Use the new quantity
  await showGameAlert("Purchase Complete", `You bought ${qtyToBuy} ${itemName} for ${totalCost} Gold.`);
  
  // No need to render, addItem and addGold already do.
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}

function openShop() {
  showMainScreen('hubShop');
}

function resetGameState() {
  stopMining(); 
  stopBlacksmithing();
  stopFletching(); 
  stopCraftingBowString(); 
  stopFishing(); 
  stopStoneForging(); // +++ NEW +++
  
  // +++ NEW: Add combat stop +++
  if (game.inCombat) {
    runFromCombat(false); // Stop combat loops
  }
  // +++ END NEW +++

  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  game.gold = 100; 
  // +++ NEW +++
  game.bank = new Array(game.bankCapacity).fill(null);
  game.bankGold = 0;
  game.equipment = { 
    necklace: null, helmet: null, cape: null, 
    weapon: null, chest: null, shield: null, 
    ring1: null, legs: null, ring2: null, 
    arrows: null, boots: null 
  };
  // +++ END NEW +++
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.blacksmith = { level: 1, xp: 0, totalXP: 0 };
  game.cooking = { level: 1, xp: 0, totalXP: 0 };
  game.woodcutting = { level: 1, xp: 0, totalXP: 0 };
  game.fletching = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  game.fishing = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  
  // +++ NEW SKILLS +++
  game.crafting = { level: 1, xp: 0, totalXP: 0 };
  game.ranged = { level: 1, xp: 0, totalXP: 0 };
  game.magic = { level: 1, xp: 0, totalXP: 0 };
  game.stoneforging = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  
  // +++ ADD THESE 4 MISSING LINES +++
  game.attack = { level: 1, xp: 0, totalXP: 0 };
  game.strength = { level: 1, xp: 0, totalXP: 0 };
  game.defence = { level: 1, xp: 0, totalXP: 0 };
  game.vitality = { level: 1, xp: 0, totalXP: 0 };
  // +++ END OF FIX +++

  // +++ NEW RESET BOUNTY +++
  game.bountyhunting = { level: 1, xp: 0, totalXP: 0 };
  game.activeBounty = null;

  game.questLines = {}; // +++ FIX: RESET QUESTS +++

  game.miningActive = false;
  game.blacksmithingActive = false; // +++ NEW +++
  game.cookingActive = false;
  game.woodcuttingActive = false; // +++ NEW +++
  game.fletchingActive = false; 
  game.craftingActive = false; 
  game.fishingActive = false; 
  game.stoneforgingActive = false; // +++ NEW +++
  game.shopOpen = false;
  game.isAdmin = false;
  
  // +++ NEW: Reset session state +++
  game.isSessionActive = false;
  game.isDragging = false;
  if (typeof window.stopSessionHeartbeat === 'function') {
      window.stopSessionHeartbeat();
  }
  
  if (game.progressFrame) {
    clearTimeout(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  renderEquipment(); // <-- ADD THIS
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('inventory'); 
  }
}

/**
 * Saves the current game.settings to localStorage
 */
function saveSettings() {
  localStorage.setItem('rusticGameSettings', JSON.stringify(game.settings));
}

/**
 * Loads settings from localStorage into game.settings
 */
function loadSettings() {
  const savedJSON = localStorage.getItem('rusticGameSettings');
  if (savedJSON) {
    const saved = JSON.parse(savedJSON);

    // --- NEW: Migration logic ---
    // Check for old properties
    if (typeof saved.volume === 'number') {
      game.settings.sfxVolume = saved.volume;
    }
    if (typeof saved.isMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isMuted;
    }

    // Load new properties if they exist
    if (typeof saved.sfxVolume === 'number') {
      game.settings.sfxVolume = saved.sfxVolume;
    }
    if (typeof saved.isSfxMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isSfxMuted;
    }
    if (typeof saved.musicVolume === 'number') {
      game.settings.musicVolume = saved.musicVolume;
    }
    if (typeof saved.isMusicMuted === 'boolean') {
      game.settings.isMusicMuted = saved.isMusicMuted;
    }
    // --- END Migration ---
  }

  applySettingsUI();

  // --- NEW: Apply music settings to player ---
  // This ensures music volume is correct on load
  if (typeof updateMusicPlayerState === 'function') {
    updateMusicPlayerState();
  }
}

/**
 * Updates the UI elements in the settings modal
 */
function applySettingsUI() {
  const sfxSlider = document.getElementById('sfxVolumeSlider');
  const sfxMute = document.getElementById('sfxMuteBtn');
  const musicSlider = document.getElementById('musicVolumeSlider');
  const musicMute = document.getElementById('musicMuteBtn');

  // --- SFX Controls ---
  if (sfxSlider) {
    sfxSlider.value = game.settings.sfxVolume;
    sfxSlider.disabled = game.settings.isSfxMuted;
  }
  if (sfxMute) {
    sfxMute.textContent = game.settings.isSfxMuted ? 'Unmute' : 'Mute';
    if (game.settings.isSfxMuted) {
      sfxMute.style.background = 'var(--gold)';
      sfxMute.style.color = '#000';
    } else {
      sfxMute.style.background = 'var(--accent)';
      sfxMute.style.color = '#fff';
    }
  }

  // --- Music Controls ---
  if (musicSlider) {
    musicSlider.value = game.settings.musicVolume;
    musicSlider.disabled = game.settings.isMusicMuted;
  }
  if (musicMute) {
    musicMute.textContent = game.settings.isMusicMuted ? 'Unmute' : 'Mute';
    if (game.settings.isMusicMuted) {
      musicMute.style.background = 'var(--gold)';
      musicMute.style.color = '#000';
    } else {
      musicMute.style.background = 'var(--accent)';
      musicMute.style.color = '#fff';
    }
  }
}

/**
 * Opens the settings modal
 */
function openSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) {
    applySettingsUI(); // Ensure UI is in sync when opening
    modal.style.display = 'flex';
  }
}

/**
 * Closes the settings modal
 */
function closeSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) modal.style.display = 'none';
}

/**
 * The new global sound player that respects settings
 * @param {string} src - The path to the sound file
 */
// +++ NEW: Hub Screen Toggler Function +++
// +++ ADDED hubHuntingBoard +++
const hubScreenIds = ['hubActions', 'hubMine', 'hubCrystalMine', 'hubBlacksmith', 'hubFletching', 'hubCrafting', 'hubElementalForge', 'hubForest', 'hubKitchen', 'hubCombat', 'hubFarm', 'hubCave', 'hubShop', 'hubBank', 'hubDynamic', 'hubFishingAreas', 'hubOcean', 'hubRiver', 'hubLottery', 'hubQuests', 'hubQuestLine', 'hubHuntingBoard'];
function showMainScreen(screenIdToShow) {
  // Stop all skilling actions
  stopMining();
  stopBlacksmithing();
  stopCookingChicken();
  stopWoodcutting();
  stopFletching(); 
  stopCraftingBowString();
  stopFishing(); 
  stopStoneForging(); // +++ NEW +++
  game.shopOpen = false;
  hideTooltip();

  // Get the wrapper and clear dynamic content
  const wrapper = document.getElementById('mainContentWrapper');
  const dynamicHub = document.getElementById('hubDynamic');
  
  // --- We removed the 'if' block that was clearing the HTML ---

  // Toggle the screens
  hubScreenIds.forEach(id => {
    const screen = document.getElementById(id);
    if (screen) {
      if (id === screenIdToShow) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    }
  });

  // Special case: if we're showing the blacksmith hub, render its items
  if (screenIdToShow === 'hubBlacksmith') {
    // --- FIX: Use the last saved tab ---
    const lastTab = game.lastSmithingTab || 'copper';
    renderSmithingItems(lastTab);
    // Also set the active button class
    if (lastTab === 'iron') {
      document.getElementById('smithIronTab').classList.add('active');
      document.getElementById('smithCopperTab').classList.remove('active');
    } else {
      document.getElementById('smithCopperTab').classList.add('active');
      document.getElementById('smithIronTab').classList.remove('active');
    }
    // --- END FIX ---
  }
  
  // +++ NEW: Special case for crafting hub +++
  if (screenIdToShow === 'hubCrafting') {
    renderCraftingItems();
  }
  
  // Special case: if we're showing the mine hub, apply level locks
  if (screenIdToShow === 'hubMine') {
    const miningLvl = game.mining.level;
    document.getElementById('ironVeinBtn').classList.toggle('locked-item', miningLvl < IRON_MINE_LVL);
    document.getElementById('coalVeinBtn').classList.toggle('locked-item', miningLvl < COAL_MINE_LVL);
  }

  // Special case: if we're showing the crystal mine hub, apply level locks
  if (screenIdToShow === 'hubCrystalMine') {
    const miningLvl = game.mining.level;
    // FIX: Apply visual lock to Earth Crystal too
    document.getElementById('earthCrystalBtn').classList.toggle('locked-item', miningLvl < EARTH_CRYSTAL_LVL);
    document.getElementById('airCrystalBtn').classList.toggle('locked-item', miningLvl < AIR_CRYSTAL_LVL);
    document.getElementById('waterCrystalBtn').classList.toggle('locked-item', miningLvl < WATER_CRYSTAL_LVL);
  }
  
  // Special case: if we're showing the forest hub, apply level locks
  if (screenIdToShow === 'hubForest') {
    const woodcuttingLvl = game.woodcutting.level;
    document.getElementById('oakTreeBtn').classList.toggle('locked-item', woodcuttingLvl < OAK_TREE_LVL);
  }

  // +++ NEW: Special case for hubRiver level locks +++
  if (screenIdToShow === 'hubRiver') {
    const fishingLvl = game.fishing.level;
    document.getElementById('fishTroutBtn').classList.toggle('locked-item', fishingLvl < TROUT_FISH_LVL);
    document.getElementById('fishSalmonBtn').classList.toggle('locked-item', fishingLvl < SALMON_FISH_LVL);
  }
  
  // Special case: if we're showing the shop
  if (screenIdToShow === 'hubShop') {
    game.shopOpen = true;
  }
  
  // Special case: if we're showing the bank
  if (screenIdToShow === 'hubBank') {
    renderBankGrid();
    updateBankGoldUI();
  }
}

function playGlobalSound(src) {
  if (game.settings.isSfxMuted) return; // Use new sfxMuted setting
  try {
    const sound = new Audio(src);
    sound.volume = game.settings.sfxVolume; // Use new sfxVolume setting
    sound.play();
  } catch (e) {
    console.warn("Could not play sound", src, e);
  }
}

/**
 * Renders the Shop grid UI
 */
function renderShopGrid() {
  const grid = document.getElementById('shopGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  for(let i = 0; i < SHOP_INVENTORY.length; i++) {
    const item = SHOP_INVENTORY[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    
    if(item) {
      // slot.draggable = true; // <-- DISABLED
      // slot.addEventListener('dragstart', (e) => handleShopDragStart(e, item)); // <-- DISABLED
      // slot.addEventListener('dragend', () => { // <-- DISABLED
      //   draggedShopItem = null;
      //   game.isDragging = false; 
      //   const draggingEl = document.querySelector('.inv-slot.dragging');
      //   if (draggingEl) draggingEl.classList.remove('dragging');
      // }); // <-- DISABLED
      
      slot.onclick = () => buyShopItem(item.name, item.price); 

      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe';
      else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe';
      else if (item.name === 'Fishing Pole') imgName = 'fishingpole';
      else if (item.name === 'Fishing Bait') imgName = 'fishingbait';
      // Add more image name fixes here if needed
      
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; };
      slot.appendChild(img);
      
      // Don't show an amount, just the item

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
        <div style="color:#fff;">Price: ${item.price} Gold</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to buy...</div>
      `; // <-- UPDATED TOOLTIP
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
    }
    grid.appendChild(slot);
  }
}

// --- END: Settings Functions ---


// --- MODIFIED: Added isDragging logic ---
document.addEventListener('DOMContentLoaded', ()=>{
  
  // --- NEW: Stats Panel Listeners ---
  const toggleStatsBtn = document.getElementById('toggleStatsBtn');
  const closeStatsBtn = document.getElementById('closeStatsBtn');
  const statsPanel = document.getElementById('statsPanel');
  const statsPanelHeader = document.getElementById('statsPanelHeader');
  
  // --- NEW: Spells Panel Listeners ---
  const toggleSpellsBtn = document.getElementById('toggleSpellsBtn');
  const closeSpellsBtn = document.getElementById('closeSpellsBtn');
  const spellsPanel = document.getElementById('spellsPanel');
  // --- END NEW ---

  if (toggleStatsBtn) {
    toggleStatsBtn.onclick = () => {
      if (statsPanel) {
        if (typeof renderEquipment === 'function') {
            renderEquipment();
        }
        // Simply toggle visibility. Do NOT close the Spells panel.
        statsPanel.style.visibility = (statsPanel.style.visibility === 'visible') ? 'hidden' : 'visible';
      }
    };
  }
  if (closeStatsBtn) {
    closeStatsBtn.onclick = () => {
      if (statsPanel) statsPanel.style.visibility = 'hidden'; 
    };
  }

  // --- NEW: Toggle Spells Button Logic ---
  if (toggleSpellsBtn) {
    toggleSpellsBtn.onclick = () => {
       if (spellsPanel) {
          // Check if currently hidden or visible
          if (spellsPanel.style.visibility !== 'visible') {
              // Opening
              if (typeof renderSpellsPanel === 'function') renderSpellsPanel();
              spellsPanel.style.visibility = 'visible';
          } else {
              // Closing
              spellsPanel.style.visibility = 'hidden';
              // FIX: Clear icons immediately to prevent visual lag
              const container = document.getElementById('spellsIconsContainer');
              if (container) container.innerHTML = ''; 
          }
       }
    }; 
  }
  
  if (closeSpellsBtn) {
    closeSpellsBtn.onclick = () => {
      if (spellsPanel) {
          spellsPanel.style.visibility = 'hidden'; 
          // FIX: Clear icons immediately to prevent visual lag
          const container = document.getElementById('spellsIconsContainer');
          if (container) container.innerHTML = ''; 
      }
    };
  }
  // --- END NEW ---

  // --- NEW: Draggable Panel Logic ---
  

  if (statsPanelHeader) {
    statsPanelHeader.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // Only drag with left click
      isDraggingPanel = true;

      // --- THIS IS THE FIX ---
      
      // 1. Get the panel's VISUAL position on screen
      const rect = statsPanel.getBoundingClientRect();
      
      // 2. Calculate the mouse's offset from the panel's top-left corner
      panelOffsetX = e.clientX - rect.left;
      panelOffsetY = e.clientY - rect.top;
      
      // 3. ATOMICALLY (all at once):
      //    a) Clear the transform that was centering it
      //    b) Set the top/left to the exact pixel values it was just at
      statsPanel.style.transform = ''; 
      statsPanel.style.top = rect.top + 'px';
      statsPanel.style.left = rect.left + 'px';
      
      e.preventDefault();
    });
  }

  document.addEventListener('mousemove', (e) => {
    if (!isDraggingPanel) return;
    e.preventDefault(); 

    // The 'isFirstMove' logic is gone.
    // We just update the position based on the new mouse coordinates
    // and the offset we saved on mousedown.
    statsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
    statsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
  });

  document.addEventListener('mouseup', (e) => {
    if (isDraggingPanel) {
        isDraggingPanel = false;
        e.preventDefault();
    }
  });
  // --- END: Stats Panel Listeners & Draggable Logic ---
  
  // +++ ADD THIS ENTIRE BLOCK OF LISTENERS +++
  
  // --- Hub Actions (Main Hub) ---
  document.getElementById('minesActionIcon').onclick = openMineHub;
  document.getElementById('crystalMineActionIcon').onclick = openCrystalMineHub; // +++ NEW +++
  document.getElementById('fishingActionIcon').onclick = openFishingHub; // +++ NEW +++
  document.getElementById('forestActionIcon').onclick = openForestHub;
  document.getElementById('blacksmithActionIcon').onclick = openBlacksmithHub;
  document.getElementById('kitchenActionIcon').onclick = openKitchenHub;
  document.getElementById('combatActionIcon').onclick = openCombatHub;
  document.getElementById('shopActionIcon').onclick = openShop;
  document.getElementById('bankActionIcon').onclick = openBank;
  document.getElementById('fletchingActionIcon').onclick = openFletchingHub; // +++ NEW +++
  document.getElementById('craftingActionIcon').onclick = openCraftingHub; 
  document.getElementById('elementalForgeActionIcon').onclick = openElementalForgeHub; // +++ NEW +++
  document.getElementById('huntingBoardActionIcon').onclick = openHuntingBoard; // +++ NEW +++
  document.getElementById('hubHuntingBoard_ReturnBtn').onclick = backToActions; // +++ NEW +++
  
  // +++ NEW: Quest Button Listener +++
  const questBtn = document.getElementById('questsActionIcon');
  if (questBtn) {
      questBtn.onclick = openQuestHub;
      questBtn.onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Quests</div>Check available jobs');
      questBtn.onmouseleave = hideTooltip;
  }
  document.getElementById('hubQuests_ReturnBtn').onclick = backToActions;
  document.getElementById('questLine_ReturnBtn').onclick = openQuestHub;
  
  // --- Hub Crafting Listeners ---
  document.getElementById('hubCrafting_ReturnBtn').onclick = backToActions; 
  document.getElementById('hubElementalForge_ReturnBtn').onclick = backToActions; // +++ NEW +++
  
  // --- Hub Mine Listeners ---

// --- Hub Crystal Mine Listeners ---
  document.getElementById('hubCrystalMine_ReturnBtn').onclick = backToActions;
  
  // FIX: Add level check for Earth Crystal click
  document.getElementById('earthCrystalBtn').onclick = () => {
    if (game.mining.level >= EARTH_CRYSTAL_LVL) openEarthCrystalMine();
  };

  document.getElementById('airCrystalBtn').onclick = () => {
    if (game.mining.level >= AIR_CRYSTAL_LVL) openAirCrystalMine();
  };
  document.getElementById('waterCrystalBtn').onclick = () => {
    if (game.mining.level >= WATER_CRYSTAL_LVL) openWaterCrystalMine();
  };

  document.getElementById('copperVeinBtn').onclick = openCopperMine;
  document.getElementById('ironVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= IRON_MINE_LVL) {
        openIronMine();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('coalVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= COAL_MINE_LVL) {
        openCoalMine();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('hubMine_ReturnBtn').onclick = backToActions;
  
  // --- Hub Blacksmith Listeners ---
  document.getElementById('smithCopperTab').onclick = () => {
    document.getElementById('smithCopperTab').classList.add('active');
    document.getElementById('smithIronTab').classList.remove('active');
    game.lastSmithingTab = 'copper'; // <-- ADD THIS LINE
    renderSmithingItems('copper');
  };
  document.getElementById('smithIronTab').onclick = () => {
    document.getElementById('smithIronTab').classList.add('active');
    document.getElementById('smithCopperTab').classList.remove('active');
    game.lastSmithingTab = 'iron'; // <-- ADD THIS LINE
    renderSmithingItems('iron');
  };
  document.getElementById('hubBlacksmith_ReturnBtn').onclick = backToActions;

  // --- Hub Fletching Listeners ---
  document.getElementById('hubFletching_ReturnBtn').onclick = backToActions;

  // --- Hub Forest Listeners ---
  document.getElementById('softwoodTreeBtn').onclick = openSoftwoodTree;
  document.getElementById('oakTreeBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.woodcutting.level >= OAK_TREE_LVL) {
        openOakTree();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('hubForest_ReturnBtn').onclick = backToActions;

  // --- Hub Kitchen Listeners ---
  document.getElementById('cookChickenBtn').onclick = openCookChicken;
  document.getElementById('cookBeefBtn').onclick = openCookBeef; // +++ NEW +++
  document.getElementById('cookHerringBtn').onclick = openCookHerring; // +++ NEW +++
  document.getElementById('cookTroutBtn').onclick = () => { // +++ NEW +++
    if (game.cooking.level >= COOK_TROUT_LVL) {
      openCookTrout();
    } else {
      document.getElementById('cookTroutBtn').classList.add('locked-item');
    }
  };
  document.getElementById('cookSalmonBtn').onclick = () => { // +++ NEW +++
    if (game.cooking.level >= COOK_SALMON_LVL) {
      openCookSalmon();
    } else {
      document.getElementById('cookSalmonBtn').classList.add('locked-item');
    }
  };
  document.getElementById('hubKitchen_ReturnBtn').onclick = backToActions;

  // --- Hub Combat Listeners ---
  document.getElementById('farmAreaBtn').onclick = openFarmCombatArea;
  document.getElementById('caveAreaBtn').onclick = openCaveCombatArea; // +++ NEW +++
  document.getElementById('hubCombat_ReturnBtn').onclick = backToActions;
  
  // --- Hub Fishing Listeners ---
  document.getElementById('oceanAreaBtn').onclick = openOceanFishingArea;
  document.getElementById('riverAreaBtn').onclick = openRiverFishingArea;
  document.getElementById('hubFishingAreas_ReturnBtn').onclick = backToActions;
  
  // --- Hub Ocean/River Return Listeners ---
  document.getElementById('hubOcean_ReturnBtn').onclick = openFishingHub;
  document.getElementById('hubRiver_ReturnBtn').onclick = openFishingHub;
  
  // --- Hub Farm/Cave Return Listeners ---
  document.getElementById('hubFarm_ReturnBtn').onclick = openCombatHub; // +++ NEW +++
  document.getElementById('hubCave_ReturnBtn').onclick = openCombatHub; // +++ NEW +++

  // --- Hub Fishing Level Locks (in Listeners) ---
  document.getElementById('fishTroutBtn').onclick = () => {
    if (game.fishing.level >= TROUT_FISH_LVL) openFishTrout();
  };
  document.getElementById('fishSalmonBtn').onclick = () => {
    if (game.fishing.level >= SALMON_FISH_LVL) openFishSalmon();
  };
  // CSS class is now applied by showMainScreen('hubRiver')

  // --- Hub Shop Listeners ---
  document.getElementById('hubShop_ReturnBtn').onclick = backToActions;
  
  // --- Hub Bank Listeners ---
  document.getElementById('bankDepositGoldBtn').onclick = depositGold;
  document.getElementById('bankWithdrawGoldBtn').onclick = withdrawGold;
  document.getElementById('hubBank_ReturnBtn').onclick = backToActions;

  // --- Tooltips for Hub Icons ---
  document.getElementById('minesActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Mine</div>');
  document.getElementById('minesActionIcon').onmouseleave = hideTooltip;
  document.getElementById('forestActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Forest</div>');
  document.getElementById('crystalMineActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Crystal Mine</div>');
  document.getElementById('crystalMineActionIcon').onmouseleave = hideTooltip;
  document.getElementById('forestActionIcon').onmouseleave = hideTooltip;
  document.getElementById('blacksmithActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Blacksmith</div>');
  document.getElementById('blacksmithActionIcon').onmouseleave = hideTooltip;
  document.getElementById('kitchenActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Kitchen</div>');
  document.getElementById('kitchenActionIcon').onmouseleave = hideTooltip;
  document.getElementById('combatActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Combat Areas</div>');
  document.getElementById('combatActionIcon').onmouseleave = hideTooltip;
  document.getElementById('shopActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
  document.getElementById('shopActionIcon').onmouseleave = hideTooltip;
  document.getElementById('bankActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Bank</div>');
  document.getElementById('bankActionIcon').onmouseleave = hideTooltip;
  document.getElementById('fletchingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Fletching Bench</div>'); // +++ NEW +++
  document.getElementById('fletchingActionIcon').onmouseleave = hideTooltip; // +++ NEW +++
  document.getElementById('craftingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Crafting Bench</div>');
  document.getElementById('craftingActionIcon').onmouseleave = hideTooltip;
  document.getElementById('elementalForgeActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Elemental Forge</div>'); 
  document.getElementById('elementalForgeActionIcon').onmouseleave = hideTooltip;
  document.getElementById('fishingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Fishing Areas</div>');
  document.getElementById('fishingActionIcon').onmouseleave = hideTooltip;
  // +++ NEW BOUNTY TOOLTIP +++
  document.getElementById('huntingBoardActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Hunting Board</div>Take on bounties');
  document.getElementById('huntingBoardActionIcon').onmouseleave = hideTooltip;

  // --- Hub Lottery Listeners ---
  document.getElementById('lotteryActionIcon').onclick = openLotteryHub;
  document.getElementById('buyTicketBtn').onclick = buyLotteryTicket;
  document.getElementById('hubLottery_ReturnBtn').onclick = backToActions;
  document.getElementById('lotteryActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Lottery</div>Win Rare Prizes!');
  document.getElementById('lotteryActionIcon').onmouseleave = hideTooltip;
  if (!hubScreenIds.includes('hubLottery')) hubScreenIds.push('hubLottery');
  
// --- Tooltips for Hub Crystal Mine ---
  document.getElementById('earthCrystalBtn').onmouseenter = (e) => {
      const isLowLvl = game.mining.level < EARTH_CRYSTAL_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Earth Crystal</div><div style="color:${textColor};">Requires Mining Lvl: ${EARTH_CRYSTAL_LVL}</div>Tool: Iron Pickaxe`);
  };
  document.getElementById('earthCrystalBtn').onmouseleave = hideTooltip;
  
  document.getElementById('airCrystalBtn').onmouseenter = (e) => {
      const isLowLvl = game.mining.level < AIR_CRYSTAL_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Air Crystal</div><div style="color:${textColor};">Requires Mining Lvl: ${AIR_CRYSTAL_LVL}</div>Tool: Iron Pickaxe`);
  };
  document.getElementById('airCrystalBtn').onmouseleave = hideTooltip;
  
  document.getElementById('waterCrystalBtn').onmouseenter = (e) => {
      const isLowLvl = game.mining.level < WATER_CRYSTAL_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Water Crystal</div><div style="color:${textColor};">Requires Mining Lvl: ${WATER_CRYSTAL_LVL}</div>Tool: Iron Pickaxe`);
  };
  document.getElementById('waterCrystalBtn').onmouseleave = hideTooltip;

  // --- Tooltips for Hub Mine ---
  
  // New Sand Vein Logic
  document.getElementById('sandVeinBtn').onclick = openSandMine;
  document.getElementById('sandVeinBtn').onmouseenter = (e) => {
      showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Sand</div><div style="color:#fff;">Requires Mining Lvl: 1</div>Tool: Bronze Pickaxe');
  };
  document.getElementById('sandVeinBtn').onmouseleave = hideTooltip;

  document.getElementById('copperVeinBtn').onmouseenter = (e) => {
      // Level 1 is always unlocked, so always white
      showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Copper Vein</div><div style="color:#fff;">Requires Mining Lvl: 1</div>Tool: Bronze Pickaxe');
  };
  document.getElementById('copperVeinBtn').onmouseleave = hideTooltip;

  document.getElementById('ironVeinBtn').onmouseenter = (e) => {
    const isLowLvl = game.mining.level < IRON_MINE_LVL;
    const textColor = isLowLvl ? '#ff8888' : '#fff';
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Iron Vein</div><div style="color:${textColor};">Requires Mining Lvl: ${IRON_MINE_LVL}</div>Tool: Copper Pickaxe`;
    showTooltip(e, tt);
  };
  document.getElementById('ironVeinBtn').onmouseleave = hideTooltip;
  
  document.getElementById('coalVeinBtn').onmouseenter = (e) => {
    const isLowLvl = game.mining.level < COAL_MINE_LVL;
    const textColor = isLowLvl ? '#ff8888' : '#fff';
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Coal Vein</div><div style="color:${textColor};">Requires Mining Lvl: ${COAL_MINE_LVL}</div>Tool: Copper Pickaxe`;
    showTooltip(e, tt);
  };
  document.getElementById('coalVeinBtn').onmouseleave = hideTooltip;
  
  // --- Tooltips for Hub Forest ---
  document.getElementById('softwoodTreeBtn').onmouseenter = (e) => {
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Softwood Tree</div><div style="color:#fff;">Requires Woodcutting Lvl: ${SOFTWOOD_TREE_LVL}</div>`);
  };
  document.getElementById('softwoodTreeBtn').onmouseleave = hideTooltip;

  document.getElementById('oakTreeBtn').onmouseenter = (e) => {
      const isLowLvl = game.woodcutting.level < OAK_TREE_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Oak Tree</div><div style="color:${textColor};">Requires Woodcutting Lvl: ${OAK_TREE_LVL}</div>`);
  };
  document.getElementById('oakTreeBtn').onmouseleave = hideTooltip;

  // --- Tooltips for Hub Kitchen ---
  
  // Chicken (Level 1)
  document.getElementById('cookChickenBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cooked Chicken</div>Requires: 1 Raw Chicken<br><div style="color:#fff;">Requires Cooking Lvl: 1</div>');
  document.getElementById('cookChickenBtn').onmouseleave = hideTooltip;

  // Beef (Level 1 - Updated to include requirement text)
  document.getElementById('cookBeefBtn').onmouseenter = (e) => {
      const isLowLvl = game.cooking.level < COOK_BEEF_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cooked Beef</div>Requires: 1 Beef<br><div style="color:${textColor};">Requires Cooking Lvl: ${COOK_BEEF_LVL}</div>`);
  };
  document.getElementById('cookBeefBtn').onmouseleave = hideTooltip;
  
  // Herring (Updated text)
  document.getElementById('cookHerringBtn').onmouseenter = (e) => {
      const isLowLvl = game.cooking.level < COOK_HERRING_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cooked Herring</div>Requires: 1 Herring<br><div style="color:${textColor};">Requires Cooking Lvl: ${COOK_HERRING_LVL}</div>`);
  };
  document.getElementById('cookHerringBtn').onmouseleave = hideTooltip;
  
  // Trout (Updated text)
  document.getElementById('cookTroutBtn').onmouseenter = (e) => {
    const isLowLvl = game.cooking.level < COOK_TROUT_LVL;
    const textColor = isLowLvl ? '#ff8888' : '#fff';
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cooked Trout</div>Requires: 1 Trout<br><div style="color:${textColor};">Requires Cooking Lvl: ${COOK_TROUT_LVL}</div>`;
    showTooltip(e, tt);
    document.getElementById('cookTroutBtn').classList.toggle('locked-item', isLowLvl);
  };
  document.getElementById('cookTroutBtn').onmouseleave = hideTooltip;
  
  // Salmon (Updated text)
  document.getElementById('cookSalmonBtn').onmouseenter = (e) => {
    const isLowLvl = game.cooking.level < COOK_SALMON_LVL;
    const textColor = isLowLvl ? '#ff8888' : '#fff';
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cooked Salmon</div>Requires: 1 Salmon<br><div style="color:${textColor};">Requires Cooking Lvl: ${COOK_SALMON_LVL}</div>`;
    showTooltip(e, tt);
    document.getElementById('cookSalmonBtn').classList.toggle('locked-item', isLowLvl);
  };
  document.getElementById('cookSalmonBtn').onmouseleave = hideTooltip;


  // --- Tooltips for Hub Combat ---
  document.getElementById('farmAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Farm</div>');
  document.getElementById('farmAreaBtn').onmouseleave = hideTooltip;
  document.getElementById('caveAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Cave</div>'); 
  document.getElementById('caveAreaBtn').onmouseleave = hideTooltip; 
  
  // --- Tooltips for Hub Fishing ---
  document.getElementById('oceanAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Ocean</div>');
  document.getElementById('oceanAreaBtn').onmouseleave = hideTooltip;
  document.getElementById('riverAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The River</div>');
  document.getElementById('riverAreaBtn').onmouseleave = hideTooltip;
  
  // --- Tooltips for Fishing Spots ---
  document.getElementById('fishHerringBtn').onmouseenter = (e) => {
      const isLowLvl = game.fishing.level < HERRING_FISH_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Herring</div><div style="color:${textColor};">Requires Fishing Lvl: ${HERRING_FISH_LVL}</div>`);
  };
  document.getElementById('fishHerringBtn').onmouseleave = hideTooltip;

  document.getElementById('fishTroutBtn').onmouseenter = (e) => {
      const isLowLvl = game.fishing.level < TROUT_FISH_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Trout</div><div style="color:${textColor};">Requires Fishing Lvl: ${TROUT_FISH_LVL}</div>`);
  };
  document.getElementById('fishTroutBtn').onmouseleave = hideTooltip;

  document.getElementById('fishSalmonBtn').onmouseenter = (e) => {
      const isLowLvl = game.fishing.level < SALMON_FISH_LVL;
      const textColor = isLowLvl ? '#ff8888' : '#fff';
      showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Salmon</div><div style="color:${textColor};">Requires Fishing Lvl: ${SALMON_FISH_LVL}</div>`);
  };
  document.getElementById('fishSalmonBtn').onmouseleave = hideTooltip;

  // +++ END NEW LISTENER BLOCK +++
  
  
  // preloadAllGameAssets(); // <-- This line should already be here
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
  
  // --- NEW: Prevent Right-Click Menu ---
  // This listens for the 'contextmenu' event (right-click) on the entire page
  // and stops the browser from showing its default menu.
  document.addEventListener('contextmenu', (e) => {
    e.preventDefault(); 
  });
  // --- END NEW ---
  
  const inventoryGrid = document.getElementById('inventoryGrid');
  const inventoryGridWrap = document.getElementById('inventoryGridWrap');
  const bankGridWrap = document.getElementById('bankGridWrap'); // <-- ADD THIS
  let draggedItemIndex = null;
  let currentDragOverSlot = null;
  let draggedShopItem = null; // <-- ADD THIS
  
if (inventoryGridWrap) {
  inventoryGridWrap.addEventListener('dragover', (e) => {
    // Only scroll if we are actively dragging an item
    if (!game.isDragging) return;

    // We must prevent default for dragover to work
    e.preventDefault(); 

    const rect = inventoryGridWrap.getBoundingClientRect();
    const clientY = e.clientY;

    const scrollSpeed = 10; // Pixels to scroll per frame
    const threshold = 50;   // 50px trigger zone from the edge

    const topThreshold = rect.top + threshold;
    const bottomThreshold = rect.bottom - threshold;

    // --- This is the inventory scroll logic ---
    if (clientY < topThreshold) {
      // Mouse is near the top, scroll up
      inventoryGridWrap.scrollTop -= scrollSpeed;
    } else if (clientY > bottomThreshold) {
      // Mouse is near the bottom, scroll down
      inventoryGridWrap.scrollTop += scrollSpeed;
    }
  });
}

// --- This is the new bank scroll logic (placed *after*) ---
if (bankGridWrap) {
  bankGridWrap.addEventListener('dragover', (e) => {
    // Only scroll if we are actively dragging an item
    if (!game.isDragging) return;

    // We must prevent default for dragover to work
    e.preventDefault(); 

    const rect = bankGridWrap.getBoundingClientRect();
    const clientY = e.clientY;

    const scrollSpeed = 10; // Pixels to scroll per frame
    const threshold = 50;   // 50px trigger zone from the edge

    const topThreshold = rect.top + threshold;
    const bottomThreshold = rect.bottom - threshold;

    if (clientY < topThreshold) {
      // Mouse is near the top, scroll up
      bankGridWrap.scrollTop -= scrollSpeed;
    } else if (clientY > bottomThreshold) {
      // Mouse is near the bottom, scroll down
      bankGridWrap.scrollTop += scrollSpeed;
    }
  });
}

  inventoryGrid.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList.contains('inv-slot') && e.target.draggable) {
      draggedItemIndex = parseInt(e.target.dataset.slotIndex);
      e.dataTransfer.effectAllowed = 'move';
      
      // +++ NEW: Link to bank drag system +++
      const item = game.inventory[draggedItemIndex];
      if (item) {
        // Use the script-global draggedBankItem
        draggedBankItem = { item: { ...item }, fromIndex: draggedItemIndex };
      }
      // +++ END NEW +++

      // +++ NEW: Set dragging flag +++
      game.isDragging = true;
      
      setTimeout(() => {
        e.target.classList.add('dragging');
      }, 0);
    }
  });


  inventoryGrid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      if (currentDragOverSlot && currentDragOverSlot !== targetSlot) {
        currentDragOverSlot.classList.remove('drag-over');
      }
      targetSlot.classList.add('drag-over');
      currentDragOverSlot = targetSlot;
    }
  });
  
  inventoryGrid.addEventListener('dragleave', (e) => {
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      targetSlot.classList.remove('drag-over');
      if (currentDragOverSlot === targetSlot) {
        currentDragOverSlot = null;
      }
    }
  });

inventoryGrid.addEventListener('dragend', (e) => {
    // This event fires when the drag operation finishes, 
    // even if it's cancelled or dropped outside a valid target.
    
    // 1. Clean up the '.dragging' class
    const draggingEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    
    // 2. Clean up any lingering 'drag-over' styles
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    
    // 3. Reset all global drag state variables
    draggedItemIndex = null;
    draggedBankItem = null;
    draggedShopItem = null; // <-- ADD THIS
    game.isDragging = false;
  });

  inventoryGrid.addEventListener('drop', async (e) => {
    e.preventDefault();
    const dropSlot = e.target.closest('.inv-slot');
    
    // Cleanup first
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging'); // <-- FIX: Check ALL dragging
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }

    if (!dropSlot) {
      draggedItemIndex = null;
      draggedBankItem = null;
      draggedShopItem = null; // <-- ADD
      game.isDragging = false;
      return;
    }
    
    const dropIndex = parseInt(dropSlot.dataset.slotIndex);

    // +++ NEW: Check for Shop Drag +++
    if (draggedShopItem) {
      // This is a BUY action
      await buyShopItem(draggedShopItem.name, draggedShopItem.price);

    } else if (draggedBankItem && draggedBankItem.source === 'bank') {
    // +++ END NEW +++

      // --- BANK -> INVENTORY (Withdrawal) ---
      await dragWithdrawItem(draggedBankItem.fromIndex, dropIndex);

    } else if (draggedItemIndex !== null) {
      // --- INVENTORY -> INVENTORY (Internal Move) ---
      const fromIndex = draggedItemIndex;
      const toIndex = dropIndex;
      
      if (fromIndex !== toIndex) { 
        
        // --- Get the item data *before* the prompt ---
        const dragItemBeforePrompt = game.inventory[fromIndex];
        const dropItem = game.inventory[toIndex];

        // --- MODIFIED: Handle Shift-Click to move specific amount ---
        if (e.shiftKey && dragItemBeforePrompt) { 
          
          if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
            await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
          } else {
            const input = await showGamePrompt(
              `Move ${dragItemBeforePrompt.name}`, 
              `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
              ""
            );
            
            // --- THIS IS THE FIX ---
            // After the prompt (await) is done, we re-check the inventory
            
            if (input === null) { 
              // User cancelled
              const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
              if (originalSlotEl) originalSlotEl.classList.remove('dragging');
              
            } else {
              // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
              const itemAfterPrompt = game.inventory[fromIndex];
              
              // Check if the item was consumed or changed
              if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
                // The item was consumed! Abort the action.
                draggedItemIndex = null;
                draggedBankItem = null;
                game.isDragging = false;
                return; // Safely exit
              }
              // --- END EXPLOIT FIX ---
            
              const splitAmount = parseInt(input);
              
              if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid number */ }
              
              // Use the most up-to-date quantity
              else if (splitAmount > itemAfterPrompt.qty) { 
                await showGameAlert("Invalid Amount", "You don't have that many.");
              } 
              
              else if (splitAmount === itemAfterPrompt.qty) { 
                // Full stack move
                if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                    dropItem.qty += itemAfterPrompt.qty;
                    game.inventory[fromIndex] = null;
                } else {
                    game.inventory[fromIndex] = dropItem;
                    game.inventory[toIndex] = itemAfterPrompt;
                }
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
              
              else {
                // This is a valid SPLIT
                if (dropItem) { 
                  dropItem.qty += splitAmount;
                } else { 
                  game.inventory[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
                }
                itemAfterPrompt.qty -= splitAmount; // Use the validated item
                
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
            }
          }
        } else {
          // --- This is the ORIGINAL Swap/Stack logic ---
          // We must re-get the dragItem in case it was consumed
          const dragItem = game.inventory[fromIndex]; 
          if (dragItem && dropItem && dragItem.name === dropItem.name) {
              dropItem.qty += dragItem.qty;
              game.inventory[fromIndex] = null;
          } else {
              game.inventory[fromIndex] = dropItem;
              game.inventory[toIndex] = dragItem;
          }
          renderInventoryGrid();
          if (typeof window.savePlayerData === 'function') savePlayerData();
        }
      }
    }
    
    // Final cleanup
    draggedItemIndex = null;
    draggedBankItem = null;
    draggedShopItem = null; // <-- ADD
    game.isDragging = false;
  });
  
  // --- NEW: Settings Modal Listeners ---
  const settingsBtn = document.getElementById('settingsBtn');
  const closeSettingsBtn = document.getElementById('closeSettingsBtn');

  // --- SFX ---
  const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
  const sfxMuteBtn = document.getElementById('sfxMuteBtn');

  // --- Music ---
  const musicVolumeSlider = document.getElementById('musicVolumeSlider');
  const musicMuteBtn = document.getElementById('musicMuteBtn');

  if (settingsBtn) settingsBtn.onclick = openSettings;
  if (closeSettingsBtn) closeSettingsBtn.onclick = closeSettings;

  // --- SFX Slider Listener ---
  if (sfxVolumeSlider) {
    sfxVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.sfxVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isSfxMuted) {
        game.settings.isSfxMuted = false;
        applySettingsUI();
      }
      saveSettings(); // Save on change
    });
  }

  // --- SFX Mute Listener ---
  if (sfxMuteBtn) {
    sfxMuteBtn.onclick = () => {
      game.settings.isSfxMuted = !game.settings.isSfxMuted;
      applySettingsUI(); // Update button text/slider state
      saveSettings(); // Save the new mute state
    };
  }

  // --- Music Slider Listener ---
  if (musicVolumeSlider) {
    musicVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.musicVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isMusicMuted) {
        game.settings.isMusicMuted = false;
        applySettingsUI();
      }
      updateMusicPlayerState(); // Update live music volume
      saveSettings(); // Save on change
    });
  }

  // --- Music Mute Listener ---
  if (musicMuteBtn) {
    musicMuteBtn.onclick = () => {
      game.settings.isMusicMuted = !game.settings.isMusicMuted;
      applySettingsUI(); // Update button text/slider state
      updateMusicPlayerState(); // Update live music volume/mute

      // --- This is a bonus fix for autoplay ---
      // If music isn't playing yet, this click will start it.
      if (!game.settings.isMusicMuted && musicPlayer.paused) {
          musicPlayer.play().then(() => {
            audioAutoplayBlocked = false; 
          }).catch(e => console.warn("Could not start music."));
      }
      // --- End bonus fix ---

      saveSettings(); // Save the new mute state
    };
  }

  // --- NEW: Global Button Click Sound ---
  document.body.addEventListener('click', (e) => {
    // This selector now captures:
    // 1. 'button' -> Standard buttons (Fight, Run, Return, etc.)
    // 2. '[id$="ActionIcon"]' -> Top Menu Icons
    // 3. '.quest-line-card' -> The Quest rectangles
    // 4. 'div[id$="Btn"]' -> Fish area buttons (they are divs, not real buttons)
    // 5. 'div[onclick^="openCombatInterface"]' -> Monster images (Chicken/Cow/Spider)
    const target = e.target.closest('button, [id$="ActionIcon"], .quest-line-card, div[id$="Btn"], div[onclick^="openCombatInterface"]');
    
    if (target) {
       // If it is a real HTML button, don't play sound if it's disabled
       if (target.tagName === 'BUTTON' && target.disabled) return;
       
       playGlobalSound('sounds/soundeffects/buttonsoundeffect.mp3');
    }
  });
  
});

window.showSaveIndicator = function() {
    const timerEl = document.getElementById('saveTimerText');
    if (timerEl) {
        timerEl.style.visibility = 'visible';
        // Hide the message after 2 seconds
        setTimeout(() => {
            timerEl.style.visibility = 'hidden';
        }, 2000);
    }
}

</script>

<div id="itemContextMenu"></div>


<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc,
    increment // <-- ADD THIS
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";

  // +++ NEW: Stub function for resetGameState +++
  // The real function is defined in the non-module script
  function stopCraftingBowString() {
    if (typeof window.stopCraftingBowString === 'function') {
      window.stopCraftingBowString();
    } else {
      game.craftingActive = false;
    }
  }
  
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // +++ --- NEW SESSION LOCK CONSTANTS & FUNCTIONS --- +++
  const LOCK_STALE_TIME_MS = 10000; // 10 seconds
  const LOCK_HEARTBEAT_MS = 999999999;  
  /**
   * (Helper) Gets the player doc ref.
   */
  function getPlayerRef() {
    const user = auth.currentUser;
    if (!user) return null;
    return doc(db, "players", user.uid);
  }

  /**
   * Shows the session lock overlay.
   */
  function showSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'flex';
  }
  
  /**
   * Hides the session lock overlay.
   */
  function hideSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'none';
  }

  /**
   * Starts the heartbeat to keep our session lock fresh.
   */
  // --- REPLACED WITH SIMPLIFIED FUNCTION (starting around line 802) ---
  /**
   * Starts the heartbeat to keep our session lock fresh.
   * NOTE: The active lock refresh logic is now solely handled by the 30s autosave
   * (or a separate manual save), so we only start a passive timer.
   */
  window.startSessionHeartbeat = function() {
    if (game.lockHeartbeat) return; // Already running
    
    // Use the extremely large interval, effectively making this timer passive.
    // The 30s autosave is now the only functional timer.
    game.lockHeartbeat = setInterval(() => {
        // This timer still runs, but the interval is so long it will rarely fire,
        // ensuring the 30s autosave is the primary write source.
    }, LOCK_HEARTBEAT_MS); 
  }

  /**
   * Stops the heartbeat.
   */
  window.stopSessionHeartbeat = function() {
    if (game.lockHeartbeat) {
      clearInterval(game.lockHeartbeat);
      game.lockHeartbeat = null;
    }
  }

  /**
   * Releases the session lock from Firebase.
   * @param {boolean} isAsync - If false, we can't wait for the update (e.g., closing tab).
   */
  window.releaseSessionLock = async function(isAsync = true) {
    stopSessionHeartbeat();
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    // We only release the lock if we are the one holding it.
    try {
      const promise = runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) return;
        const lock = snap.data().activeSession;
        if (lock && lock.id === game.sessionLockId) {
          transaction.update(playerRef, { activeSession: null });
        }
      });
      
      if (isAsync) {
        await promise;
      }
    } catch (e) {
      console.error("Failed to release lock:", e);
    }
  }
  
  /**
   * Tries to acquire the session lock using a transaction.
   * This is called when a lock is free or stale, or when user clicks "Take Control".
   */
  window.acquireSessionLock = async function() {
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    try {
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) throw new Error("Player doc does not exist.");
        
        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();
        
        // Check if a fresh lock is held by another session
        if (lock && lock.id !== game.sessionLockId && (now - lock.timestamp) < LOCK_STALE_TIME_MS) {
          throw new Error("Lock is still fresh and held by another session.");
        }
        
        // Lock is free, stale, or ours. Take it.
        const newLock = { id: game.sessionLockId, timestamp: now };
        transaction.update(playerRef, { activeSession: newLock });
      });
      
      // Success! We are now the active session.
      game.isSessionActive = true;
      
      // *** CRITICAL FIX ***: We no longer call startSessionHeartbeat() 
      // here to prevent the original 3s interval logic from running.
      // We rely purely on the 30s autosave for lock refresh.
      
      // startSessionHeartbeat(); <-- DELETE THIS LINE
      
      hideSessionLockOverlay();
      
    } catch (e) {
      console.error("Failed to acquire lock:", e.message);
      // We failed to get the lock, another tab must have beat us.
      // The onSnapshot listener will handle showing the overlay.
    }
  }
  // +++ --- END NEW SESSION LOCK FUNCTIONS --- +++


  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      
      // +++ NEW: Only the active session can save data +++
      if (!game.isSessionActive) return;
      
      const nameToSave = game.name || "";
      const inventoryToSave = [];
      // --- THIS IS THE FIX ---
      // This code was missing. It adds your inventory to the save file.
      game.inventory.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      // +++ NEW: Convert bank to save format +++
      const bankToSave = [];
      game.bank.forEach((item, index) => {
          if (item) {
              bankToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: inventoryToSave, 
        gold: game.gold,
        // +++ NEW +++
        bank: bankToSave,
        bankGold: game.bankGold,
        // +++ END NEW +++
        equipment: game.equipment, // <-- ADD THIS
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        blacksmith: {
          level: game.blacksmith.level,
          xp: game.blacksmith.xp,
          totalXP: game.blacksmith.totalXP
        },
        // +++ NEW ATTACK SAVE LOGIC +++
        attack: {
          level: game.attack.level,
          xp: game.attack.xp,
          totalXP: game.attack.totalXP
        },
        // +++ NEW STRENGTH AND DEFENCE SAVE LOGIC +++
        strength: {
          level: game.strength.level,
          xp: game.strength.xp,
          totalXP: game.strength.totalXP
        },
        defence: {
          level: game.defence.level,
          xp: game.defence.xp,
          totalXP: game.defence.totalXP
        },
        // +++ NEW VITALITY SAVE LOGIC +++
        vitality: {
          level: game.vitality.level,
          xp: game.vitality.xp,
          totalXP: game.vitality.totalXP
        },
        // +++ END NEW VITALITY SAVE LOGIC +++
        // +++ NEW COOKING SAVE LOGIC +++
        cooking: {
          level: game.cooking.level,
          xp: game.cooking.xp,
          totalXP: game.cooking.totalXP
        },
        // +++ NEW WOODCUTTING SAVE LOGIC +++
        woodcutting: {
          level: game.woodcutting.level,
          xp: game.woodcutting.xp,
          totalXP: game.woodcutting.totalXP
        },
        // +++ END NEW WOODCUTTING SAVE LOGIC +++
        // +++ NEW FLETCHING SAVE LOGIC +++
        fletching: {
          level: game.fletching.level,
          xp: game.fletching.xp,
          totalXP: game.fletching.totalXP
        },
        // +++ END NEW FLETCHING SAVE LOGIC +++
        
        // +++ NEW CRAFTING/RANGED SAVE LOGIC +++
        crafting: {
          level: game.crafting.level,
          xp: game.crafting.xp,
          totalXP: game.crafting.totalXP
        },
        ranged: {
          level: game.ranged.level,
          xp: game.ranged.xp,
          totalXP: game.ranged.totalXP
        },
        // +++ NEW MAGIC SAVE LOGIC +++
        magic: {
          level: game.magic.level,
          xp: game.magic.xp,
          totalXP: game.magic.totalXP
        },
        // +++ NEW FISHING SAVE LOGIC +++
        fishing: {
          level: game.fishing.level,
          xp: game.fishing.xp,
          totalXP: game.fishing.totalXP
        },
        stoneforging: {
          level: game.stoneforging.level,
          xp: game.stoneforging.xp,
          totalXP: game.stoneforging.totalXP
        },
        // +++ NEW BOUNTY SAVE +++
        bountyhunting: {
          level: game.bountyhunting.level,
          xp: game.bountyhunting.xp,
          totalXP: game.bountyhunting.totalXP
        },
        activeBounty: game.activeBounty || null,
        
        questLines: game.questLines, // +++ NEW: Save Quest Line Data +++
        // +++ END NEW SAVE LOGIC +++
        
        playerAttackStyle: game.playerAttackStyle, 
        autocastSpell: game.autocastSpell || null, // +++ NEW: Save the active spell +++
        updatedAt: new Date().toISOString()
        // We don't save activeSession here, that's handled by the lock functions
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
      
      // *** MODIFIED LINE ***
      if (typeof window.showSaveIndicator === 'function') {
        window.showSaveIndicator();
      }

    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- HEAVILY MODIFIED: loadPlayerDataAndStart (now handles session lock) ---
  async function loadPlayerDataAndStart(user) {
    try {
      if (playerDocListener) {
        playerDocListener();
        playerDocListener = null;
      }
      
      if (updatesListenerUnsubscribe) {
        updatesListenerUnsubscribe();
        updatesListenerUnsubscribe = null;
      }
      isUpdatesHistoryLoaded = false;

      const ref = doc(db, "players", user.uid);
      let isFirstLoad = true; 
      
      playerDocListener = onSnapshot(ref, (snap) => {
        
        if (!snap.exists()) {
          console.log("Player document doesn't exist, showing start screen.");
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return; 
        }

        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();

        // --- 1. SESSION LOCK LOGIC ---
        if (!lock || (now - lock.timestamp > LOCK_STALE_TIME_MS)) {
          // Lock is free or stale. Try to acquire it.
          // We only do this if we're not *already* the active session.
          if (!game.isSessionActive) {
            acquireSessionLock();
          }
        } else if (lock.id !== game.sessionLockId) {
          // Another tab has a fresh lock. We are INACTIVE.
          game.isSessionActive = false;
          stopSessionHeartbeat();
          showSessionLockOverlay();
          // Stop any local actions immediately
          stopMining();
          stopBlacksmithing();
          if (game.inTrade) closeTradeWindow();
        } else {
          // We have the lock. We are ACTIVE.
          game.isSessionActive = true;
          hideSessionLockOverlay();
        }

        // --- 2. DATA SYNC LOGIC ---
        
        // Ignore our own "echo" saves
        if (snap.metadata.hasPendingWrites) {
          return;
        }
        
        // If we are the active tab, AND we are busy (mining, dragging, etc.),
        // do not sync data. This prevents rollbacks.
        if (game.isSessionActive && (game.miningActive || game.blacksmithingActive || game.cookingActive || game.woodcuttingActive || game.fletchingActive || game.isDragging)) {
          return;
        }
        
        // If we are INACTIVE, OR we are ACTIVE and IDLE, sync the data.
        game.playerAttackStyle = data.playerAttackStyle || 'strength';
        
        // +++ NEW: Load Autocast Spell +++
        game.autocastSpell = data.autocastSpell || null;
        // Update the visual border on the spell icons immediately
        if (typeof renderSpellsPanel === 'function') renderSpellsPanel();
        // +++ END NEW +++
        
        // +++ NEW: Load Equipment +++
        game.equipment = data.equipment || { helmet: null, chest: null, weapon: null, boots: null };
        renderEquipment(); // <-- Render the equipment on load
        // +++ END NEW +++

        if (!data.name) {
          // This handles the case right after registration
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return;
        }

        game.name = data.name || game.name || "Adventurer";
        game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
        game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
        
        let loadedInventoryData = data.inventory || [];
        game.inventory = new Array(game.inventoryCapacity).fill(null);
        if (Array.isArray(loadedInventoryData)) {
            if (loadedInventoryData.length > 0 && typeof loadedInventoryData[0].slot === 'number') {
                loadedInventoryData.forEach(item => {
                    if (item && typeof item.slot === 'number' && item.slot < game.inventoryCapacity) {
                        game.inventory[item.slot] = { name: item.name, qty: item.qty };
                    }
                });
            } else if (loadedInventoryData.length > 0) {
                console.log("Migrating (buggy) array inventory...");
                for (let i = 0; i < loadedInventoryData.length && i < game.inventoryCapacity; i++) {
                    if(loadedInventoryData[i]) {
                      game.inventory[i] = { name: loadedInventoryData[i].name, qty: loadedInventoryData[i].qty };
                    }
                }
            }
        } else {
            console.log("Migrating legacy (object) inventory...");
            const entries = Object.entries(loadedInventoryData);
            for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
                game.inventory[i] = { name: entries[i][0], qty: entries[i][1] };
            }
        }
        
        game.gold = (typeof data.gold === 'number') ? data.gold : 0; 
        
        // +++ NEW: Load Bank Data +++
        game.bankGold = (typeof data.bankGold === 'number') ? data.bankGold : 0;
        game.questLines = data.questLines || {}; // +++ NEW: Load Quest Line Data +++
        let loadedBankData = data.bank || [];
        game.bank = new Array(game.bankCapacity).fill(null);
        if (Array.isArray(loadedBankData)) {
            loadedBankData.forEach(item => {
                if (item && typeof item.slot === 'number' && item.slot < game.bankCapacity) {
                    game.bank[item.slot] = { name: item.name, qty: item.qty };
                }
            });
        }
        // +++ END NEW +++
        
        if (data.mining) {
          game.mining.level = data.mining.level || 1;
          game.mining.xp = data.mining.xp || 0;
          game.mining.totalXP = data.mining.totalXP || getTotalXPForLevel(data.mining.level - 1) + data.mining.xp || 0; 
        } else {
          game.mining = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        if (data.blacksmith) {
          game.blacksmith.level = data.blacksmith.level || 1;
          game.blacksmith.xp = data.blacksmith.xp || 0;
          game.blacksmith.totalXP = data.blacksmith.totalXP || getTotalXPForLevel(data.blacksmith.level - 1) + data.blacksmith.xp || 0; 
        } else {
          game.blacksmith = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW ATTACK LOADING LOGIC +++
        if (data.attack) {
          game.attack.level = data.attack.level || 1;
          game.attack.xp = data.attack.xp || 0;
          game.attack.totalXP = data.attack.totalXP || getTotalXPForLevel(data.attack.level - 1) + data.attack.xp || 0; 
        } else {
          game.attack = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW ATTACK LOADING LOGIC +++
        
        // +++ NEW STRENGTH LOADING LOGIC +++
        if (data.strength) {
          game.strength.level = data.strength.level || 1;
          game.strength.xp = data.strength.xp || 0;
          game.strength.totalXP = data.strength.totalXP || getTotalXPForLevel(data.strength.level - 1) + data.strength.xp || 0; 
        } else {
          game.strength = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW STRENGTH LOADING LOGIC +++
        
        // +++ NEW DEFENCE LOADING LOGIC +++
        if (data.defence) {
          game.defence.level = data.defence.level || 1;
          game.defence.xp = data.defence.xp || 0;
          game.defence.totalXP = data.defence.totalXP || getTotalXPForLevel(data.defence.level - 1) + data.defence.xp || 0; 
        } else {
          game.defence = { level: 1, xp: 0, totalXP: 0 }; 
        }
        //
        //

        // +++ NEW VITALITY LOADING LOGIC +++
        if (data.vitality) {
          game.vitality.level = data.vitality.level || 1;
          game.vitality.xp = data.vitality.xp || 0;
          game.vitality.totalXP = data.vitality.totalXP || getTotalXPForLevel(data.vitality.level - 1) + data.vitality.xp || 0; 
        } else {
          game.vitality = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW COOKING LOADING LOGIC +++
        if (data.cooking) {
          game.cooking.level = data.cooking.level || 1;
          game.cooking.xp = data.cooking.xp || 0;
          game.cooking.totalXP = data.cooking.totalXP || getTotalXPForLevel(data.cooking.level - 1) + data.cooking.xp || 0; 
        } else {
          game.cooking = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW WOODCUTTING LOADING LOGIC +++
        if (data.woodcutting) {
          game.woodcutting.level = data.woodcutting.level || 1;
          game.woodcutting.xp = data.woodcutting.xp || 0;
          game.woodcutting.totalXP = data.woodcutting.totalXP || getTotalXPForLevel(data.woodcutting.level - 1) + data.woodcutting.xp || 0; 
        } else {
          game.woodcutting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW WOODCUTTING LOADING LOGIC +++
        
        // +++ NEW FLETCHING LOADING LOGIC +++
        if (data.fletching) {
          game.fletching.level = data.fletching.level || 1;
          game.fletching.xp = data.fletching.xp || 0;
          game.fletching.totalXP = data.fletching.totalXP || getTotalXPForLevel(data.fletching.level - 1) + data.fletching.xp || 0; 
        } else {
          game.fletching = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW FLETCHING LOADING LOGIC +++
        
        // +++ NEW CRAFTING LOADING LOGIC +++
        if (data.crafting) {
          game.crafting.level = data.crafting.level || 1;
          game.crafting.xp = data.crafting.xp || 0;
          game.crafting.totalXP = data.crafting.totalXP || getTotalXPForLevel(data.crafting.level - 1) + data.crafting.xp || 0; 
        } else {
          game.crafting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW CRAFTING LOADING LOGIC +++
        
        // +++ NEW RANGED LOADING LOGIC +++
        if (data.ranged) {
          game.ranged.level = data.ranged.level || 1;
          game.ranged.xp = data.ranged.xp || 0;
          game.ranged.totalXP = data.ranged.totalXP || getTotalXPForLevel(data.ranged.level - 1) + data.ranged.xp || 0; 
        } else {
          game.ranged = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW RANGED LOADING LOGIC +++
        
        // +++ NEW MAGIC LOADING LOGIC +++
        if (data.magic) {
          game.magic.level = data.magic.level || 1;
          game.magic.xp = data.magic.xp || 0;
          game.magic.totalXP = data.magic.totalXP || getTotalXPForLevel(data.magic.level - 1) + data.magic.xp || 0; 
        } else {
          game.magic = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW MAGIC LOADING LOGIC +++
        
        // +++ NEW FISHING LOADING LOGIC +++
        if (data.fishing) {
          game.fishing.level = data.fishing.level || 1;
          game.fishing.xp = data.fishing.xp || 0;
          game.fishing.totalXP = data.fishing.totalXP || getTotalXPForLevel(data.fishing.level - 1) + data.fishing.xp || 0; 
        } else {
          game.fishing = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW STONE FORGING LOADING LOGIC +++
        if (data.stoneforging) {
          game.stoneforging.level = data.stoneforging.level || 1;
          game.stoneforging.xp = data.stoneforging.xp || 0;
          game.stoneforging.totalXP = data.stoneforging.totalXP || getTotalXPForLevel(data.stoneforging.level - 1) + data.stoneforging.xp || 0; 
        } else {
          game.stoneforging = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW BOUNTY LOADING LOGIC +++
        if (data.bountyhunting) {
          game.bountyhunting.level = data.bountyhunting.level || 1;
          game.bountyhunting.xp = data.bountyhunting.xp || 0;
          game.bountyhunting.totalXP = data.bountyhunting.totalXP || getTotalXPForLevel(data.bountyhunting.level - 1) + data.bountyhunting.xp || 0; 
        } else {
          game.bountyhunting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        game.activeBounty = data.activeBounty || null;
        // +++ END NEW LOGIC +++

        setText('charName', game.name);
        updateHPUI(); // This now calculates maxHP using game.vitality.level
        renderInventoryGrid();
        updateSkillUI();
        updateGoldUI(); 
        
        // +++ NEW: Pre-render the bank UI on load +++
        renderBankGrid();
        updateBankGoldUI();
        // +++ END NEW +++

        // +++ NEW: Pre-render the Shop UI on load +++
        renderShopGrid();
        // +++ END NEW +++
        
        if (isFirstLoad) {
          window.renderLeaderboards(); 
          isFirstLoad = false;         
          backToActions(); 
        }
        
        startScreen.style.display = 'none';
        authScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        loadSettings();
        startMusicPlaylist();

      }, async (error) => { // <-- Add 'async' here
        console.error("Player listener error:", error);
        await showGameAlert("Load Error", "Error loading player data. Please refresh the page.");
      });
      
      const initialSnap = await getDoc(ref);
      if (!initialSnap.exists() || !initialSnap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false; 
      }

      return true; 
      
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }

  // --- MODIFIED: Added activeSession to new doc ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: [],
        gold: 100, 
        // +++ NEW +++
        bank: [],
        bankGold: 0,
        // +++ END NEW +++
        equipment: { helmet: null, chest: null, weapon: null, boots: null },
        mining: { level: 1, xp: 0, totalXP: 0 },
        blacksmith: { level: 1, xp: 0, totalXP: 0 }, 
        attack: { level: 1, xp: 0, totalXP: 0 }, 
        strength: { level: 1, xp: 0, totalXP: 0 }, 
        defence: { level: 1, xp: 0, totalXP: 0 }, 
        vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY FOR NEW ACCOUNTS +++
        cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING FOR NEW ACCOUNTS +++
        woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING FOR NEW ACCOUNTS +++
        fletching: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW FLETCHING FOR NEW ACCOUNTS +++
        
        // +++ NEW SKILLS FOR NEW ACCOUNTS +++
        crafting: { level: 1, xp: 0, totalXP: 0 },
        ranged: { level: 1, xp: 0, totalXP: 0 },
        fishing: { level: 1, xp: 0, totalXP: 0 },
        stoneforging: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW +++
        magic: { level: 1, xp: 0, totalXP: 0 }, 
        
        playerAttackStyle: 'strength',
        activeSession: null, // +++ ADD THIS
        createdAt: new Date().toISOString()
      });
      await showGameAlert("Account Created", "Your account has been created. You must now create your character.");
    } catch (err) {
      await showGameAlert("Registration Failed", err.message || "An unknown error occurred during registration.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      await showGameAlert("Login Failed", err.message || "An unknown error occurred during login.");
      console.error(err);
    }
  };

  // --- MODIFIED: Handles session cleanup ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();

      const started = await loadPlayerDataAndStart(user);
      
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
        game.playerAttackStyle = 'strength';
      }
      
      if (started) {
        initChatListener();
        initTradeListeners();
        initUpdatesListener();
        initBroadcastListener(); // +++ ADD THIS LINE +++
        // The loadPlayerDataAndStart listener will automatically handle
        // acquiring the lock on first load.
      } else {
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // User is logged out
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      
      // Stop listeners and release lock
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();
      if (updatesListenerUnsubscribe) updatesListenerUnsubscribe();
      if (broadcastListenerUnsubscribe) broadcastListenerUnsubscribe(); // +++ ADD THIS LINE +++
      isUpdatesHistoryLoaded = false;
      stopSessionHeartbeat();
      // We don't release the lock, just let it go stale.
      
      if (window.resetGameState) {
        window.resetGameState();
      }
      isTradeRequestsLoaded = false; 
    }
  });

  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) { await showGameAlert("Error", "Please enter a name for your character."); return; }
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            { await showGameAlert("Name Taken", "That name is already taken. Please choose another."); return; }
          }
        } catch (e) {
          console.error("Name check failed:", e);
          { await showGameAlert("Error", "An error occurred while checking the name. Please try again."); return; }
        }
        
        originalCreate(); // Sets game.name locally
        
        const user = auth.currentUser;
        if (user) {
          // --- THIS IS THE FIX ---
          // We MUST acquire the session lock *before* trying to save,
          // otherwise savePlayerData() will exit early because
          // game.isSessionActive is false.
          if (typeof window.acquireSessionLock === 'function') {
            await window.acquireSessionLock();
          }

          game.isSessionActive = true;
         

          await window.savePlayerData(); // This will now succeed
          window.renderLeaderboards();
          initChatListener(); 
          initTradeListeners(); 
          initUpdatesListener(); 
          // The onSnapshot listener will fire and update the UI
        }
      };
    }
  })();
  
  // --- CHAT FUNCTIONS (Unchanged) ---
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false; 
  let playerDocListener = null; 
  let updatesListenerUnsubscribe = null;
  let isUpdatesHistoryLoaded = false; 
// +++ NEW BROADCAST LISTENER +++
  let broadcastListenerUnsubscribe = null;
  let lastBroadcastTimestamp = null;


  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;
    if (messageText.length === 0) return; 
    
    // +++ NEW: Prevent sending chat from inactive tab +++
    if (!game.isSessionActive) {
      await showGameAlert("Session Not Active", "This tab is not active. Take control to send messages.");
      return;
    }
    
    chatInput.value = '';
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; 
    }
    if (messageText.length > 256) {
      await showGameAlert("Error", "Your message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      await showGameAlert("Error", "You must be logged in and have a character to chat.");
      return;
    }
    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      await showGameAlert("Error", "Failed to send message. Please try again.");
    }
  }
  function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';
    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; 
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    chatMessagesContainer.prepend(msgElement); 
  }
  function formatUpdateTimestamp(timestamp) {
    if (!timestamp) return "Just now";
    const date = timestamp.toDate();
    // Formats to: 11/11/25
    return date.toLocaleString('en-US', {
      month: 'numeric',
      day: 'numeric',
      year: '2-digit'
    });
  }

  function addUpdateMessageToDOM(doc) {
    const contentContainer = document.getElementById('updatesContent');
    if (!contentContainer) return;

    const data = doc.data();
    const docId = doc.id;

    // --- FIX: Check if this update is already in the DOM ---
    if (document.getElementById(`update-${docId}`)) {
      return; // Already exists, do nothing
    }
    // --- END FIX ---

    const msgElement = document.createElement('div');
    msgElement.className = 'update-message';
    msgElement.id = `update-${docId}`; // --- NEW: Add unique ID ---
    
    const formattedDate = formatUpdateTimestamp(data.timestamp);
    
    // Create text nodes to prevent HTML injection from the update message
    const textNode = document.createTextNode(" " + data.text);
    const strongNode = document.createElement('strong');
    strongNode.textContent = `${formattedDate}:`;
    
    msgElement.appendChild(strongNode);
    msgElement.appendChild(textNode);
    
    // Add to the top of the list
    contentContainer.prepend(msgElement);
  }

  function initUpdatesListener() {
    if (updatesListenerUnsubscribe) {
      updatesListenerUnsubscribe();
      updatesListenerUnsubscribe = null;
    }
    const contentContainer = document.getElementById('updatesContent');
    if (!contentContainer) return;

    const q = query(
      collection(db, "updates"), 
      orderBy("timestamp", "asc"), // Get oldest first
      limitToLast(20) // But only the last 20
    );

    updatesListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      if (!isUpdatesHistoryLoaded) {
        // First load: clear "loading" and add all docs
        isUpdatesHistoryLoaded = true;
        contentContainer.innerHTML = '';
        // Prepend all docs so they end up in newest-first order
        querySnapshot.docs.forEach(doc => {
          addUpdateMessageToDOM(doc); // --- FIX: Pass whole doc ---
        });
      } else {
        // Subsequent loads: only add new ones
        querySnapshot.docChanges().forEach((change) => {
          // --- FIX: Show all new messages, including your own ---
          if (change.type === "added") {
            addUpdateMessageToDOM(change.doc); // --- FIX: Pass whole doc ---
          }
        });
      }

      // Prune old messages if we have more than 20
      while (contentContainer.childElementCount > 20) {
        contentContainer.lastChild.remove(); // Remove from the bottom
      }
      
    }, (error) => {
      console.error("Updates listener error: ", error);
      contentContainer.innerHTML = '<div style="color: red; text-align: center;">Error loading updates.</div>';
    });
  }

// +++ NEW: BROADCAST LISTENER (REVISED) +++
  function initBroadcastListener() {
    if (broadcastListenerUnsubscribe) {
      broadcastListenerUnsubscribe();
      broadcastListenerUnsubscribe = null;
    }

    const broadcastRef = doc(db, "system", "broadcast");

    broadcastListenerUnsubscribe = onSnapshot(broadcastRef, (doc) => {
      if (!doc.exists()) return; // No broadcast message set

      const data = doc.data();
      const message = data.message;
      const timestamp = data.timestamp;

      // Ignore if the message has no timestamp
      if (!timestamp) return;

      // --- THIS IS THE NEW LOGIC ---
      if (lastBroadcastTimestamp === null) {
        // This is the FIRST time the listener is running on page load.
        // We will "prime" the system by storing the current timestamp,
        // but we will NOT show the overlay.
        lastBroadcastTimestamp = timestamp;
        return; // Exit without showing the pop-up
      }

      // If we are here, the listener has run at least once.
      // Now, we only proceed if the timestamp in Firestore is *different*
      // from the one we already saw.
      if (timestamp.toMillis() === lastBroadcastTimestamp.toMillis()) {
        // This is the same message we've already seen. Do nothing.
        return;
      }
      // --- END NEW LOGIC ---

      // If we get this far, it means:
      // 1. It's not the first page load check.
      // 2. The timestamp is NEW.
      // This is a genuine, real-time update.
      
      lastBroadcastTimestamp = timestamp; // Store the new timestamp

      const overlay = document.getElementById('broadcastOverlay');
      const messageEl = document.getElementById('broadcastMessage');

      if (overlay && messageEl) {
        messageEl.textContent = message;
        overlay.style.display = 'flex'; // Show the overlay
      }

    }, (error) => {
      console.error("Broadcast listener error: ", error);
    });
  }

  function initChatListener() {
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      let hasAdds = false; 
      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isChatHistoryLoaded) {
            hasAdds = true; 
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            
            // +++ NEW: Admin Color Check +++
            if (msg.senderUid === ADMIN_UID) {
              sender.style.color = '#ff4d4d'; // Admin Red
            } else {
              sender.style.color = 'var(--gold)'; // Default Gold
            }
            // +++ END NEW +++
            
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });
      if (!isChatHistoryLoaded) {
        isChatHistoryLoaded = true;
        let hadHistoryMessages = false;
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            
            // +++ NEW: Admin Color Check +++
            if (msg.senderUid === ADMIN_UID) {
              sender.style.color = '#ff4d4d'; // Admin Red
            } else {
              sender.style.color = 'var(--gold)'; // Default Gold
            }
            // +++ END NEW +++
            
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
        });
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; 
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      else if (hasAdds) {
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        chatMessagesContainer.scrollTop = 0;
      }
    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  
  // --- TRADE FUNCTIONS (Mostly Unchanged) ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; 
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    if (!isChatHistoryLoaded) {
      localMessageQueue.push({ text, type });
    } else {
      _addLocalMessageToDOM(text, type);
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      chatMessagesContainer.scrollTop = 0;
    }
  }
  function convertSavedInvToLocal(savedInvData) {
      const localInv = new Array(game.inventoryCapacity).fill(null);
      if (!Array.isArray(savedInvData)) {
          const entries = Object.entries(savedInvData);
          for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
              localInv[i] = { name: entries[i][0], qty: entries[i][1] };
          }
      } else {
          if (savedInvData.length > 0 && typeof savedInvData[0].slot === 'number') {
              savedInvData.forEach(item => {
                  if (item && item.slot < game.inventoryCapacity) {
                      localInv[item.slot] = { name: item.name, qty: item.qty };
                  }
              });
          } else if (savedInvData.length > 0) {
              for (let i = 0; i < savedInvData.length && i < game.inventoryCapacity; i++) {
                  if (savedInvData[i]) {
                      localInv[i] = { name: savedInvData[i].name, qty: savedInvData[i].qty };
                  }
              }
          }
      }
      return localInv;
  }
  function convertLocalInvToSaved(localInv) {
      const inventoryToSave = [];
      localInv.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      return inventoryToSave;
  }

  // =================================================================
  // --- 3. REPLACED 'checkItem' FUNCTION (module script) ---
  // This function now correctly SUMS all stacks.
  // =================================================================
  function checkItem(localInvArray, itemName, qty) {
      let totalQty = 0;
      for (const slot of localInvArray) {
          if (slot && slot.name === itemName) {
              totalQty += slot.qty;
          }
      }
      return totalQty >= qty;
  }

  // =================================================================
  // --- 4. REPLACED 'modifyInventory' FUNCTION (module script) ---
  // This function now correctly adds/removes from multiple stacks.
  // =================================================================
  function modifyInventory(localInvArray, itemName, qtyChange) {
      // Deep copy the array to avoid modifying the original
      const newInv = JSON.parse(JSON.stringify(localInvArray)); 
      
      if (qtyChange > 0) { // Adding items
          let amountToAdd = qtyChange;
          
          // 1. Try to stack first
          for (const slot of newInv) {
              if (slot && slot.name === itemName) {
                  slot.qty += amountToAdd;
                  amountToAdd = 0;
                  break; 
              }
          }
          
          // 2. If still items left, find an empty slot
          if (amountToAdd > 0) {
              let emptySlotIndex = newInv.findIndex(slot => slot === null);
              if (emptySlotIndex > -1) {
                  newInv[emptySlotIndex] = { name: itemName, qty: amountToAdd };
              } else {
                  // This should be caught by the transaction, but good to have
                  throw new Error(`Inventory full, cannot add ${itemName}.`);
              }
          }
      } else if (qtyChange < 0) { // Removing items
          let amountToRemove = Math.abs(qtyChange);
          
          // 1. Iterate backwards to empty smaller/later stacks first
          for (let i = newInv.length - 1; i >= 0; i--) {
              const slot = newInv[i];
              if (slot && slot.name === itemName) {
                  if (slot.qty > amountToRemove) {
                      // This stack has more than we need
                      slot.qty -= amountToRemove;
                      amountToRemove = 0;
                  } else {
                      // This stack will be emptied
                      amountToRemove -= slot.qty;
                      newInv[i] = null; // Empty the slot
                  }
              }
              if (amountToRemove === 0) break; // We're done
          }
          if (amountToRemove > 0) {
              // This should be impossible if checkItem was called first
              throw new Error(`Tried to remove more ${itemName} than available.`);
          }
      }
      return newInv;
  }
  // =================================================================
  // --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
  // =================================================================

  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);
            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addGold(amount); 
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self gold: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data(); // We still need this for the name
                await updateDoc(doc(db, "players", playerDoc.id), {
                    gold: increment(amount) // Use the atomic increment operation
                });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); 
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; 
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addItem(formattedName, qty); // Uses new addItem
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self item: ${e.message}`, 'error');
                }
                return true;
            }
            // This command now uses the NEW modifyInventory, so it will work
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                let currentLocalInv = convertSavedInvToLocal(playerData.inventory || []);
                const newLocalInv = modifyInventory(currentLocalInv, formattedName, qty); // Uses new modifyInventory
                const newSavedInv = convertLocalInvToSaved(newLocalInv);
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newSavedInv });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            // +++ NEW: Added 'crafting', 'ranged', 'fishing', 'magic' to admin command +++
            const validSkills = ['mining', 'blacksmith', 'attack', 'strength', 'defence', 'vitality', 'cooking', 'woodcutting', 'fletching', 'crafting', 'ranged', 'fishing', 'magic'];
if (!validSkills.includes(skill)) {
     addLocalChatMessage("Unknown skill.", 'error');
     return true;
}
            const newTotalXP = getTotalXPForLevel(level); 
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };
            if (targetName === game.name.toLowerCase()) {
                try {
                    game[skill] = newSkillData; 
                    updateSkillUI();
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Set own ${skill} level to ${level}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error setting self level: ${e.message}`, 'error');
                }
                return true;
            }
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { [skill]: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s ${skill} level to ${level}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
        
        // +++ NEW: Admin /update command +++
        if (command === 'update') {
            const messageText = args.join(' ');
            if (messageText.length === 0) {
                addLocalChatMessage("Usage: /update [message]", 'error');
                return true;
            }
            if (messageText.length > 512) {
              addLocalChatMessage("Error: Update message is too long (max 512 chars).", 'error');
              return true;
            }

            try {
              // Add to the new 'updates' collection
              await addDoc(collection(db, "updates"), {
                text: messageText,
                timestamp: serverTimestamp()
              });
              addLocalChatMessage("Update posted.", 'system');
            } catch (e) {
              console.error("Error posting update: ", e);
              addLocalChatMessage("Error posting update.", 'error');
            
            }
            return true;
        }

        // +++ NEW: Fix Quest Data Command +++
        if (command === 'fixquests') {
            // This manually resets the tutorial line to the correct state
            // Status: Foundation (Done), Chickens (Done), Fishing (Active)
            const newLineData = { 
                completed: ['tut_1', 'tut_2'], 
                activeQuestId: 'tut_2_fishing', 
                kills: 0 
            };
            
            // 1. Update Local State
            game.questLines['tutorial'] = newLineData;
            
            // 2. Force Save
            await window.savePlayerData();
            
            // 3. Refresh UI
            addLocalChatMessage("Quest line fixed: Fishing is active, Spider quest restored as completed.", 'system');
            return true;
        }

        // +++ NEW: Forget Quest Command (Smart Name Lookup) +++
        if (command === 'forget') {
            // Join args to allow spaces in names (e.g., "River Bounty")
            const inputName = args.join(' '); 
            
            if (!inputName) {
                addLocalChatMessage("Usage: /forget [Quest Name]", 'error');
                return true;
            }

            let targetId = inputName; // Default: assume user typed the ID
            let foundName = inputName;

            // 1. Try to find the ID by searching Quest Names first
            for (const lineId in QUEST_LINES) {
                const line = QUEST_LINES[lineId];
                // Case-insensitive check against quest names
                const match = line.quests.find(q => q.name.toLowerCase() === inputName.toLowerCase());
                if (match) {
                    targetId = match.id;
                    foundName = match.name;
                    break;
                }
            }

            let found = false;
            
            // 2. Remove from history using the ID we found (or the input)
            for (const lineId in game.questLines) {
                const lineData = game.questLines[lineId];
                
                if (lineData.completed && Array.isArray(lineData.completed)) {
                    const index = lineData.completed.indexOf(targetId);
                    
                    if (index > -1) {
                        // Remove from completed list
                        lineData.completed.splice(index, 1);
                        
                        // Reset active/kill state
                        lineData.activeQuestId = null; 
                        lineData.kills = 0;
                        
                        found = true;
                        addLocalChatMessage(`Admin: Forgot quest '${foundName}'. Re-open the quest tab to see changes.`, 'system');
                        break; 
                    }
                }
            }
            
            if (found) {
                await window.savePlayerData();
            } else {
                addLocalChatMessage(`Quest '${foundName}' not found in your completed history.`, 'error');
            }
            return true;
        }

        // +++ NEW: Admin /messageall command +++
        if (command === 'messageall') {
            const messageText = args.join(' ');
            if (messageText.length === 0) {
                addLocalChatMessage("Usage: /messageall [message]", 'error');
                return true;
            }
            if (messageText.length > 512) {
              addLocalChatMessage("Error: Message is too long (max 512 chars).", 'error');
              return true;
            }

            try {
              // Set the broadcast message
              await setDoc(doc(db, "system", "broadcast"), {
                message: messageText,
                timestamp: serverTimestamp()
              });
              addLocalChatMessage("Broadcast message sent.", 'system');
            } catch (e) {
              console.error("Error sending broadcast: ", e);
              addLocalChatMessage("Error sending broadcast.", 'error');
            }
            return true;
        }
        // +++ END NEW +++
    }
    
    // +++ NEW: Check for active session before allowing trade +++
    
    if (!game.isSessionActive) {
      addLocalChatMessage("This tab is not active. Take control to trade.", 'error');
      return true; // It's a command, but it's blocked.
    }

    if (messageText.startsWith('/trade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    if (messageText.startsWith('/accepttrade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    return false;
  }
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }
      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');
    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);
      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      const requestSnapshot = await getDocs(requestQuery);
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          return data.fromUid === requesterUid; 
      });
      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }
      const requestDoc = validRequests[0]; 
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      await batch.commit();
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); 
    tradeSessionUnsubscribes = []; 
    isTradeRequestsLoaded = false; 
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    // Trade requests are disabled due to maintenance.
    tradeRequestUnsubscribe = onSnapshot(requestQuery, () => {
      isTradeRequestsLoaded = true;
    }, (error) => console.error("Trade request listener error:", error));
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; 
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }
    if (game.blacksmithingActive) {
        stopBlacksmithing();
        game.wasMiningBeforeTrade = true; 
    }
    
    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    
    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    // --- THIS IS THE FIX ---
    // Use the session data to initialize the trade state
    game.myTradeOffer = sessionData[myRole];
    game.theirTradeOffer = sessionData[theirRole];
    // --- END FIX ---
    
    game.myTradeRole = myRole; 

    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    
    // Set the gold input to the *correct* initial value
    document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
    document.getElementById('tradeMyGoldOffer').max = game.gold;
    
    renderTradeInventory(); 
    // Render the grids with the data we just loaded
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); 
    renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems); 
    modal.style.display = 'flex'; 
    if (game.activeTradeListener) game.activeTradeListener(); 
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      const data = doc.data();
      if (data.status === 'cancelled') {
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      if (data.status === 'completed') {
        addLocalChatMessage("Trade complete!", 'trade');
        closeTradeWindow();
        return;
      }
      // --- THIS IS THE FIX ---
      // ONLY update THEIR offer from the snapshot
      game.theirTradeOffer = data[theirRole];
      
      // Manually sync our own "accepted" status
      // This is the ONLY part of our offer we want from the server
      game.myTradeOffer.accepted = data[myRole].accepted;

      // Render THEIR grid (our grid is updated locally)
      // We also update our inventory to show correct available amounts
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      renderTradeInventory();
      
      // We no longer need to check if we're typing, because we are
      // no longer syncing our own gold value from the server.
      
      // ONLY set THEIR gold display
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // Update statuses for both
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);
      // --- END FIX ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';

    // --- Create a map of available items from all stacks ---
    const availableItems = new Map();
    for (const slot of game.inventory) {
        if (slot) {
            const currentQty = availableItems.get(slot.name) || 0;
            availableItems.set(slot.name, currentQty + slot.qty);
        }
    }
    
    // --- Subtract offered items ---
    for (const [name, qty] of Object.entries(game.myTradeOffer.offerItems)) {
        if (availableItems.has(name)) {
            availableItems.set(name, availableItems.get(name) - qty);
        }
    }

    // --- Render the grid based on the calculated map ---
    availableItems.forEach((qtyAvailable, name) => {
      if (qtyAvailable <= 0) return; 

      const slotEl = document.createElement('div');
      slotEl.className = 'inv-slot';
      slotEl.onclick = () => addItemToOffer(name, qtyAvailable); 
      let imgName = name.toLowerCase().replace(/\s+/g,'_');
      if (name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      const img = document.createElement('img');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slotEl.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slotEl.appendChild(amt);
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slotEl.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slotEl.onmouseleave = hideTooltip;
      grid.appendChild(slotEl);
    });
  }
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    const itemEntries = Object.entries(items);
    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        const img = document.createElement('img');
        let imgName = name.toLowerCase().replace(/\s+/g,'_');
        if (name === 'Copper Bar') {
            imgName = 'copperbar';
        }
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }
  async function addItemToOffer(itemName, maxQty) {
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      // --- MODIFICATION HERE ---
      const input = await window.showGamePrompt( // Use window.showGamePrompt
        `Offer ${itemName}`,
        `How many ${itemName} do you want to offer? (Max: ${maxQty})`, 
        maxQty
      );
      if (input === null) return; 
      qtyToOffer = parseInt(input);
      // --- END MODIFICATION ---
    }
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      await window.showGameAlert("Invalid Amount", `You can only offer up to ${maxQty} of this item.`); // Use window.showGameAlert
      qtyToOffer = maxQty;
    }
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      await window.showGameAlert("Trade Full", "Your trade offer grid is full (16 unique items)."); // Use window.showGameAlert
      return;
    }
    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    game.myTradeOffer = newOfferObject;
    
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 

    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; 
    delete newOfferItems[itemName]; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 2. Update local UI IMMEDIATELY
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 
    // --- END FIX ---

    try {
      // 3. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    // --- END FIX ---

    try {
      // 2. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true 
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }
  async function cancelTrade() {
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;
    const sessionId = game.activeTradeSessionId;
    closeTradeWindow(); 
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
      }
    }
  }
  function closeTradeWindow() {
    if (!game.inTrade) return; 
    if (game.activeTradeListener) {
      game.activeTradeListener(); 
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; 
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    renderInventoryGrid();
    updateGoldUI();
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      const startBtn = document.getElementById('startMineBtn');
      const startSmithBtn = document.getElementById('startSmithBtn');
      if (startBtn) {
        startMining();
      } else if (startSmithBtn) { 
        startBlacksmithing();
      }
    }
  }
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);
        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }
        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;
        const p1LocalInv = convertSavedInvToLocal(p1Data.inventory || []);
        const p2LocalInv = convertSavedInvToLocal(p2Data.inventory || []);
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!checkItem(p1LocalInv, item, qty)) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!checkItem(p2LocalInv, item, qty)) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }

        let newP1LocalInv = [...p1LocalInv];
        let newP2LocalInv = [...p2LocalInv];

        // --- These loops now use the NEW 'modifyInventory' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
            newP1LocalInv = modifyInventory(newP1LocalInv, item, -qty);
            newP2LocalInv = modifyInventory(newP2LocalInv, item, +qty);
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
            newP2LocalInv = modifyInventory(newP2LocalInv, item, -qty);
            newP1LocalInv = modifyInventory(newP1LocalInv, item, +qty);
        }
        // --- End of new function usage ---

        const newP1SavedInv = convertLocalInvToSaved(newP1LocalInv);
        const newP2SavedInv = convertLocalInvToSaved(newP2LocalInv);
        transaction.update(sessionRef, { status: 'completed' });
        transaction.update(player1Ref, {
            gold: p1Data.gold - p1Offer.offerGold + p2Offer.offerGold,
            inventory: newP1SavedInv
        });
        transaction.update(player2Ref, {
            gold: p2Data.gold - p2Offer.offerGold + p1Offer.offerGold,
            inventory: newP2SavedInv
        });
      });
    } catch (e) {
      console.error("TRADE FAILED:", e);
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    
    // --- FIX: Remove the line that clears innerHTML to prevent flash ---
    // contentContainer.innerHTML = `...`; // <-- THIS LINE IS DELETED
    
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        
        // --- THIS IS THE FIX ---
        // We now get the totalXP from *all* skills and add them together.
        const miningXp = data.mining?.totalXP || 0; 
        const blacksmithXp = data.blacksmith?.totalXP || 0;
        const attackXp = data.attack?.totalXP || 0;
        const strengthXp = data.strength?.totalXP || 0;
        const defenceXp = data.defence?.totalXP || 0;
        const vitalityXp = data.vitality?.totalXP || 0;
        const cookingXp = data.cooking?.totalXP || 0;
        const woodcuttingXp = data.woodcutting?.totalXP || 0; // +++ NEW +++
        const fletchingXp = data.fletching?.totalXP || 0; // +++ NEW +++
        const craftingXp = data.crafting?.totalXP || 0; // +++ NEW +++
        const rangedXp = data.ranged?.totalXP || 0; 
        const fishingXp = data.fishing?.totalXP || 0; 
        const magicXp = data.magic?.totalXP || 0; 
        const stoneforgingXp = data.stoneforging?.totalXP || 0; // +++ NEW +++

        const totalXp = miningXp + blacksmithXp + attackXp + strengthXp + defenceXp + vitalityXp + cookingXp + woodcuttingXp + fletchingXp + craftingXp + rangedXp + fishingXp + magicXp + stoneforgingXp;
        // --- END OF FIX ---

        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // --- MODIFIED: Added Session Lock Button ---
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = async () => {
          // --- NEW: Disable button and show loading text ---
          refreshLeaderboardBtn.disabled = true;
          refreshLeaderboardBtn.textContent = '...'; // Use '...' as it's small

          if (typeof window.savePlayerData === 'function') {
            await window.savePlayerData();
          }
          
          // --- NEW: Await the render so we can re-enable the button ---
          await window.renderLeaderboards(); 
          
          // --- NEW: Re-enable button ---
          refreshLeaderboardBtn.disabled = false;
          refreshLeaderboardBtn.textContent = 'Refresh';
        };
    }
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); 
          sendChatMessage();
        }
      });
    }
    
    // +++ NEW: Session Lock Button +++
    const takeControlBtn = document.getElementById('takeControlButton');
    if (takeControlBtn) {
      takeControlBtn.onclick = () => {
        if (typeof window.acquireSessionLock === 'function') {
          window.acquireSessionLock();
        }
      };
    }
  });

  // --- Autosave runs every 30s, but only performs writes if the tab is visible ---
  setInterval(async () => {
    const user = auth.currentUser;

    // Check if user is logged in, is the active session, not in trade, AND THE TAB IS VISIBLE.
    if (user && game.isSessionActive && !game.inTrade && !document.hidden) {
        
      // 1. Refresh Lock Heartbeat (WRITE)
      // This update maintains the lock and prevents other tabs from stealing control.
      const playerRef = getPlayerRef();
      if (playerRef) {
          try {
              await updateDoc(playerRef, { "activeSession.timestamp": Date.now() }); 
          } catch (e) {
              console.error("Autosave Heartbeat failed:", e);
          }
      }
      
      // 2. Perform Full Save (WRITE)
      window.savePlayerData();
    }
    // If document.hidden is true, the timer function exits immediately with no writes.
  }, 9000);

  // --- MODIFIED: Releases session lock on tab close ---
  window.addEventListener('beforeunload', (e) => {
    try {
      // If we are the active session, release the lock
      if (game.isSessionActive) {
        if (typeof window.releaseSessionLock === 'function') {
          // Fire-and-forget, we can't wait for the update
          window.releaseSessionLock(false); 
        }
      }
      
      // Try one last save
      const user = auth.currentUser;
      if (user && game.isSessionActive && !game.inTrade) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // --- MODIFIED: Releases session lock on logout ---
  window.firebaseLogout = async function() {
  try {
    // 1. If in trade, cancel it first (Existing logic)
    if (game.inTrade && game.activeTradeSessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.warn("Could not cancel active trade on logout:", e);
      }
      closeTradeWindow();
    }

    // +++ NEW: STOP ALL ACTIONS +++
    // This is the fix. Stop all intervals and set active flags to false.
    if (game.inCombat) {
      runFromCombat(false);
    }
    if (game.miningActive) {
      stopMining();
    }
    if (game.blacksmithingActive) {
      stopBlacksmithing();
    }
    if (game.cookingActive) {
      stopCookingChicken();
    }
    if (game.woodcuttingActive) {
      stopWoodcutting();
    }
    if (game.fletchingActive) {
      stopFletching();
    }
    if (game.craftingActive) {
      stopCraftingBowString();
    }
    if (game.fishingActive) {
      stopFishing();
    }
    if (game.stoneforgingActive) { // +++ NEW +++
      stopStoneForging();
    }
    // NEW: Clear autocast on logout
    game.autocastSpell = null;
    if (typeof renderSpellsPanel === 'function') renderSpellsPanel();
    // +++ END NEW +++
    
    // 2. +++ NEW CRITICAL FIX +++: Release the session lock explicitly
    if (game.isSessionActive) {
      if (typeof window.releaseSessionLock === 'function') {
        // Await the lock release before doing anything else
        await window.releaseSessionLock(true);
      }
    }
    stopSessionHeartbeat();
    
    // 3. Save, then sign out
    await window.savePlayerData();
    await signOut(auth);
    
    await showGameAlert("Logged Out", "You have been successfully logged out.");
  } catch (e) {
    console.error("Logout failed:", e);
    await showGameAlert("Logout Failed", "Logout failed. Please try again or close your browser.");
  }
};

  (function() {
    // --- This is the new master preloader ---

    // Define all critical images your game needs to start
    const MASTER_ASSET_LIST = [
      'images/brick_background.png',
      'images/gearicon.png',

      // --- ADD THESE 6 LINES FOR YOUR NEW PLACEHOLDERS ---
      'images/necklace.png',
      'images/cape.png',
      'images/shield.png',
      'images/legs.png',
      'images/ring.png',
      'images/arrows.png',
      // --- END OF NEW LINES ---

      'images/helmet.png',
      'images/weapon.png',
      'images/chestplate.png',
      'images/boots.png',
      'images/goldpouch.png',
      'images/mines.png',
      'images/foresticon.png',
      'images/blacksmithicon.png',
      'images/kitchenbutton.png',
      'images/combatareas.png',
      'images/shopbutton.png',
      'images/bankbutton.png',
      'images/miningskillicon.png',
      'images/blacksmithskillicon.png',
      'images/attackskillicon.jpeg',
      'images/strengthskillicon.png',
      'images/defenseskillicon.png',
      'images/vitalityskillicon.png',
      'images/cookingskillicon.png',
      'images/woodcuttingskillicon.jpeg',
      'images/copperore.png',
      'images/copperbar.png',
      'images/coppershortsword.png',
      'images/copperhelmet.png',
      'images/copperchestplate.png',
      'images/copperboots.png',
      'images/rawchicken.png',
      'images/cookedchicken.png',
      'images/burntchicken.png',
      'images/beef.png', // +++ NEW +++
      'images/cookedbeef.png', // +++ NEW +++
      'images/burntbeef.png', // +++ NEW +++
      'images/chickenmonster.png',
      'images/chickenanim.gif',
      'images/coppervein.png',
      'images/coalvein.png',
      'images/ironvein.png',
      'images/farm.png',
      'images/softwood.png',
      'images/oak.png',
      'images/bronzepickaxe.png',
      'images/bronzeaxe.png',
      'images/copperpickaxe.png',
      'images/copperaxe.png',
      'images/ironpickaxe.png',
      'images/ironaxe.png',
      'images/ironore.png',
      'images/ironbar.png',
      'images/earthcrystalshard.png',
      'images/aircrystalshard.png',
      'images/watercrystalshard.png',
      'images/earthcrystalvein.png',
      'images/aircrystalvein.png',
      'images/watercrystalvein.png',
      'images/crystalmine.jpeg',
      'images/ironshortsword.png',
      'images/ironhelmet.png',
      'images/ironchestplate.png',
      'images/ironboots.png',
      'images/fletchingskillicon.jpeg', // +++ CHANGED TO .jpeg +++
      'images/fletchingworkbench.png',
      'images/feather.png',
      'images/arrowshaft.png',
      'images/copperarrowtip.png',
      'images/unboundarrow.png',
      'images/copperarrow.png',
      'images/copperplatelegs.png', // +++ NEW +++
      'images/ironplatelegs.png', // +++ NEW +++
      
      // +++ NEW CAVE/SPIDER ASSETS +++
      // +++ NEW CAVE/SPIDER/RAT/CENTIPEDE ASSETS +++
      'images/cave.png',
      'images/spidermonster.png',
      'images/spideranim.gif',
      'images/silk.png',
      'images/ratmonster.jpeg', 
      'images/ratanim.webp',
      'images/rattail.png', // New Item
      'images/centipedemonster.jpeg',
      'images/centipedeanim.webp',
      'images/sand.png', // +++ NEW +++
      'images/sandvein.jpeg', // +++ NEW +++
      'images/emptyvial.png', // +++ NEW +++
      'images/venom.png', // +++ NEW +++
      
      // +++ NEW ASSETS FOR CRAFTING/RANGED +++
      'images/craftingskillicon.png',
      
      // +++ NEW ASSETS FOR CRAFTING/RANGED +++
      'images/craftingskillicon.png',
      'images/rangedskillicon.jpeg',
      'images/craftingbenchbutton.png',
      'images/bowstring.png',
      'images/unstrungsoftwoodbow.png',
      'images/unstrungoakbow.png',
      'images/softwoodbow.png',
      'images/oakbow.png',
      // +++ NEW LEATHER ASSETS +++
      'images/cowhide.png',
      'images/leatherhood.png',
      'images/leather.png',
      'images/leatherarmor.png',
      'images/leatherpants.png',
      'images/leatherboots.png',
      'images/cowmonster.png',
      'images/cowanim.webp',
      
      // +++ NEW FISHING ASSETS +++
      'images/fishingskillicon.jpeg',
      'images/fishingareasbutton.jpeg',
      'images/oceanbutton.png',
      'images/riverbutton.jpeg',
      'images/herring.png',
      'images/trout.png',
      'images/salmon.png',
      
      // +++ NEW FISHING REQUIREMENTS +++
      'images/fishingpole.png',
      'images/fishingbait.png',
      
      // +++ NEW CLOTH & WIZARD ASSETS +++
      'images/cloth.png',
      'images/wizardhat.png',
      'images/wizardrobe.png',
      'images/wizardtrousers.png',
      'images/wizardboots.png',
      'images/magicstaff.png',
      'images/magicskillicon.jpeg',
      
      // +++ NEW ELEMENTAL FORGE ASSETS +++
      'images/earthstone.png',
      'images/airstone.png',
      'images/waterstone.png',
      'images/elementalforge.jpeg',
      'images/stoneforgingskillicon.jpeg',
      'images/questbuttonicon.jpg', // +++ NEW +++
      'images/1tapper.png',         // +++ NEW ADMIN WEAPON +++
      'images/petspider.png',       // +++ NEW PET IMAGE +++
      'images/bountyhunterskillicon.jpeg', // +++ NEW +++
      'images/huntingboard.jpeg' // +++ NEW +++
    ];

    /**
     * Preloads all assets and shows a loading screen
     * @param {string[]} assetList - Array of image paths
     * @returns {Promise}
     */
    function preloadAllAssets(assetList) {
      const authScreen = document.getElementById('authScreen');
      if (authScreen) authScreen.style.display = 'none';

      // Find the existing loading screen
      const loadingScreen = document.getElementById('loadingScreen');
      loadingScreen.style.display = 'flex'; // Make sure it's visible
      
      // --- NEW: Get Progress Bar elements ---
      const progressBarFill = document.getElementById('loading-bar-fill');
      const progressPercentText = document.getElementById('loading-progress-percent');
      // --- END NEW ---

      // --- REMOVED old progressText creation ---

      let loadedCount = 0;
      const totalAssets = assetList.length; // --- NEW: Get total count ---

      const promises = assetList.map(src => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            loadedCount++;
            
            // --- NEW: Update Progress Bar ---
            const percent = Math.round((loadedCount / totalAssets) * 100);
            if (progressBarFill) {
              progressBarFill.style.width = percent + '%';
            }
            if (progressPercentText) {
              progressPercentText.innerText = percent + '%';
            }
            // --- END NEW ---

            // --- REMOVED old text update ---
            resolve();
          };
          img.onerror = () => {
            console.warn(`[Preloader] Failed to load: ${src}`);
            resolve(); // Resolve anyway so the game doesn't hang
          };
          img.src = src;
        });
      });

      return Promise.all(promises);
    }

    // Run the preloader
    preloadAllAssets(MASTER_ASSET_LIST).then(() => {
      console.log('[Preloader] All assets loaded.');

      // +++ NEW: Force-decode combat GIFs +++
      // This invisibly adds the GIFs to the page, forcing the browser
      // to decode them before they are needed.
   const primeImg = document.createElement('img');
   primeImg.src = 'images/chickenanim.gif';
   primeImg.style.cssText = 'position:absolute; left:-9999px; top:-9999px; width:1px; height:1px;';
   document.body.appendChild(primeImg);

      // +++ ADD THIS BLOCK FOR THE SPIDER +++
   // +++ ADD THIS BLOCK FOR THE COW +++
   const primeImg3 = document.createElement('img');
   primeImg3.src = 'images/cowanim.gif';
   primeImg3.style.cssText = 'position:absolute; left:-9999px; top:-9999px; width:1px; height:1px;';
   document.body.appendChild(primeImg3);
   // +++ END NEW +++
      
      const loadingScreen = document.getElementById('loadingScreen');
      
      if (loadingScreen) {
        loadingScreen.style.display = 'none'; // Hide loading
      }

      // --- We removed the code that shows the authScreen ---
      // The onAuthStateChanged listener will now handle showing
      // the correct screen (login OR game) without a flash.

    });

  })();
</script>
</body>
</html>