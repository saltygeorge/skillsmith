<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}
body {
  margin: 0;
  font-family: "Garamond", serif;
  background: #3f2b21;
  background-image: url('images/brick_background.png');
  background-size: cover;
  background-attachment: fixed;
  background-position: center center;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- Panel Row Wrappers --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch;
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- Spacer for Chat Panel --- */
.sidebar-spacer {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0;
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  background: var(--panel-bg);
  padding: 16px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.char-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px;
}

.hp-bar { background: #772222; border-radius: 6px; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

#equipmentTab {
  display: flex;
  flex-direction: column;
  justify-content: center;
  flex-grow: 1;
  padding-top: 70px;
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { display: flex; flex-direction: column; align-items: center; }
.equipment-row { display: flex; justify-content: center; margin: 6px 0; gap: 10px; }
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  padding: var(--slot-gap); 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 2000;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- Custom Scrollbar --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px;
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Main area --- */
.main {
  flex: 1;
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  min-height: 500px; 
  position: relative;
  
  /* --- NEW: Added flex properties --- */
  display: flex;
  flex-direction: column;
}

#mainContentWrapper {
  flex-grow: 1;     /* Allows this wrapper to fill the panel's height */
  overflow-y: auto;   /* ADDS A SCROLLBAR if content is too tall */
  min-height: 0;      /* A flexbox fix to allow shrinking/scrolling */
  
  /* --- NEW: Add custom scrollbar --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

#mainContentWrapper::-webkit-scrollbar {
  width: 8px;
}
#mainContentWrapper::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Chat Panel --- */
.chat-panel {
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  display: flex; 
  flex-direction: column;
  min-height: 200px;
  flex-shrink: 0;
  flex: 1;
}
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}
#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}

/* --- Action Progress --- */
.progress-container {
  background: #7c644c;
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}
.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }
.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}
button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

@media(max-width:900px) {
  .container { flex-direction: column; align-items: center; }
  #top-row-panels, #bottom-row-chat {
      flex-direction: column;
      width: 95%;
  }
  .sidebar, .main, .chat-panel { 
      width: 100%;
      box-sizing: border-box;
  }
  .sidebar-spacer {
      display: none;
  }
}

/* --- Trade Modal --- */
#tradeModal { display: none; }
.trade-content {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}
.trade-main-area { display: flex; gap: 20px; flex: 1; }
.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}
.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img { width: 30px; height: 30px; }
#tradeInventoryGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}
.trade-offer-layout { display: flex; gap: 20px; }
.trade-offer-box { flex: 1; display: flex; flex-direction: column; }
.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}
#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}
.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}

/* --- Drag & Drop --- */
.inv-slot.dragging {
  opacity: 0.4;
  cursor: grabbing;
}
.inv-slot.drag-over {
  border-color: var(--gold);
  border-style: dashed;
  background: rgba(181, 166, 66, 0.1);
}

/* +++ NEW: SESSION LOCK OVERLAY +++ */
#sessionLockOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#sessionLockOverlay div {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  padding: 30px 40px;
  border-radius: 10px;
  max-width: 400px;
}
#sessionLockOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}

#deathOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5001; /* Higher than session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#deathOverlay div {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  padding: 30px 40px;
  border-radius: 10px;
  max-width: 400px;
}
#deathOverlay h2 {
  margin-top: 0;
  color: #ff4d4d; /* Red for death */
}
/* +++ END NEW STYLES +++ */

#combat-main-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#combat-enemy-area {
  flex-basis: 200px; /* Reduced from 220px */
  flex-shrink: 0;
  text-align: center;
  position: relative;
  margin-bottom: 15px;
}

#combat-enemy-img {
  max-height: 150px; /* Reduced from 180px */
  max-width: 100%;
  object-fit: contain;
}

#combat-enemy-hp-bar {
  background: #772222;
  border-radius: 6px;
  /* overflow: hidden; */ /* <-- This is the fix */
  position: relative;
  height: 28px;
  width: 80%;
  max-width: 300px;
  margin: 10px auto 0 auto;
  border: 2px solid #333;
}

#combat-enemy-hp-fill {
  height: 100%;
  background: #d22;
  width: 100%;
  transition: width 0.25s;
}

#combat-enemy-hp-text {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  font-size: 13px;
}

#combat-player-area {
  flex-grow: 1;
  display: flex;
  gap: 20px;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
}

#combat-equip-panel {
  /* Removed the fixed flex-basis of 300px */
  /* This panel will now shrink to fit its content */
}

#combat-action-panel {
  /* flex-grow: 1; has been removed */
  display: flex;
  flex-direction: column;
}

#combat-styles {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

#combat-styles button {
  flex: 1;
  padding: 12px;
  border: 2px solid var(--accent);
  background: var(--accent);
  opacity: 0.7;
}

#combat-styles button.active {
  background: var(--accent-hover);
  border-color: var(--gold);
  opacity: 1.0;
}


#combat-main-actions {
  display: flex;
  gap: 10px;
  flex-direction: column; /* Stack buttons */
}

#combat-main-actions button {
  /* flex: 1; removed */
  font-size: 16px;
}
/* --- END: Combat UI Styles --- */

.combat-splat {
  position: absolute;
  right: -40px; /* Moved over to center the new box */
  top: -5px;    /* Moved up slightly */
  font-size: 1.2rem;
  font-weight: bold;
  pointer-events: none;
  z-index: 1600;
  animation: rise 900ms ease-out forwards;
  
  /* --- NEW "BOX" STYLES --- */
  background: rgba(10, 10, 10, 0.75);
  border: 1px solid #000;
  border-radius: 6px;
  padding: 3px 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}

.splat-damage {
  color: #ff4d4d; /* Bright red */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

.splat-block {
  color: #6dafff; /* Bright blue */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

/* --- NEW: Item Context Menu --- */
#itemContextMenu {
  display: none;
  position: fixed;
  z-index: 3000;
  background: var(--panel-bg);
  border: 2px solid #453625;
  border-radius: 6px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  padding: 5px;
  min-width: 100px;
}
.context-menu-btn {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 4px;
  text-align: left;
  cursor: pointer;
  font-weight: 700;
}
.context-menu-btn:hover {
  background: var(--accent-hover);
}
/* --- END: Item Context Menu --- */

</style>
</head>
<body>

<div id="authScreen" style="display:flex; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header">
          <h2 id="charName">Player</h2>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-row">
                  <div class="equipment-slot" id="helmet">
                    <img src="images/helmet.png" alt="Helmet">
                  </div>
                </div>
                <div class="equipment-row" style="align-items:center;">
                  <div class="equipment-slot" id="weapon">
                    <img src="images/weapon.png" alt="Weapon">
                  </div>
                  <div class="equipment-slot" id="chest">
                    <img src="images/chestplate.png" alt="Chest">
                  </div>
                </div>
                <div class="equipment-row">
                  <div class="equipment-slot" id="boots">
                    <img src="images/boots.png" alt="Boots">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
              <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
                <img src="images/goldpouch.png" alt="Gold" style="width: 60px; height: 60px; object-fit: contain;">
                <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 8px;">0</span>
              </div>
              
            </div>
            
          </div>
          
          <div id="skillsTab" style="display:none;">
            </div>
          
        </div>
      </div>

      <div class="main" id="mainArea">
        <div id="mainContentWrapper">
          </div>
        <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>
      </div>

    </div> 
    
    <div id="bottom-row-chat">

      <div class="sidebar-spacer"></div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div class="sidebar-spacer"></div>

    </div> 
    
  </div> 
</div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<div id="sessionLockOverlay" style="display: none;">
  <div>
    <h2>Session Active Elsewhere</h2>
    <p>This account is already being played in another tab or browser. To prevent data corruption, this tab has been disabled.</p>
    <button id="takeControlButton" class="primary">Take Control Here</button>
  </div>
</div>

<div id="deathOverlay" style="display: none;">
  <div>
    <h2>You died!</h2>
    <p>You lost all your inventory and gold.</p>
    <button id="reviveBtn" class="primary" onclick="revivePlayer()">Revive</button>
  </div>
</div>

<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  inventory: [], 
  inventoryCapacity: 39,
  gold: 0, 
  mining: { level: 1, xp: 0, totalXP: 0 },
  blacksmith: { level: 1, xp: 0, totalXP: 0 },
  attack: { level: 1, xp: 0, totalXP: 0 }, 
  strength: { level: 1, xp: 0, totalXP: 0 }, 
  defence: { level: 1, xp: 0, totalXP: 0 }, 
  vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY SKILL +++
  cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING SKILL +++
  miningActive: false,
  blacksmithingActive: false, // +++ NEW: Add missing cookingActive state +++
  cookingActive: false,
  blacksmithingActive: false,
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, 
  isAdmin: false,
  inCombat: false,
  playerAttackStyle: 'strength', // Default to strength
  currentEnemy: null,
  playerCombatInterval: null,
  enemyCombatInterval: null,
  wasMiningBeforeCombat: false, // Renamed from 'wasMiningBeforeTrade'
  wasSmithingBeforeCombat: false,
  
  // +++ NEW SESSION LOCK +++
  // This is a unique ID for this specific tab
  sessionLockId: (function() {
  let id = sessionStorage.getItem('gameSessionId');
  if (!id) {
    // No ID exists, so this is a new tab. Create one.
    id = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    sessionStorage.setItem('gameSessionId', id);
  }
  // Return the persistent ID for this tab
  return id;
})(),
// +++ END MODIFICATION +++

lockHeartbeat: null,    // This will hold the setInterval ID for the heartbeat
isSessionActive: false, // Is this tab the "master" tab?
isDragging: false,      // Are we currently dragging an item?

inTrade: false,
activeTradeSessionId: null,
activeTradeListener: null, 
myTradeRole: null, 
myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};
// +++ END MODIFICATION +++

game.inventory = new Array(game.inventoryCapacity).fill(null);

const VALID_ITEMS = [
  'Copper Ore',
  'Copper Bar',
  'Copper Chestplate',
  'Copper Shortsword',
  'Raw Chicken',
  'Cooked Chicken',
  'Burnt Chicken'
]; // <-- THIS LINE IS THE FIX (Array is now closed)

const XP_TABLE = [
  0,        // Level 1
  83,       // Level 2
  174,      // Level 3
  276,      // Level 4
  388,      // Level 5
  512,      // Level 6
  650,      // Level 7
  801,      // Level 8
  969,      // Level 9
  1154,     // Level 10
  1358,     // Level 11
  1584,     // Level 12
  1833,     // Level 13
  2107,     // Level 14
  2411,     // Level 15
  2746,     // Level 16
  3115,     // Level 17
  3523,     // Level 18
  3973,     // Level 19
  4470,     // Level 20
  5018,     // Level 21
  5624,     // Level 22
  6291,     // Level 23
  7028,     // Level 24
  7842,     // Level 25
  8740,     // Level 26
  9730,     // Level 27
  10824,    // Level 28
  12031,    // Level 29
  13363,    // Level 30
  14833,    // Level 31
  16456,    // Level 32
  18247,    // Level 33
  20224,    // Level 34
  22436,    // Level 35
  24898,    // Level 36
  27673,    // Level 37
  30779,    // Level 38
  33648,    // Level 39
  37224,    // Level 40
  41171,    // Level 41
  45542,    // Level 42
  50339,    // Level 43
  55649,    // Level 44
  61512,    // Level 45
  67983,    // Level 46
  75127,    // Level 47
  83014,    // Level 48
  91721,    // Level 49
  101333,   // Level 50
  111945,   // Level 51
  123660,   // Level 52
  136615,   // Level 53
  150872,   // Level 54
  166636,   // Level 55
  184040,   // Level 56
  203254,   // Level 57
  224446,   // Level 58
  247866,   // Level 59
  273742,   // Level 60
  302288,   // Level 61
  333804,   // Level 62
  368599,   // Level 63
  407015,   // Level 64
  449426,   // Level 65
  496254,   // Level 66
  547953,   // Level 67
  605032,   // Level 68
  668051,   // Level 69
  737637,   // Level 70
  814445,   // Level 71
  899252,   // Level 72
  992895,   // Level 73
  1096245,  // Level 74
  1210210,  // Level 75
  1336486,  // Level 76
  1475581,  // Level 77 (Using 1,475,581)
  1629200,  // Level 78 (Using 1,629,200)
  1798808,  // Level 79
  1986068,  // Level 80
  2192818,  // Level 81
  2421027,  // Level 82
  2673114,  // Level 83
  2951373,  // Level 84 (Using 2,951,373)
  3258594,  // Level 85
  3597292,  // Level 86
  3972294,  // Level 87 (Using 3,972,294)
  4385776,  // Level 88
  4842295,  // Level 89
  5346332,  // Level 90 (Using 5,346,332)
  5902831,  // Level 91
  6517253,  // Level 92
  7195629,  // Level 93
  7944614,  // Level 94
  8771588,  // Level 95
  9684577,  // Level 96
  10692629, // Level 97
  11805606, // Level 98
  13034031, // Level 99
  15000000  // Level 100: Custom value
];

const CHESTPLATE_BAR_COST = 10;
const CHESTPLATE_XP = 50; // Defining a standard XP gain for the item

// +++ NEW SHORTSWORD CONSTANTS +++
const SHORTSWORD_BAR_COST = 5;
const SHORTSWORD_XP = 32;
const SHORTSWORD_TIME_MS = 5000;
// +++ END NEW CONSTANTS +++

function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) return n.toString();
  if (n < 1000000) return parseFloat((n / 1000).toFixed(2)) + 'k';
  return parseFloat((n / 1000000).toFixed(2)) + 'M';
}

function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  backToActions(); 
}

function updateHPUI(){
  // Calculate new maxHP based on Vitality level (1 HP per level starting at Lvl 1)
  game.maxHP = 10 + (game.vitality ? (game.vitality.level - 1) : 0);
  
  // Ensure current HP doesn't exceed max HP after a level up
  game.hp = Math.min(game.hp, game.maxHP); 
  
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}

function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount);
  updateGoldUI();
}

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;

  for(let i = 0; i < capacity; i++){
    const slotData = game.inventory[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    if(slotData){
      slot.draggable = true;
      const item = slotData;
      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      
      // --- NEW: Custom image name logic for all multi-word items ---
      if (item.name === 'Copper Bar') {
          imgName = 'copperbar';
      } else if (item.name === 'Copper Chestplate') { // Handles chestplate image
          imgName = 'copperchestplate';
      } else if (item.name === 'Copper Shortsword') { // +++ SHORTSWORD IMAGE FIX +++
          imgName = 'coppershortsword';
      } else if (item.name === 'Raw Chicken') {
          imgName = 'rawchicken';
      } else if (item.name === 'Cooked Chicken') {
          imgName = 'cookedchicken';
      } else if (item.name === 'Burnt Chicken') {
          imgName = 'burntchicken';
      }
      // --- END NEW LOGIC ---
      
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      
      // --- NEW: Add item stats to tooltip ---
      let itemStats = '';
      if (itemName === 'Cooked Chicken') {
        itemStats = '<div style="color:#aaffaa; margin-top:4px;">+3 HP</div>';
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
        ${itemStats}
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      
      // --- NEW: Updated click handler ---
      const itemQty = item.qty; // Capture qty for the closure
      slot.onclick = (event) => {
        handleItemClick(event, itemName, itemQty);
      };
    } else {
      slot.draggable = false;
    }
    grid.appendChild(slot);
  }
}

// =================================================================
// --- 1. REPLACED 'addItem' FUNCTION (non-module script) ---
// This function now correctly handles multiple stacks.
// =================================================================
function addItem(name, qty = 1) {
  let amountToAdd = qty;

  // 1. Try to stack in existing slots first
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      slot.qty += amountToAdd;
      amountToAdd = 0;
      break; // Found a stack, stop looking
    }
  }

  // 2. If items are left (no existing stack found), find an empty slot
  if (amountToAdd > 0) {
    let emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex > -1) {
      game.inventory[emptySlotIndex] = { name: name, qty: amountToAdd };
      amountToAdd = 0;
    } else {
      console.warn(`Inventory full! Could not add ${amountToAdd} ${name}`);
      // Note: We don't return, so the inventory still renders
    }
  }

  renderInventoryGrid();
}

// =================================================================
// --- 2. REPLACED 'removeItem' FUNCTION (non-module script) ---
// This function now correctly removes from multiple stacks.
// =================================================================
function removeItem(name, qty = 1) {
  let amountToRemove = qty;
  let totalAvailable = 0;

  // 1. First, check if we even have enough across ALL stacks
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      totalAvailable += slot.qty;
    }
  }

  if (totalAvailable < amountToRemove) {
    console.warn(`Tried to remove ${qty} ${name}, but only have ${totalAvailable}`);
    return false; // Not enough items
  }

  // 2. If we have enough, remove them. Iterate backwards is safer.
  for (let i = game.inventory.length - 1; i >= 0; i--) {
    const slot = game.inventory[i];
    if (slot && slot.name === name) {
      if (slot.qty > amountToRemove) {
        // This stack has more than we need
        slot.qty -= amountToRemove;
        amountToRemove = 0;
      } else {
        // This stack will be emptied
        amountToRemove -= slot.qty;
        game.inventory[i] = null; // Empty the slot
      }
    }
    if (amountToRemove === 0) break; // We're done
  }
  return true; // Successfully removed
}
// =================================================================
// --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
// =================================================================

function handleSellItemClick(itemName, currentQty) {
  if (!game.shopOpen) return;
  let sellPrice = 0;
  if (itemName === 'Copper Ore') {
    sellPrice = 1;
  } else {
    alert("This shop doesn't buy that item.");
    return;
  }
  
  // --- This logic needs to be updated to check total quantity ---
  let totalQty = 0;
  for (const slot of game.inventory) {
      if(slot && slot.name === itemName) {
          totalQty += slot.qty;
      }
  }

  let qtyToSell = 0;
  if (totalQty === 1) {
    qtyToSell = 1;
  } else {
    const input = prompt(`How many ${itemName} do you want to sell? (You have: ${totalQty})`, totalQty);
    if (input === null) return;
    qtyToSell = parseInt(input);
  }

  if (isNaN(qtyToSell) || qtyToSell <= 0) return;
  if (qtyToSell > totalQty) {
    alert("You don't have that many to sell.");
    return;
  }
  
  const totalGold = qtyToSell * sellPrice;
  // NOTE: Using alert/confirm is bad practice, but we'll leave it for now.
  const confirmed = confirm(`Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`);
  
  if (confirmed) {
    // We use the NEW removeItem function which works correctly
    if (removeItem(itemName, qtyToSell)) {
        addGold(totalGold);
        hideTooltip(); 
        renderInventoryGrid();
        if (game.inTrade) {
          renderTradeInventory();
        }
        alert(`You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`);
    } else {
        alert("Something went wrong, the sale did not complete.");
    }
  }
}

function handleItemClick(event, itemName, itemQty) {
  // Always close any open menu first
  hideItemContextMenu();

  if (game.shopOpen) {
    // If shop is open, we're selling
    handleSellItemClick(itemName, itemQty);
  } else if (itemName === 'Cooked Chicken') {
    // Not in shop, and it's a chicken. Show eat menu.
    showItemContextMenu(event, itemName);
  }
  // Other items do nothing outside the shop... for now.
}

// NEW: Shows the right-click-style menu
function showItemContextMenu(event, itemName) {
  const menu = document.getElementById('itemContextMenu');
  let menuContent = '';

  if (itemName === 'Cooked Chicken') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedChicken()">Eat</button>`;
  }
  
  // We can add other options here later (e.g., "Drop")
  
  if (menuContent) {
    menu.innerHTML = menuContent;
    menu.style.display = 'block';
    
    // Position menu near the cursor
    const rect = document.body.getBoundingClientRect();
    menu.style.left = (event.clientX - rect.left + 5) + 'px';
    menu.style.top = (event.clientY - rect.top + 5) + 'px';

    // Add a one-time listener to close the menu
    // Use setTimeout to skip this current click event
    setTimeout(() => {
      document.addEventListener('click', hideItemContextMenu, { once: true });
    }, 0);
  }
}

// NEW: Hides the item context menu
function hideItemContextMenu() {
  const menu = document.getElementById('itemContextMenu');
  if (menu) menu.style.display = 'none';
  // Remove the listener just in case (though {once: true} should handle it)
  document.removeEventListener('click', hideItemContextMenu);
}

// NEW: The logic for eating the chicken
function eatCookedChicken() {
  hideItemContextMenu(); // Close the menu

  // Check if HP is full
  if (game.hp >= game.maxHP) {
    alert("Your HP is already full.");
    return;
  }

  // Try to remove the item. If successful, heal the player.
  if (removeItem('Cooked Chicken', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + 3);
    updateHPUI();
    
    // --- NEW FIX: Re-render inventory and save ---
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
    // --- END FIX ---

  } else {
    console.warn('Tried to eat Cooked Chicken, but removeItem failed.');
  }
}

const tooltip = document.getElementById('tooltip');
function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}
function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}
function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){
    // level is the CURRENT level (1-100)
    
    // Safety check for levels beyond the table
    if (level >= XP_TABLE.length) {
        return 0; 
    }

    // XP_TABLE[level] holds the total XP for level + 1
    const xpNeededForNextLevel = XP_TABLE[level]; 
    
    // XP_TABLE[level - 1] holds the total XP for the current level
    const xpAlreadyGained = XP_TABLE[level - 1] || 0; 

    return xpNeededForNextLevel - xpAlreadyGained;
}

function getTotalXPForLevel(level) {
    // level is the level we want the *cumulative* XP for (1-100)

    // The XP_TABLE is 0-indexed: Lvl 1 total XP is at index 0.
    const index = Math.min(level - 1, XP_TABLE.length - 1);

    return XP_TABLE[index] || 0;
}

function updateSkillUI(){
  const skillsTab = document.getElementById('skillsTab');
  if (!skillsTab) return;
  
  // Clear the tab and set up the header/container
  skillsTab.innerHTML = `
    <div style="font-size:14px; margin-bottom:12px;">Skills</div>
    <div id="skillIconsContainer" style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: flex-start;">
      </div>
  `;

  const container = document.getElementById('skillIconsContainer');

  /**
   * Helper function to create a skill icon with a tooltip
   * @param {string} skillName - The display name (e.g., "Mining")
   * @param {string} skillDataKey - The key in the game object (e.g., "mining")
   * @param {string} iconFileName - The name of the icon file in /images/
   */
  const createSkillIcon = (skillName, skillDataKey, iconFileName) => {
    const data = game[skillDataKey];
    const iconWrapper = document.createElement('button');
    iconWrapper.className = 'primary'; // Use 'primary' class for base styling
    iconWrapper.style.cssText = `
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 5px; 
      padding: 8px 10px; 
      height: 80px; /* Fixed height for consistency */
      width: 80px;  /* Fixed width for consistency */
      justify-content: center;
      font-size: 13px;
      background: var(--accent);
      border: 2px solid #50311f; /* Added a border to define the button */
      transition: all 0.15s ease;
    `;
    
    // --- Create the tooltip content ---
    const nextXP = getNextXP(data.level);
    // Calculate progress percentage, ensuring it doesn't exceed 100%
    const progressPercent = Math.min(100, (data.xp / nextXP) * 100);
    
    const tooltipContent = `
      <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${skillName}</div>
      <div style="font-size: 14px; margin-bottom: 6px;">Level: <span style="font-weight: bold;">${data.level}</span></div>
      <div>XP: ${data.xp.toLocaleString()} / ${nextXP.toLocaleString()}</div>
      <div>(Total XP: ${data.totalXP.toLocaleString()})</div>
      
      <div style="width: 100%; height: 8px; background: #555; border-radius: 4px; margin-top: 8px; border: 1px solid #333;">
        <div style="height: 100%; width: ${progressPercent}%; background: #4caf50; border-radius: 4px; transition: width 0.2s;"></div>
      </div>
    `;

    // Set up hover/tooltip events
    iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
    iconWrapper.onmouseleave = hideTooltip;

    // Create and append icon image
    const img = document.createElement('img');
    img.src = `images/${iconFileName}`;
    img.alt = skillName;
    img.style.cssText = 'width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; pointer-events: none;';
    img.onerror = function(){ this.style.opacity='0.1'; this.style.filter='grayscale(100%)'; }; // Fallback
    iconWrapper.appendChild(img);

    // Append level text
    const levelText = document.createElement('span');
    levelText.innerText = `Lvl ${data.level}`;
    levelText.style.fontWeight = 'bold';
    levelText.style.pointerEvents = 'none';
    iconWrapper.appendChild(levelText);

    container.appendChild(iconWrapper);
  };

  // --- Call the function for each of your skills ---
  createSkillIcon('Mining', 'mining', 'miningskillicon.png');
  createSkillIcon('Blacksmith', 'blacksmith', 'blacksmithskillicon.png');
  createSkillIcon('Attack', 'attack', 'attackskillicon.png'); 
  createSkillIcon('Strength', 'strength', 'strengthskillicon.png'); 
  createSkillIcon('Defence', 'defence', 'defenseskillicon.png'); 
  createSkillIcon('Vitality', 'vitality', 'vitalityskillicon.png'); // +++ NEW VITALITY SKILL CALL +++
  createSkillIcon('Cooking', 'cooking', 'cookingskillicon.png'); // +++ NEW COOKING SKILL CALL +++
}

function showItemPopup(text, progressElementId, delay = 0) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.innerHTML = text; // Allow HTML
popup.style.lineHeight = '1.4';
    const bar = document.getElementById(progressElementId);
    if (bar) {
        const barRect = bar.getBoundingClientRect();
        const mainRect = main.getBoundingClientRect();
        const relativeX = barRect.left - mainRect.left;
        const relativeY = barRect.top - mainRect.top;
        popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
        popup.style.top = (relativeY - 30) + 'px';
    } else {
        popup.style.left = '50%';
        popup.style.top = '120px';
        popup.style.transform = 'translateX(-50%)';
    }
    if (delay > 0) {
    setTimeout(() => {
      main.appendChild(popup);
      setTimeout(() => popup.remove(), 850); // 850 to match splat
    }, delay);
  } else {
    main.appendChild(popup);
    setTimeout(() => popup.remove(), 850); // 850 to match splat
  }
}

function addXP(skill, amount, delay = 0){
  if (!game[skill]) {
      console.warn(`Skill "${skill}" does not exist.`);
      return;
  }
  game[skill].totalXP += amount; 
  game[skill].xp += amount;
  
  let leveledUp = false; // --- NEW: Add a flag ---
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
    leveledUp = true; // --- NEW: Set the flag ---
  }
  
  // --- NEW: Check if vitality leveled up and update HP ---
  if (leveledUp && skill === 'vitality') {
    updateHPUI();
  }
  // --- END NEW ---

  updateSkillUI();
  let barId = '';
  if (skill === 'mining') barId = 'mineProgress';
  if (skill === 'blacksmith') barId = 'smithProgress';
  if (skill !== 'blacksmith' && skill !== 'mining' && skill !== 'cooking') { // Don't show popup for blacksmith, it will be handled manually
    if (delay > 0) {
      setTimeout(() => {
        showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
      }, delay);
    } else {
      showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
    }
 }

 }

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

// --- MODIFIED: Added Session Lock Check ---
function startMining() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(MINE_ITEM, 1); // Uses new addItem
    addXP('mining', MINE_XP); // This now adds XP without a popup

    // NEW: Create two separate, delayed popups
    showItemPopup(`+${MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 Copper Ore`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, startTime));
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// +++ NEW CRAFTING FUNCTION BLOCK TO INSERT +++
const CHESTPLATE_TIME_MS = 10000; 

function startChestplateCrafting() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  // --- Check total bars across all stacks ---
  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < CHESTPLATE_BAR_COST) {
      alert(`You need at least ${CHESTPLATE_BAR_COST} Copper Bars to craft a chestplate.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, now));
}

function chestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / CHESTPLATE_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check materials again before consuming ---
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < CHESTPLATE_BAR_COST) {
        alert("You've run out of Copper Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Bar', CHESTPLATE_BAR_COST); // Consume 10 bars
    addItem('Copper Chestplate', 1); // Add 1 chestplate
    addXP('blacksmith', CHESTPLATE_XP); // Award Blacksmith XP
    
    // NEW: Create two separate, delayed popups
    showItemPopup(`+${CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Copper Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < CHESTPLATE_BAR_COST) {
        alert("You don't have enough bars to craft another chestplate.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, startTime));
  }
}
// +++ END NEW CRAFTING FUNCTION +++


function startShortswordCrafting() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < SHORTSWORD_BAR_COST) {
      alert(`You need at least ${SHORTSWORD_BAR_COST} Copper Bars to craft a shortsword.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, now));
}

function shortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SHORTSWORD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < SHORTSWORD_BAR_COST) {
        alert("You've run out of Copper Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Bar', SHORTSWORD_BAR_COST); // Consume 5 bars
    addItem('Copper Shortsword', 1); // Add 1 shortsword
    addXP('blacksmith', SHORTSWORD_XP); // Award Blacksmith XP
    
    // NEW: Create two separate, delayed popups
    showItemPopup(`+${SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Copper Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < SHORTSWORD_BAR_COST) {
        alert("You don't have enough bars to craft another shortsword.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, startTime));
  }
}
// +++ END NEW SHORTSWORD CRAFTING FUNCTION +++

const SMITH_TIME_MS = 5000;
const SMITH_XP = 25;
const SMITH_ORE_COST = 2;
const SMITH_BAR_ITEM = 'Copper Bar';

// --- MODIFIED: Added Session Lock Check ---
function startBlacksmithing() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  // --- Check total ore across all stacks ---
  let totalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Ore') {
          totalOre += slot.qty;
      }
  }

  if (totalOre < SMITH_ORE_COST) {
      alert(`You need at least ${SMITH_ORE_COST} Copper Ore to smith a bar.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
}

function blacksmithingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SMITH_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check total ore again ---
    let totalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOre += slot.qty;
        }
    }
    if (totalOre < SMITH_ORE_COST) {
        alert("You've run out of Copper Ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Ore', SMITH_ORE_COST); // Uses new removeItem
    addItem(SMITH_BAR_ITEM, 1); // Uses new addItem
    addXP('blacksmith', SMITH_XP); // This now adds XP without a popup
    
    // NEW: Create two separate, delayed popups
    showItemPopup(`+${SMITH_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Copper Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalOreAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOreAfter += slot.qty;
        }
    }
    if (totalOreAfter < SMITH_ORE_COST) {
        alert("You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, startTime));
  }
}

function stopBlacksmithing(){
  game.blacksmithingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('smithProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startSmithBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopSmithBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

const COOK_CHICKEN_TIME_MS = 3000;
const COOK_CHICKEN_XP = 30;

// --- NEW COOKING FUNCTIONS ---
function startCookingChicken() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.cookingActive) return;

  // --- Check for Raw Chicken ---
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Raw Chicken') {
          totalRaw += slot.qty;
      }
  }

  if (totalRaw < 1) {
      alert(`You need at least 1 Raw Chicken to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
}

function cookingChickenLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_CHICKEN_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check materials again ---
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        alert("You've run out of Raw Chicken.");
        stopCookingChicken();
        return;
    }
    
    removeItem('Raw Chicken', 1); // Consume 1 raw chicken
    addXP('cooking', COOK_CHICKEN_XP); // Always award XP (no popup thanks to Step 1)
    
    // Calculate success rate (50% at Lvl 1, 100% at Lvl 10)
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    // NEW: Create two separate, delayed popups
    if (Math.random() * 100 < successRate) {
      // Success
      addItem('Cooked Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Cooked Chicken`, 'cookProgress', 450);
    } else {
      // Burnt
      addItem('Burnt Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Burnt Chicken`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        alert("You don't have any more Raw Chicken to cook.");
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, startTime));
  }
}

function stopCookingChicken(){
  game.cookingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('cookProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCookBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCookBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function openCookChicken(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing(); // Also stop smithing
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Cooking - Chicken</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 Raw Chicken.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingChicken;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken;
}

function openKitchenHub() {
  game.shopOpen = false;
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopCookingChicken(); // Stop cooking
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Kitchen</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose something to cook.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start; gap: 10px;">
      <button id="cookChickenBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/cookedchicken.png" alt="Cooked Chicken" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Cook Chicken</span>
      </button>
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const cookChickenBtn = document.getElementById('cookChickenBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');
  
  if (cookChickenBtn) {
    cookChickenBtn.onclick = openCookChicken;
    cookChickenBtn.onmouseenter = (event) => {
      showTooltip(event, 'Requires: 1 Raw Chicken');
    };
    cookChickenBtn.onmouseleave = hideTooltip;
  }
  
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function openCopperBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 2 Copper Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startBlacksmithing;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
}

// +++ NEW COPPER CHESTPLATE UI +++
function openCopperChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${CHESTPLATE_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = stopBlacksmithing; // Use the same stop function
}
// +++ END NEW COPPER CHESTPLATE UI +++

// +++ NEW COPPER SHORTSWORD UI +++
function openCopperShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SHORTSWORD_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = stopBlacksmithing; 
}
// +++ END NEW COPPER SHORTSWORD UI +++

function openBlacksmithHub() {
  game.shopOpen = false;
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Blacksmith</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose an item to smith.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start; gap: 10px;">
      <button id="copperBarBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/copperbar.png" alt="Copper Bar" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Bar</span>
      </button>
      <button id="copperShortswordBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/coppershortsword.png" alt="Copper Shortsword" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Shortsword</span>
      </button>
      <button id="copperChestplateBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/copperchestplate.png" alt="Copper Chestplate" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Chestplate</span>
      </button>
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const copperBarBtn = document.getElementById('copperBarBtn');
  const copperShortswordBtn = document.getElementById('copperShortswordBtn'); 
  const copperChestplateBtn = document.getElementById('copperChestplateBtn'); 
  const returnBtn = document.getElementById('returnToActionsBtn');
  
  if (copperBarBtn) {
    copperBarBtn.onclick = openCopperBarSmith;
    copperBarBtn.onmouseenter = (event) => {
      showTooltip(event, 'Requires: 2 Copper Ore');
    };
    copperBarBtn.onmouseleave = hideTooltip;
  }
  
  if (copperShortswordBtn) {
    copperShortswordBtn.onclick = openCopperShortswordSmith;
    copperShortswordBtn.onmouseenter = (event) => {
      showTooltip(event, `Requires: ${SHORTSWORD_BAR_COST} Copper Bars`);
    };
    copperShortswordBtn.onmouseleave = hideTooltip;
  }
  
  if (copperChestplateBtn) {
    copperChestplateBtn.onclick = openCopperChestplateSmith;
    copperChestplateBtn.onmouseenter = (event) => {
      showTooltip(event, `Requires: ${CHESTPLATE_BAR_COST} Copper Bars`);
    };
    copperChestplateBtn.onmouseleave = hideTooltip;
  }

  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function openCopperMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Beginner Mine - Copper vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A low level copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
}

function openMineHub() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining(); 
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Mines</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose a mine to enter.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
      <button id="copperVeinBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/coppervein.png" alt="Copper Vein" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Vein</span>
      </button>
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const copperBtn = document.getElementById('copperVeinBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (copperBtn) {
    copperBtn.onclick = openCopperMine;
    copperBtn.onmouseenter = (event) => {
      showTooltip(event, 'Lvl Required: 1');
    };
    copperBtn.onmouseleave = hideTooltip;
  }
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function openCombatHub() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining(); 
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Combat Areas</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fighting.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
      
      <button id="farmAreaBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/farm.png" alt="Farm Area" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>The Farm</span>
      </button>
      
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const farmBtn = document.getElementById('farmAreaBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');
  
  if (farmBtn) {
    // This now opens the farm area
    farmBtn.onclick = openFarmCombatArea;
    farmBtn.onmouseenter = (event) => {
      showTooltip(event, 'Lvl Required: 1');
    };
    farmBtn.onmouseleave = hideTooltip;
  }
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function openFarmCombatArea() {
  game.shopOpen = false;
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>The Farm</h2>
    <div style="margin-top:8px; color:#efe3cf;">A peaceful farm, mostly.</div>
    
    <div style="margin-top:20px; text-align:center; cursor:pointer;" onclick="openCombatInterface('Chicken')">
      <img src="images/chickenmonster.png" alt="Chicken" style="height: 100px;">
      <div style="font-weight:bold;">Chicken (Lvl 1)</div>
    </div>
    
    <div class="action-buttons" style="margin-top:14px;">
      <button onclick="openCombatHub()" class="primary" style="background:#666;">Return</button>
    </div>
  `;
}

// NEW: Function to build and open the main combat UI
function openCombatInterface(enemyName) {
  // Stop any skilling
  if (game.miningActive) {
    stopMining();
    game.wasMiningBeforeCombat = true;
  }
  if (game.blacksmithingActive) {
    stopBlacksmithing();
    game.wasSmithingBeforeCombat = true;
  }
  
  // Define our enemy
  if (enemyName === 'Chicken') {
    game.currentEnemy = {
      name: 'Chicken',
      level: 1,
      maxHp: 10,
      currentHp: 10,
      attack: 1, // Low attack level
      strength: 1, // Max hit is 1
      defence: 1, // Low defence
      img: 'images/chickenmonster.png'
    };
  } else {
    console.error('Unknown enemy:', enemyName);
    return;
  }
  
  const wrapper = document.getElementById('mainContentWrapper');
  
  // --- This is the new UI layout you described ---
  wrapper.innerHTML = `
    <div id="combat-main-container">
    
      <div id="combat-enemy-area">
        <img id="combat-enemy-img" src="${game.currentEnemy.img}" alt="${game.currentEnemy.name}">
        <div id="combat-enemy-hp-bar">
          <div id="combat-enemy-hp-fill" style="width:100%"></div>
          <div id="combat-enemy-hp-text">10 / 10 HP</div>
        </div>
      </div>
      
      <div id="combat-player-area">
        
        <div id="combat-equip-panel">
          <div class="equipment-character">
            <div class="character-frame">
              <div class="equipment-row">
                <div class="equipment-slot" id="combat-helmet">
                  </div>
              </div>
              <div class="equipment-row" style="align-items:center;">
                <div class="equipment-slot" id="combat-weapon"></div>
                <div class="equipment-slot" id="combat-chest"></div>
              </div>
              <div class="equipment-row">
                <div class="equipment-slot" id="combat-boots"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div id="combat-action-panel">
          <p style="margin: 0 0 10px 0; font-weight: bold;">Combat Style:</p>
          <div id="combat-styles">
            <button id="style-attack" class="primary" onclick="setAttackStyle('attack')">Accurate</button>
            <button id="style-strength" class="primary" onclick="setAttackStyle('strength')">Aggressive</button>
            <button id="style-defence" class="primary" onclick="setAttackStyle('defence')">Defensive</button>
          </div>
          
          
          <div id="combat-main-actions">
            <button id="combat-fight-btn" class="primary" style="background:#900;" onclick="beginCombat()">Fight</button>
            <button id="combat-run-btn" class="primary" style="background:#080; display:none;" onclick="runFromCombat()">Run</button>
            <button id="combat-return-btn" class="primary" style="background:#555;" onclick="returnToFarm()">Return</button>
          </div>
          
        </div>
      </div>
    </div>
  `;
  
  // Set the default active style button
  setAttackStyle(game.playerAttackStyle, true); 
  // We'll add a function to load the equipment images later
}

function setAttackStyle(style, isInitialization = false) {
  game.playerAttackStyle = style;
  
  // Update button visual state
  const styles = ['attack', 'strength', 'defence'];
  styles.forEach(s => {
    const btn = document.getElementById(`style-${s}`);
    if (btn) {
      if (s === style) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    }
  });
  
  if (!isInitialization) {
    // Line deleted
  }
}




// NEW: Function to start the combat loops
function beginCombat() {
  if (game.inCombat) return; // Prevent starting multiple times
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  
  game.inCombat = true;
  document.getElementById('combat-fight-btn').style.display = 'none'; // HIDE Fight
  document.getElementById('combat-run-btn').style.display = 'block'; // SHOW Run
  document.getElementById('combat-run-btn').disabled = false;
  
  
  // Player attacks every 2.4 seconds (example speed)
  game.playerCombatInterval = setInterval(playerAttackTurn, 2400);
  
  // Enemy (Chicken) attacks every 3.0 seconds (example speed)
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
}

// NEW: Function to stop combat
function runFromCombat(playerDied = false) {
  if (!game.inCombat) return; // Can't run if not in a fight
  
  game.inCombat = false;
  
  // Stop the attack loops
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  game.playerCombatInterval = null;
  game.enemyCombatInterval = null;

  const fightBtn = document.getElementById('combat-fight-btn');
  const runBtn = document.getElementById('combat-run-btn');
  const returnBtn = document.getElementById('combat-return-btn');
  
  if (playerDied) {
    // Player is dead, disable all actions
    if (fightBtn) fightBtn.disabled = true;
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'none';
  } else {
    // Player clicked "Run"
    if (fightBtn) fightBtn.style.display = 'block'; // SHOW Fight
    if (fightBtn) fightBtn.disabled = false;
    if (runBtn) runBtn.style.display = 'none'; // HIDE Run
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'block'; // Show return

    // Reset enemy HP
    if (game.currentEnemy) {
        game.currentEnemy.currentHp = game.currentEnemy.maxHp;
        updateEnemyCombatUI();
    }
  }
}

function returnToFarm() {
  // +++ NEW FIX: Stop combat loops +++
  if (game.inCombat) {
    game.inCombat = false;
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
    game.playerCombatInterval = null;
    game.enemyCombatInterval = null;
  }
  // +++ END FIX +++

  // 1. Go back to the farm screen
  openFarmCombatArea(); 
  
  // 2. Check if we need to resume skilling
  if (game.wasMiningBeforeCombat) {
    openCopperMine(); // Re-opens the mine UI
    startMining();      // Restarts mining
  } else if (game.wasSmithingBeforeCombat) {
    // This is more complex, might need to know *which* item
    openBlacksmithHub(); // Just return to hub for now
  }
  game.wasMiningBeforeCombat = false;
  game.wasSmithingBeforeCombat = false;
}

// NEW: Helper function to update the enemy's HP bar
function updateEnemyCombatUI() {
  if (!game.currentEnemy) return;
  
  const enemy = game.currentEnemy;
  const percent = Math.max(0, (enemy.currentHp / enemy.maxHp) * 100);
  
  const fill = document.getElementById('combat-enemy-hp-fill');
  const text = document.getElementById('combat-enemy-hp-text');
  
  if (fill) fill.style.width = percent + '%';
  if (text) text.textContent = `${enemy.currentHp} / ${enemy.maxHp} HP`;
}

function showDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'flex';
}

/**
 * Hides the death overlay.
 */
function hideDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'none';
}

/**
 * Handles all logic when a player's HP reaches 0.
 */
function handlePlayerDeath() {
  // 1. Wipe inventory
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  renderInventoryGrid();
  
  // 2. Wipe gold
  game.gold = 0;
  updateGoldUI();
  
  // 3. Save the empty state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 4. Show the death modal
  showDeathOverlay();
}

/**
 * Handles the "Revive" button click.
 */
function revivePlayer() {
  // 1. Hide the modal
  hideDeathOverlay();
  
  // 2. Restore HP
  game.hp = game.maxHP;
  updateHPUI();
  
  // 3. Go back to the main hub
  backToActions();
  
  // 4. Save the new HP state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}
// --- END: Death & Revive Functions ---


function showDamageSplat(target, amount, type) {
  let anchorElement = null;
  if (target === 'player') {
    // This finds the player's main hp-bar
    anchorElement = document.getElementById('hpFill').parentElement; 
  } else if (target === 'enemy') {
    anchorElement = document.getElementById('combat-enemy-hp-bar');
  }

  if (!anchorElement) return;

  const splat = document.createElement('div');
  splat.className = 'combat-splat';
  
  if (type === 'damage') {
    splat.classList.add('splat-damage');
    splat.textContent = amount;
  } else { // 'block'
    splat.classList.add('splat-block');
    splat.textContent = '0';
  }
  
  // Randomize horizontal position slightly
  splat.style.right = (Math.floor(Math.random() * 20) - 40) + 'px';
  
  anchorElement.appendChild(splat);
  setTimeout(() => splat.remove(), 850); // Remove just before animation ends
}

function playerAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- 1. Calculate Hit Chance ---
  // Player's Attack vs. Enemy's Defence
  // We'll make it a simple formula. Base 70% chance.
  let hitChance = 70 + (game.attack.level - game.currentEnemy.defence);
  hitChance = Math.max(10, Math.min(90, hitChance)); // Clamp between 10% and 90%

  if (Math.random() * 100 > hitChance) {
    showDamageSplat('enemy', 0, 'block'); // ENEMY MISS
    return;
  }

  // --- 2. Calculate Damage (If Hit) ---
  // Based on your table: Damage = Strength_Lvl (Major) + Attack_Lvl / 6 (Minor)
  // We'll use this formula for the "Max Hit".
  let maxHit = Math.floor(game.strength.level + (game.attack.level / 6));
  if (maxHit < 1) maxHit = 1; // Ensure you can always hit at least a 1
  
  // Damage is a random number from 0 to your max hit
  let damage = Math.floor(Math.random() * (maxHit + 1));

  if (damage > 0) {
    showDamageSplat('enemy', damage, 'damage'); // ENEMY HIT
  } else {
    showDamageSplat('enemy', 0, 'block'); // ENEMY HIT A 0
  }

  // Apply damage to enemy
  game.currentEnemy.currentHp -= damage;
  // Line deleted
  updateEnemyCombatUI();

  // --- 3. Grant XP ---
  if (damage > 0) {
    // Grant XP based on the style you're using
    let mainXPGained = damage * 4; // Example: 4 XP per point of damage
    let skillToTrain = game.playerAttackStyle; // 'attack', 'strength', or 'defence'
    
    addXP(skillToTrain, mainXPGained, 0);
    
    // Per your table, Vitality XP is *always* gained
    let vitalityXPGained = Math.ceil(mainXPGained / 2); // e.g., half of main XP
    addXP('vitality', vitalityXPGained, 450); // <-- This 450ms delay fixes it
  }

  // --- 4. Check for Enemy Death ---
  if (game.currentEnemy.currentHp <= 0) {
    
    // +++ NEW: Add item drop +++
    addItem('Raw Chicken', 1);
    showItemPopup('+1 Raw Chicken', null, 900); // 900ms delay
    
    // Per your request: Respawn the chicken
    game.currentEnemy.currentHp = game.currentEnemy.maxHp;
    updateEnemyCombatUI();
  }
}

// NEW: The Enemy's turn to attack
function enemyAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- 1. Calculate Hit Chance ---
  // "he doesn't hit often"
  // Enemy Attack (1) vs. Player Defence (game.defence.level)
  // We'll give it a very low base chance.
  let hitChance = 25 + (game.currentEnemy.attack - game.defence.level);
  hitChance = Math.max(5, Math.min(50, hitChance)); // Clamp between 5% and 50%
  
  if (Math.random() * 100 > hitChance) {
    showDamageSplat('player', 0, 'block'); // PLAYER MISS
    return;
  }

  // --- 2. Calculate Damage (If Hit) ---
  // "his max hit is 1"
  let maxHit = game.currentEnemy.strength; // This is 1
  let damage = Math.floor(Math.random() * (maxHit + 1)); // Will be 0 or 1

  // TODO: Apply player's Damage Reduction from Defence/Armor here
  
  if (damage > 0) {
    showDamageSplat('player', damage, 'damage'); // PLAYER HIT
  } else {
    showDamageSplat('player', 0, 'block'); // PLAYER HIT A 0
  }
  
  // Apply damage to player
  game.hp -= damage;
  // Line deleted
  updateHPUI(); // Update the player's main HP bar

  // --- 3. Check for Player Death ---
  if (game.hp <= 0) {
    game.hp = 0; // Don't let it go negative
    updateHPUI();
    
    // Stop the fight, passing 'true' to indicate the player died
    runFromCombat(true); 
    
    // Call the new death handler
    handlePlayerDeath();
  }
}

function backToActions(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <div id="actionScreen" style="display: flex; gap: 10px;">
      <img id="minesActionIcon" src="images/mines.png" alt="Mines" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="blacksmithActionIcon" src="images/blacksmithicon.png" alt="Blacksmith" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="shopActionIcon" src="images/shopbutton.png" alt="Shop" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="combatActionIcon" src="images/combatareas.png" alt="Combat Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="kitchenActionIcon" src="images/kitchenbutton.png" alt="Kitchen" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
    </div>
  `;
  const minesIcon = document.getElementById('minesActionIcon');
  const blacksmithIcon = document.getElementById('blacksmithActionIcon');
  const shopIcon = document.getElementById('shopActionIcon'); 
  const combatIcon = document.getElementById('combatActionIcon'); // +++ NEW ICON REFERENCE +++
  const kitchenIcon = document.getElementById('kitchenActionIcon');
  
  if (minesIcon) {
    minesIcon.onclick = openMineHub;
    minesIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Mines</div>');
    };
    minesIcon.onmouseleave = hideTooltip;
  }
  if (blacksmithIcon) {
    blacksmithIcon.onclick = openBlacksmithHub; 
    blacksmithIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Blacksmith</div>');
    };
    blacksmithIcon.onmouseleave = hideTooltip;
  }
  if (shopIcon) {
    shopIcon.onclick = openShop; 
    shopIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
    };
    shopIcon.onmouseleave = hideTooltip;
  }
  
  // +++ NEW COMBAT ICON LOGIC +++
  if (combatIcon) {
    combatIcon.onclick = openCombatHub; 
    combatIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Combat Areas</div>');
    };
    combatIcon.onmouseleave = hideTooltip;
  }
  // +++ END NEW COMBAT LOGIC +++
if (kitchenIcon) {
    kitchenIcon.onclick = openKitchenHub; 
    kitchenIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Kitchen</div>');
    };
    kitchenIcon.onmouseleave = hideTooltip;
  }
  // +++ END NEW KITCHEN LOGIC +++
}

function openShop() {
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  game.shopOpen = true; 
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>General Store</h2>
    <div style="margin-top:8px; color:#efe3cf;">
      Click an item in your inventory to sell it.
    </div>
    <div style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.1); border-radius:6px;">
      <strong>Items you can sell:</strong>
      <ul style="margin: 5px 0 0 20px; padding: 0;">
        <li style="margin-top:5px;">Copper Ore - 1 Gold each</li>
      </ul>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="returnToActionsBtn" class="primary" style="background:#666;">Return</button>
    </div>
  `;
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function resetGameState() {
  stopMining(); 
  stopBlacksmithing();
  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  game.gold = 0; 
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.blacksmith = { level: 1, xp: 0, totalXP: 0 };
  game.cooking = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  game.miningActive = false,
  game.blacksmithingActive = false, // +++ NEW +++
  game.cookingActive = false,
  game.blacksmithingActive = false;
  game.shopOpen = false; 
  game.isAdmin = false;
  
  // +++ NEW: Reset session state +++
  game.isSessionActive = false;
  game.isDragging = false;
  if (typeof window.stopSessionHeartbeat === 'function') {
      window.stopSessionHeartbeat();
  }
  
  if (game.progressFrame) {
    cancelAnimationFrame(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('inventory'); 
  }
}

// --- MODIFIED: Added isDragging logic ---
document.addEventListener('DOMContentLoaded', ()=>{
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
  
  const inventoryGrid = document.getElementById('inventoryGrid');
  let draggedItemIndex = null;
  let currentDragOverSlot = null;
  
  inventoryGrid.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList.contains('inv-slot') && e.target.draggable) {
      draggedItemIndex = parseInt(e.target.dataset.slotIndex);
      e.dataTransfer.effectAllowed = 'move';
      
      // +++ NEW: Set dragging flag +++
      game.isDragging = true;
      
      setTimeout(() => {
        e.target.classList.add('dragging');
      }, 0);
    }
  });

  inventoryGrid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      if (currentDragOverSlot && currentDragOverSlot !== targetSlot) {
        currentDragOverSlot.classList.remove('drag-over');
      }
      targetSlot.classList.add('drag-over');
      currentDragOverSlot = targetSlot;
    }
  });
  
  inventoryGrid.addEventListener('dragleave', (e) => {
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      targetSlot.classList.remove('drag-over');
      if (currentDragOverSlot === targetSlot) {
        currentDragOverSlot = null;
      }
    }
  });

  inventoryGrid.addEventListener('drop', (e) => {
    e.preventDefault();
    const dropSlot = e.target.closest('.inv-slot');
    if (dropSlot && draggedItemIndex !== null) {
      const dropIndex = parseInt(dropSlot.dataset.slotIndex);
      if (draggedItemIndex !== dropIndex) {
        
        // --- This logic needs to be stack-aware ---
        const dragItem = game.inventory[draggedItemIndex];
        const dropItem = game.inventory[dropIndex];
        
        if (dragItem && dropItem && dragItem.name === dropItem.name) {
            // Stacking items
            dropItem.qty += dragItem.qty;
            game.inventory[draggedItemIndex] = null;
        } else {
            // Swapping items
            game.inventory[draggedItemIndex] = dropItem;
            game.inventory[dropIndex] = dragItem;
        }
        
        renderInventoryGrid();
        // +++ NEW: Save immediately after a successful drag/drop +++
        if (typeof window.savePlayerData === 'function') {
            window.savePlayerData();
        }
      }
    }
    
    // Cleanup
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    draggedItemIndex = null;
    // +++ NEW: Clear dragging flag +++
    game.isDragging = false;
  });

  inventoryGrid.addEventListener('dragend', (e) => {
    // Final cleanup
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    draggedItemIndex = null;
    // +++ NEW: Clear dragging flag +++
    game.isDragging = false;
  });
  
});
</script>

<div id="itemContextMenu"></div>

<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc,
    increment // <-- ADD THIS
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";
  
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // +++ --- NEW SESSION LOCK CONSTANTS & FUNCTIONS --- +++
  const LOCK_STALE_TIME_MS = 10000; // 10 seconds
  const LOCK_HEARTBEAT_MS = 999999999;  
  /**
   * (Helper) Gets the player doc ref.
   */
  function getPlayerRef() {
    const user = auth.currentUser;
    if (!user) return null;
    return doc(db, "players", user.uid);
  }

  /**
   * Shows the session lock overlay.
   */
  function showSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'flex';
  }
  
  /**
   * Hides the session lock overlay.
   */
  function hideSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'none';
  }

  /**
   * Starts the heartbeat to keep our session lock fresh.
   */
  // --- REPLACED WITH SIMPLIFIED FUNCTION (starting around line 802) ---
  /**
   * Starts the heartbeat to keep our session lock fresh.
   * NOTE: The active lock refresh logic is now solely handled by the 30s autosave
   * (or a separate manual save), so we only start a passive timer.
   */
  window.startSessionHeartbeat = function() {
    if (game.lockHeartbeat) return; // Already running
    
    // Use the extremely large interval, effectively making this timer passive.
    // The 30s autosave is now the only functional timer.
    game.lockHeartbeat = setInterval(() => {
        // This timer still runs, but the interval is so long it will rarely fire,
        // ensuring the 30s autosave is the primary write source.
    }, LOCK_HEARTBEAT_MS); 
  }

  /**
   * Stops the heartbeat.
   */
  window.stopSessionHeartbeat = function() {
    if (game.lockHeartbeat) {
      clearInterval(game.lockHeartbeat);
      game.lockHeartbeat = null;
    }
  }

  /**
   * Releases the session lock from Firebase.
   * @param {boolean} isAsync - If false, we can't wait for the update (e.g., closing tab).
   */
  window.releaseSessionLock = async function(isAsync = true) {
    stopSessionHeartbeat();
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    // We only release the lock if we are the one holding it.
    try {
      const promise = runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) return;
        const lock = snap.data().activeSession;
        if (lock && lock.id === game.sessionLockId) {
          transaction.update(playerRef, { activeSession: null });
        }
      });
      
      if (isAsync) {
        await promise;
      }
    } catch (e) {
      console.error("Failed to release lock:", e);
    }
  }
  
  /**
   * Tries to acquire the session lock using a transaction.
   * This is called when a lock is free or stale, or when user clicks "Take Control".
   */
  window.acquireSessionLock = async function() {
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    try {
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) throw new Error("Player doc does not exist.");
        
        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();
        
        // Check if a fresh lock is held by another session
        if (lock && lock.id !== game.sessionLockId && (now - lock.timestamp) < LOCK_STALE_TIME_MS) {
          throw new Error("Lock is still fresh and held by another session.");
        }
        
        // Lock is free, stale, or ours. Take it.
        const newLock = { id: game.sessionLockId, timestamp: now };
        transaction.update(playerRef, { activeSession: newLock });
      });
      
      // Success! We are now the active session.
      game.isSessionActive = true;
      
      // *** CRITICAL FIX ***: We no longer call startSessionHeartbeat() 
      // here to prevent the original 3s interval logic from running.
      // We rely purely on the 30s autosave for lock refresh.
      
      // startSessionHeartbeat(); <-- DELETE THIS LINE
      
      hideSessionLockOverlay();
      
    } catch (e) {
      console.error("Failed to acquire lock:", e.message);
      // We failed to get the lock, another tab must have beat us.
      // The onSnapshot listener will handle showing the overlay.
    }
  }
  // +++ --- END NEW SESSION LOCK FUNCTIONS --- +++


  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      
      // +++ NEW: Only the active session can save data +++
      if (!game.isSessionActive) return;
      
      const nameToSave = game.name || "";
      const inventoryToSave = [];
      game.inventory.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: inventoryToSave, 
        gold: game.gold, 
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        blacksmith: {
          level: game.blacksmith.level,
          xp: game.blacksmith.xp,
          totalXP: game.blacksmith.totalXP
        },
        // +++ NEW ATTACK SAVE LOGIC +++
        attack: {
          level: game.attack.level,
          xp: game.attack.xp,
          totalXP: game.attack.totalXP
        },
        // +++ NEW STRENGTH AND DEFENCE SAVE LOGIC +++
        strength: {
          level: game.strength.level,
          xp: game.strength.xp,
          totalXP: game.strength.totalXP
        },
        defence: {
          level: game.defence.level,
          xp: game.defence.xp,
          totalXP: game.defence.totalXP
        },
        // +++ NEW VITALITY SAVE LOGIC +++
        vitality: {
          level: game.vitality.level,
          xp: game.vitality.xp,
          totalXP: game.vitality.totalXP
        },
        // +++ END NEW VITALITY SAVE LOGIC +++
        // +++ NEW COOKING SAVE LOGIC +++
        cooking: {
          level: game.cooking.level,
          xp: game.cooking.xp,
          totalXP: game.cooking.totalXP
        },
        // +++ END NEW VITALITY SAVE LOGIC +++
        playerAttackStyle: game.playerAttackStyle, // <-- ADD THIS
        updatedAt: new Date().toISOString()
        // We don't save activeSession here, that's handled by the lock functions
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- HEAVILY MODIFIED: loadPlayerDataAndStart (now handles session lock) ---
  async function loadPlayerDataAndStart(user) {
    try {
      if (playerDocListener) {
        playerDocListener();
        playerDocListener = null;
      }

      const ref = doc(db, "players", user.uid);
      let isFirstLoad = true; 
      
      playerDocListener = onSnapshot(ref, (snap) => {
        
        if (!snap.exists()) {
          console.log("Player document doesn't exist, showing start screen.");
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return; 
        }

        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();

        // --- 1. SESSION LOCK LOGIC ---
        if (!lock || (now - lock.timestamp > LOCK_STALE_TIME_MS)) {
          // Lock is free or stale. Try to acquire it.
          // We only do this if we're not *already* the active session.
          if (!game.isSessionActive) {
            acquireSessionLock();
          }
        } else if (lock.id !== game.sessionLockId) {
          // Another tab has a fresh lock. We are INACTIVE.
          game.isSessionActive = false;
          stopSessionHeartbeat();
          showSessionLockOverlay();
          // Stop any local actions immediately
          stopMining();
          stopBlacksmithing();
          if (game.inTrade) closeTradeWindow();
        } else {
          // We have the lock. We are ACTIVE.
          game.isSessionActive = true;
          hideSessionLockOverlay();
        }

        // --- 2. DATA SYNC LOGIC ---
        
        // Ignore our own "echo" saves
        if (snap.metadata.hasPendingWrites) {
          return;
        }
        
        // If we are the active tab, AND we are busy (mining, dragging, etc.),
        // do not sync data. This prevents rollbacks.
        if (game.isSessionActive && (game.miningActive || game.blacksmithingActive || game.isDragging)) {
          return;
        }
        
        // If we are INACTIVE, OR we are ACTIVE and IDLE, sync the data.
        game.playerAttackStyle = data.playerAttackStyle || 'strength';

        if (!data.name) {
          // This handles the case right after registration
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return;
        }

        game.name = data.name || game.name || "Adventurer";
        game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
        game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
        
        let loadedInventoryData = data.inventory || [];
        game.inventory = new Array(game.inventoryCapacity).fill(null);
        if (Array.isArray(loadedInventoryData)) {
            if (loadedInventoryData.length > 0 && typeof loadedInventoryData[0].slot === 'number') {
                loadedInventoryData.forEach(item => {
                    if (item && typeof item.slot === 'number' && item.slot < game.inventoryCapacity) {
                        game.inventory[item.slot] = { name: item.name, qty: item.qty };
                    }
                });
            } else if (loadedInventoryData.length > 0) {
                console.log("Migrating (buggy) array inventory...");
                for (let i = 0; i < loadedInventoryData.length && i < game.inventoryCapacity; i++) {
                    if(loadedInventoryData[i]) {
                      game.inventory[i] = { name: loadedInventoryData[i].name, qty: loadedInventoryData[i].qty };
                    }
                }
            }
        } else {
            console.log("Migrating legacy (object) inventory...");
            const entries = Object.entries(loadedInventoryData);
            for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
                game.inventory[i] = { name: entries[i][0], qty: entries[i][1] };
            }
        }
        
        game.gold = (typeof data.gold === 'number') ? data.gold : 0; 
        
        if (data.mining) {
          game.mining.level = data.mining.level || 1;
          game.mining.xp = data.mining.xp || 0;
          game.mining.totalXP = data.mining.totalXP || getTotalXPForLevel(data.mining.level - 1) + data.mining.xp || 0; 
        } else {
          game.mining = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        if (data.blacksmith) {
          game.blacksmith.level = data.blacksmith.level || 1;
          game.blacksmith.xp = data.blacksmith.xp || 0;
          game.blacksmith.totalXP = data.blacksmith.totalXP || getTotalXPForLevel(data.blacksmith.level - 1) + data.blacksmith.xp || 0; 
        } else {
          game.blacksmith = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW ATTACK LOADING LOGIC +++
        if (data.attack) {
          game.attack.level = data.attack.level || 1;
          game.attack.xp = data.attack.xp || 0;
          game.attack.totalXP = data.attack.totalXP || getTotalXPForLevel(data.attack.level - 1) + data.attack.xp || 0; 
        } else {
          game.attack = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW ATTACK LOADING LOGIC +++
        
        // +++ NEW STRENGTH LOADING LOGIC +++
        if (data.strength) {
          game.strength.level = data.strength.level || 1;
          game.strength.xp = data.strength.xp || 0;
          game.strength.totalXP = data.strength.totalXP || getTotalXPForLevel(data.strength.level - 1) + data.strength.xp || 0; 
        } else {
          game.strength = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW STRENGTH LOADING LOGIC +++
        
        // +++ NEW DEFENCE LOADING LOGIC +++
        if (data.defence) {
          game.defence.level = data.defence.level || 1;
          game.defence.xp = data.defence.xp || 0;
          game.defence.totalXP = data.defence.totalXP || getTotalXPForLevel(data.defence.level - 1) + data.defence.xp || 0; 
        } else {
          game.defence = { level: 1, xp: 0, totalXP: 0 }; 
        }
        //
        //

        // +++ NEW VITALITY LOADING LOGIC +++
        if (data.vitality) {
          game.vitality.level = data.vitality.level || 1;
          game.vitality.xp = data.vitality.xp || 0;
          game.vitality.totalXP = data.vitality.totalXP || getTotalXPForLevel(data.vitality.level - 1) + data.vitality.xp || 0; 
        } else {
          game.vitality = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW COOKING LOADING LOGIC +++
        if (data.cooking) {
          game.cooking.level = data.cooking.level || 1;
          game.cooking.xp = data.cooking.xp || 0;
          game.cooking.totalXP = data.cooking.totalXP || getTotalXPForLevel(data.cooking.level - 1) + data.cooking.xp || 0; 
        } else {
          game.cooking = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++

        setText('charName', game.name);
        updateHPUI(); // This now calculates maxHP using game.vitality.level
        renderInventoryGrid();
        updateSkillUI();
        updateGoldUI(); 
        
        if (isFirstLoad) {
          window.renderLeaderboards(); 
          isFirstLoad = false;         
          backToActions(); 
        }
        
        startScreen.style.display = 'none';
        authScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        
      }, (error) => {
        console.error("Player listener error:", error);
        alert("Error loading player data. Please refresh.");
      });
      
      const initialSnap = await getDoc(ref);
      if (!initialSnap.exists() || !initialSnap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false; 
      }

      return true; 
      
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }

  // --- MODIFIED: Added activeSession to new doc ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: [],
        gold: 0, 
        mining: { level: 1, xp: 0, totalXP: 0 },
        blacksmith: { level: 1, xp: 0, totalXP: 0 }, 
        attack: { level: 1, xp: 0, totalXP: 0 }, 
        strength: { level: 1, xp: 0, totalXP: 0 }, 
        defence: { level: 1, xp: 0, totalXP: 0 }, 
        vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY FOR NEW ACCOUNTS +++
        cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING FOR NEW ACCOUNTS +++
        playerAttackStyle: 'strength',
        activeSession: null, // +++ ADD THIS
        createdAt: new Date().toISOString()
      });
      alert("Account created. Now create your character."); 
    } catch (err) {
      alert(err.message || "Registration failed.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      alert(err.message || "Login failed."); 
      console.error(err);
    }
  };

  // --- MODIFIED: Handles session cleanup ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();

      const started = await loadPlayerDataAndStart(user);
      
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
        game.playerAttackStyle = 'strength';
      }
      
      if (started) {
        initChatListener();
        initTradeListeners();
        // The loadPlayerDataAndStart listener will automatically handle
        // acquiring the lock on first load.
      } else {
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // User is logged out
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      
      // Stop listeners and release lock
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();
      stopSessionHeartbeat();
      // We don't release the lock, just let it go stale.
      
      if (window.resetGameState) {
        window.resetGameState();
      }
      isTradeRequestsLoaded = false; 
    }
  });

  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) return alert('Enter a name first.');
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            return alert("That name is already taken. Please choose another.");
          }
        } catch (e) {
          console.error("Name check failed:", e);
          return alert("Error checking name. Please try again.");
        }
        
        originalCreate(); // Sets game.name locally
        
        const user = auth.currentUser;
        if (user) {
          // --- THIS IS THE FIX ---
          // We MUST acquire the session lock *before* trying to save,
          // otherwise savePlayerData() will exit early because
          // game.isSessionActive is false.
          if (typeof window.acquireSessionLock === 'function') {
            await window.acquireSessionLock();
          }

          game.isSessionActive = true;
         

          await window.savePlayerData(); // This will now succeed
          window.renderLeaderboards();
          initChatListener(); 
          initTradeListeners(); 
          // The onSnapshot listener will fire and update the UI
        }
      };
    }
  })();
  
  // --- CHAT FUNCTIONS (Unchanged) ---
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false;
  let playerDocListener = null; 

  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;
    if (messageText.length === 0) return; 
    
    // +++ NEW: Prevent sending chat from inactive tab +++
    if (!game.isSessionActive) {
      alert("This tab is not active. Take control to send messages.");
      return;
    }
    
    chatInput.value = '';
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; 
    }
    if (messageText.length > 256) {
      alert("Message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      alert("You must be logged in and have a character to chat.");
      return;
    }
    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      alert("Failed to send message. Please try again.");
    }
  }
  function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';
    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; 
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    chatMessagesContainer.prepend(msgElement); 
  }
  function initChatListener() {
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      let hasAdds = false; 
      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isChatHistoryLoaded) {
            hasAdds = true; 
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });
      if (!isChatHistoryLoaded) {
        isChatHistoryLoaded = true;
        let hadHistoryMessages = false;
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
        });
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; 
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      else if (hasAdds) {
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        chatMessagesContainer.scrollTop = 0;
      }
    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  
  // --- TRADE FUNCTIONS (Mostly Unchanged) ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; 
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    if (!isChatHistoryLoaded) {
      localMessageQueue.push({ text, type });
    } else {
      _addLocalMessageToDOM(text, type);
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      chatMessagesContainer.scrollTop = 0;
    }
  }
  function convertSavedInvToLocal(savedInvData) {
      const localInv = new Array(game.inventoryCapacity).fill(null);
      if (!Array.isArray(savedInvData)) {
          const entries = Object.entries(savedInvData);
          for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
              localInv[i] = { name: entries[i][0], qty: entries[i][1] };
          }
      } else {
          if (savedInvData.length > 0 && typeof savedInvData[0].slot === 'number') {
              savedInvData.forEach(item => {
                  if (item && item.slot < game.inventoryCapacity) {
                      localInv[item.slot] = { name: item.name, qty: item.qty };
                  }
              });
          } else if (savedInvData.length > 0) {
              for (let i = 0; i < savedInvData.length && i < game.inventoryCapacity; i++) {
                  if (savedInvData[i]) {
                      localInv[i] = { name: savedInvData[i].name, qty: savedInvData[i].qty };
                  }
              }
          }
      }
      return localInv;
  }
  function convertLocalInvToSaved(localInv) {
      const inventoryToSave = [];
      localInv.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      return inventoryToSave;
  }

  // =================================================================
  // --- 3. REPLACED 'checkItem' FUNCTION (module script) ---
  // This function now correctly SUMS all stacks.
  // =================================================================
  function checkItem(localInvArray, itemName, qty) {
      let totalQty = 0;
      for (const slot of localInvArray) {
          if (slot && slot.name === itemName) {
              totalQty += slot.qty;
          }
      }
      return totalQty >= qty;
  }

  // =================================================================
  // --- 4. REPLACED 'modifyInventory' FUNCTION (module script) ---
  // This function now correctly adds/removes from multiple stacks.
  // =================================================================
  function modifyInventory(localInvArray, itemName, qtyChange) {
      // Deep copy the array to avoid modifying the original
      const newInv = JSON.parse(JSON.stringify(localInvArray)); 
      
      if (qtyChange > 0) { // Adding items
          let amountToAdd = qtyChange;
          
          // 1. Try to stack first
          for (const slot of newInv) {
              if (slot && slot.name === itemName) {
                  slot.qty += amountToAdd;
                  amountToAdd = 0;
                  break; 
              }
          }
          
          // 2. If still items left, find an empty slot
          if (amountToAdd > 0) {
              let emptySlotIndex = newInv.findIndex(slot => slot === null);
              if (emptySlotIndex > -1) {
                  newInv[emptySlotIndex] = { name: itemName, qty: amountToAdd };
              } else {
                  // This should be caught by the transaction, but good to have
                  throw new Error(`Inventory full, cannot add ${itemName}.`);
              }
          }
      } else if (qtyChange < 0) { // Removing items
          let amountToRemove = Math.abs(qtyChange);
          
          // 1. Iterate backwards to empty smaller/later stacks first
          for (let i = newInv.length - 1; i >= 0; i--) {
              const slot = newInv[i];
              if (slot && slot.name === itemName) {
                  if (slot.qty > amountToRemove) {
                      // This stack has more than we need
                      slot.qty -= amountToRemove;
                      amountToRemove = 0;
                  } else {
                      // This stack will be emptied
                      amountToRemove -= slot.qty;
                      newInv[i] = null; // Empty the slot
                  }
              }
              if (amountToRemove === 0) break; // We're done
          }
          if (amountToRemove > 0) {
              // This should be impossible if checkItem was called first
              throw new Error(`Tried to remove more ${itemName} than available.`);
          }
      }
      return newInv;
  }
  // =================================================================
  // --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
  // =================================================================

  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);
            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addGold(amount); 
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self gold: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data(); // We still need this for the name
                await updateDoc(doc(db, "players", playerDoc.id), {
                    gold: increment(amount) // Use the atomic increment operation
                });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); 
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; 
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addItem(formattedName, qty); // Uses new addItem
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self item: ${e.message}`, 'error');
                }
                return true;
            }
            // This command now uses the NEW modifyInventory, so it will work
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                let currentLocalInv = convertSavedInvToLocal(playerData.inventory || []);
                const newLocalInv = modifyInventory(currentLocalInv, formattedName, qty); // Uses new modifyInventory
                const newSavedInv = convertLocalInvToSaved(newLocalInv);
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newSavedInv });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            if (skill !== 'mining' && skill !== 'blacksmith') {
                 addLocalChatMessage("Unknown skill. Use 'mining' or 'blacksmith'.", 'error');
                 return true;
            }
            const newTotalXP = getTotalXPForLevel(level); 
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };
            if (targetName === game.name.toLowerCase()) {
                try {
                    game[skill] = newSkillData; 
                    updateSkillUI();
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Set own ${skill} level to ${level}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error setting self level: ${e.message}`, 'error');
                }
                return true;
            }
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { [skill]: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s ${skill} level to ${level}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
    }
    
    // +++ NEW: Check for active session before allowing trade +++
    if (!game.isSessionActive) {
      addLocalChatMessage("This tab is not active. Take control to trade.", 'error');
      return true; // It's a command, but it's blocked.
    }

    if (messageText.startsWith('/trade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    if (messageText.startsWith('/accepttrade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    return false;
  }
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }
      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');
    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);
      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      const requestSnapshot = await getDocs(requestQuery);
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          return data.fromUid === requesterUid; 
      });
      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }
      const requestDoc = validRequests[0]; 
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      await batch.commit();
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); 
    tradeSessionUnsubscribes = []; 
    isTradeRequestsLoaded = false; 
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    // Trade requests are disabled due to maintenance.
    tradeRequestUnsubscribe = onSnapshot(requestQuery, () => {
      isTradeRequestsLoaded = true;
    }, (error) => console.error("Trade request listener error:", error));
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; 
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }
    if (game.blacksmithingActive) {
        stopBlacksmithing();
        game.wasMiningBeforeTrade = true; 
    }
    
    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    
    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    // --- THIS IS THE FIX ---
    // Use the session data to initialize the trade state
    game.myTradeOffer = sessionData[myRole];
    game.theirTradeOffer = sessionData[theirRole];
    // --- END FIX ---
    
    game.myTradeRole = myRole; 

    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    
    // Set the gold input to the *correct* initial value
    document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
    document.getElementById('tradeMyGoldOffer').max = game.gold;
    
    renderTradeInventory(); 
    // Render the grids with the data we just loaded
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); 
    renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems); 
    modal.style.display = 'flex'; 
    if (game.activeTradeListener) game.activeTradeListener(); 
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      const data = doc.data();
      if (data.status === 'cancelled') {
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      if (data.status === 'completed') {
        addLocalChatMessage("Trade complete!", 'trade');
        closeTradeWindow();
        return;
      }
      // --- THIS IS THE FIX ---
      // ONLY update THEIR offer from the snapshot
      game.theirTradeOffer = data[theirRole];
      
      // Manually sync our own "accepted" status
      // This is the ONLY part of our offer we want from the server
      game.myTradeOffer.accepted = data[myRole].accepted;

      // Render THEIR grid (our grid is updated locally)
      // We also update our inventory to show correct available amounts
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      renderTradeInventory();
      
      // We no longer need to check if we're typing, because we are
      // no longer syncing our own gold value from the server.
      
      // ONLY set THEIR gold display
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // Update statuses for both
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);
      // --- END FIX ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';

    // --- Create a map of available items from all stacks ---
    const availableItems = new Map();
    for (const slot of game.inventory) {
        if (slot) {
            const currentQty = availableItems.get(slot.name) || 0;
            availableItems.set(slot.name, currentQty + slot.qty);
        }
    }
    
    // --- Subtract offered items ---
    for (const [name, qty] of Object.entries(game.myTradeOffer.offerItems)) {
        if (availableItems.has(name)) {
            availableItems.set(name, availableItems.get(name) - qty);
        }
    }

    // --- Render the grid based on the calculated map ---
    availableItems.forEach((qtyAvailable, name) => {
      if (qtyAvailable <= 0) return; 

      const slotEl = document.createElement('div');
      slotEl.className = 'inv-slot';
      slotEl.onclick = () => addItemToOffer(name, qtyAvailable); 
      let imgName = name.toLowerCase().replace(/\s+/g,'_');
      if (name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      const img = document.createElement('img');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slotEl.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slotEl.appendChild(amt);
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slotEl.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slotEl.onmouseleave = hideTooltip;
      grid.appendChild(slotEl);
    });
  }
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    const itemEntries = Object.entries(items);
    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        const img = document.createElement('img');
        let imgName = name.toLowerCase().replace(/\s+/g,'_');
        if (name === 'Copper Bar') {
            imgName = 'copperbar';
        }
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }
  async function addItemToOffer(itemName, maxQty) {
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      const input = prompt(`How many ${itemName} do you want to offer? (Max: ${maxQty})`, maxQty);
      if (input === null) return; 
      qtyToOffer = parseInt(input);
    }
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      alert(`You can only offer up to ${maxQty} of this item.`);
      qtyToOffer = maxQty;
    }
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      alert("Your trade offer grid is full (16 unique items).");
      return;
    }
    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 2. Update local UI IMMEDIATELY
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 
    // --- END FIX ---

    try {
      // 3. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; 
    delete newOfferItems[itemName]; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 2. Update local UI IMMEDIATELY
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 
    // --- END FIX ---

    try {
      // 3. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    // --- END FIX ---

    try {
      // 2. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true 
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }
  async function cancelTrade() {
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;
    const sessionId = game.activeTradeSessionId;
    closeTradeWindow(); 
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
      }
    }
  }
  function closeTradeWindow() {
    if (!game.inTrade) return; 
    if (game.activeTradeListener) {
      game.activeTradeListener(); 
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; 
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    renderInventoryGrid();
    updateGoldUI();
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      const startBtn = document.getElementById('startMineBtn');
      const startSmithBtn = document.getElementById('startSmithBtn');
      if (startBtn) {
        startMining();
      } else if (startSmithBtn) { 
        startBlacksmithing();
      }
    }
  }
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);
        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }
        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;
        const p1LocalInv = convertSavedInvToLocal(p1Data.inventory || []);
        const p2LocalInv = convertSavedInvToLocal(p2Data.inventory || []);
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!checkItem(p1LocalInv, item, qty)) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!checkItem(p2LocalInv, item, qty)) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }

        let newP1LocalInv = [...p1LocalInv];
        let newP2LocalInv = [...p2LocalInv];

        // --- These loops now use the NEW 'modifyInventory' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
            newP1LocalInv = modifyInventory(newP1LocalInv, item, -qty);
            newP2LocalInv = modifyInventory(newP2LocalInv, item, +qty);
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
            newP2LocalInv = modifyInventory(newP2LocalInv, item, -qty);
            newP1LocalInv = modifyInventory(newP1LocalInv, item, +qty);
        }
        // --- End of new function usage ---

        const newP1SavedInv = convertLocalInvToSaved(newP1LocalInv);
        const newP2SavedInv = convertLocalInvToSaved(newP2LocalInv);
        transaction.update(sessionRef, { status: 'completed' });
        transaction.update(player1Ref, {
            gold: p1Data.gold - p1Offer.offerGold + p2Offer.offerGold,
            inventory: newP1SavedInv
        });
        transaction.update(player2Ref, {
            gold: p2Data.gold - p2Offer.offerGold + p1Offer.offerGold,
            inventory: newP2SavedInv
        });
      });
    } catch (e) {
      console.error("TRADE FAILED:", e);
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    contentContainer.innerHTML = `
      <div style="text-align:center; margin-top: 20px; color: #fff; opacity: 0.7;">Refreshing...</div>
    `;
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        
        // --- THIS IS THE FIX ---
        // We now get the totalXP from *all* skills and add them together.
        const miningXp = data.mining?.totalXP || 0; 
        const blacksmithXp = data.blacksmith?.totalXP || 0;
        const attackXp = data.attack?.totalXP || 0;
        const strengthXp = data.strength?.totalXP || 0;
        const defenceXp = data.defence?.totalXP || 0;
        const vitalityXp = data.vitality?.totalXP || 0;
        const cookingXp = data.cooking?.totalXP || 0;

        const totalXp = miningXp + blacksmithXp + attackXp + strengthXp + defenceXp + vitalityXp + cookingXp;
        // --- END OF FIX ---

        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // --- MODIFIED: Added Session Lock Button ---
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = async () => {
          if (typeof window.savePlayerData === 'function') {
            await window.savePlayerData();
          }
          window.renderLeaderboards();
        };
    }
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); 
          sendChatMessage();
        }
      });
    }
    
    // +++ NEW: Session Lock Button +++
    const takeControlBtn = document.getElementById('takeControlButton');
    if (takeControlBtn) {
      takeControlBtn.onclick = () => {
        if (typeof window.acquireSessionLock === 'function') {
          window.acquireSessionLock();
        }
      };
    }
  });

  // --- Autosave runs every 30s, but only performs writes if the tab is visible ---
  setInterval(async () => {
    const user = auth.currentUser;

    // Check if user is logged in, is the active session, not in trade, AND THE TAB IS VISIBLE.
    if (user && game.isSessionActive && !game.inTrade && !document.hidden) {
        
      // 1. Refresh Lock Heartbeat (WRITE)
      // This update maintains the lock and prevents other tabs from stealing control.
      const playerRef = getPlayerRef();
      if (playerRef) {
          try {
              await updateDoc(playerRef, { "activeSession.timestamp": Date.now() }); 
          } catch (e) {
              console.error("Autosave Heartbeat failed:", e);
          }
      }
      
      // 2. Perform Full Save (WRITE)
      window.savePlayerData();
    }
    // If document.hidden is true, the timer function exits immediately with no writes.
  }, 30000);

  // --- MODIFIED: Releases session lock on tab close ---
  window.addEventListener('beforeunload', (e) => {
    try {
      // If we are the active session, release the lock
      if (game.isSessionActive) {
        if (typeof window.releaseSessionLock === 'function') {
          // Fire-and-forget, we can't wait for the update
          window.releaseSessionLock(false); 
        }
      }
      
      // Try one last save
      const user = auth.currentUser;
      if (user && game.isSessionActive && !game.inTrade) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // --- MODIFIED: Releases session lock on logout ---
  window.firebaseLogout = async function() {
  try {
    // 1. If in trade, cancel it first (Existing logic)
    if (game.inTrade && game.activeTradeSessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.warn("Could not cancel active trade on logout:", e);
      }
      closeTradeWindow();
    }
    
    // 2. +++ NEW CRITICAL FIX +++: Release the session lock explicitly
    if (game.isSessionActive) {
      if (typeof window.releaseSessionLock === 'function') {
        // Await the lock release before doing anything else
        await window.releaseSessionLock(true);
      }
    }
    stopSessionHeartbeat();
    
    // 3. Save, then sign out
    await window.savePlayerData();
    await signOut(auth);
    
    alert("Logged out."); 
  } catch (e) {
    console.error("Logout failed:", e);
    alert("Logout failed. Please try again or close your browser.");
  }
};
</script>
</body>
</html>