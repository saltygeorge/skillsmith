<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  /* --- ADD THIS LINE --- */
  --panel-noise: linear-gradient(rgba(0,0,0,0.03), rgba(0,0,0,0.03));
  
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}

/* --- NEW MASTER PANEL STYLE --- */
.sidebar, 
.main, 
.chat-panel, 
.trade-content, 
#sessionLockOverlay div, 
#deathOverlay div, 
.settings-modal, 
.game-modal, 
#statsPanel {
  /* 1. Original brown color */
  background-color: var(--panel-bg);
  
  /* 2. Subtle noise texture on top */
  background-image: var(--panel-noise);
  
  /* 3. New 3D "Bevel" Border */
  border: 4px solid #453625; /* Fallback */
  border-top-color: #7c644c;    /* Lighter top */
  border-left-color: #7c644c;   /* Lighter left */
  border-bottom-color: #3f2b21; /* Darker bottom */
  border-right-color: #3f2b21;  /* Darker right */
  
  /* 4. Same shadow and radius */
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
}

body {
  margin: 0;
  font-family: "Garamond", serif;
  background: #3f2b21;
  background-image: url('images/brickbackground.png');
  background-size: cover;
  background-attachment: fixed;
  background-position: center center;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;

  /* --- ADD THESE LINES --- */
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none;     /* IE 10+ */
  -moz-user-select: none;    /* Firefox */
  user-select: none;         /* Standard */
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- Panel Row Wrappers --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch;
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- Spacer for Chat Panel --- */
.sidebar-spacer {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0;
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  padding: 16px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.char-header { display: flex; justify-content: center; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px;
}

.hp-bar { background: #772222; border-radius: 6px; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

#equipmentTab {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  justify-content: space-between; /* This pushes the button to the bottom */
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { 
  display: grid;
  grid-template-columns: repeat(3, var(--slot-size));
  gap: var(--slot-gap);
  /* All the old flexbox and width properties are gone */
}
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  position: relative; /* <-- THIS IS THE FIX */
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  padding: 0; 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 3501; /* <-- THIS IS THE FIX */
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- Custom Scrollbar --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px;
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Main area --- */
.main {
  flex: 1;
  padding: 18px;
  min-height: 500px; 
  position: relative;

  /* --- NEW: Added flex properties --- */
  display: flex;
  flex-direction: column;
}

.bank-content-wrapper {
  /* This overrides the standard padding from the parent containers (like .main or #mainContentWrapper) */
  padding: 0 10px 10px 10px; /* Adjust top/bottom padding as needed, but reduce left/right */
  width: 100%;
  box-sizing: border-box; /* Crucial for preventing width overflow */
}

#mainContentWrapper {
  flex-grow: 1;     /* Allows this wrapper to fill the panel's height */
  overflow-y: auto;   /* ADDS A SCROLLBAR if content is too tall */
  min-height: 0;      /* A flexbox fix to allow shrinking/scrolling */
  
  /* --- NEW: Add custom scrollbar --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

#mainContentWrapper::-webkit-scrollbar {
  width: 8px;
}
#mainContentWrapper::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Chat Panel --- */
.chat-panel {
  padding: 18px;
  display: flex; 
  flex-direction: column;
  min-height: 200px;
  flex-shrink: 0;
  flex: 1;
}
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}
#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}

/* --- Action Progress --- */
.progress-container {
  background: #7c644c;
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}

.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }
.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}

.progress-text {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  pointer-events: none; /* Lets clicks pass through */
}

button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

/* --- NEW WARNING POPUP --- */
.warning-popup {
  position: absolute;
  background: rgba(221, 68, 68, 0.9); /* Red background */
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1501; /* Above XP popup */
  transform-origin: center;
  animation: fadeOutWarning 3000ms ease-out forwards; /* 3 second animation */
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
@keyframes fadeOutWarning {
  0% { transform: translateY(0); opacity: 1; }
  80% { transform: translateY(-30px); opacity: 1; }
  100% { transform: translateY(-40px); opacity: 0; }
}
/* --- END NEW --- */

/* --- Trade Modal --- */
#tradeModal { display: none; }
.trade-content {
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}
.trade-main-area { display: flex; gap: 20px; flex: 1; }
.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}
.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img { width: 30px; height: 30px; }
#tradeInventoryGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}
.trade-offer-layout { display: flex; gap: 20px; }
.trade-offer-box { flex: 1; display: flex; flex-direction: column; }
.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}
#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}
.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}

/* --- Drag & Drop --- */
.inv-slot.dragging {
  opacity: 0.4;
  cursor: grabbing;
}
.inv-slot.drag-over {
  border-color: var(--gold);
  border-style: dashed;
  background: rgba(181, 166, 66, 0.1);
}

/* +++ NEW: SESSION LOCK OVERLAY +++ */
#sessionLockOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#sessionLockOverlay div {
  padding: 30px 40px;
  max-width: 400px;
}
#sessionLockOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}

#deathOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5001; /* Higher than session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#deathOverlay div {
  padding: 30px 40px;
  max-width: 400px;
}
#deathOverlay h2 {
  margin-top: 0;
  color: #ff4d4d; /* Red for death */
}
/* +++ END NEW STYLES +++ */

/* --- NEW: Broadcast Overlay Style --- */
#broadcastOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5002; /* Above death/session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#broadcastOverlay div {
  /* This uses the master panel style */
  padding: 30px 40px;
  max-width: 400px;
}
#broadcastOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}
/* --- END NEW --- */

#combat-main-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#combat-enemy-area {
  flex-basis: 200px; /* Reduced from 220px */
  flex-shrink: 0;
  text-align: center;
  position: relative;
  margin-bottom: 15px;
}

#combat-enemy-img {
  max-height: 150px; /* Reduced from 180px */
  max-width: 100%;
  object-fit: contain;
}

#combat-enemy-hp-bar {
  background: #772222;
  border-radius: 6px;
  /* overflow: hidden; */ /* <-- This is the fix */
  position: relative;
  height: 28px;
  width: 80%;
  max-width: 300px;
  margin: 10px auto 0 auto;
  border: 2px solid #333;
}

#combat-enemy-hp-fill {
  height: 100%;
  background: #d22;
  width: 100%;
  transition: width 0.25s;
}

#combat-enemy-hp-text {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  font-size: 13px;
}

#combat-player-area {
  flex-grow: 1;
  display: flex;
  gap: 20px;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  justify-content: center; /* <-- ADDED THIS to center the buttons */
}


#combat-action-panel {
  /* flex-grow: 1; has been removed */
  display: flex;
  flex-direction: column;
}

#combat-styles {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

#combat-styles button {
  flex: 1;
  padding: 12px;
  border: 2px solid var(--accent);
  background: var(--accent);
  opacity: 0.7;
}

#combat-styles button.active {
  background: var(--accent-hover);
  border-color: var(--gold);
  opacity: 1.0;
}


#combat-main-actions {
  display: flex;
  gap: 10px;
  flex-direction: column; /* Stack buttons */
}

#combat-main-actions button {
  /* flex: 1; removed */
  font-size: 16px;
}
/* --- END: Combat UI Styles --- */

.combat-splat {
  position: absolute;
  right: -40px; /* Moved over to center the new box */
  top: -5px;    /* Moved up slightly */
  font-size: 1.2rem;
  font-weight: bold;
  pointer-events: none;
  z-index: 1600;
  animation: rise 900ms ease-out forwards;
  
  /* --- NEW "BOX" STYLES --- */
  background: rgba(10, 10, 10, 0.75);
  border: 1px solid #000;
  border-radius: 6px;
  padding: 3px 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}

.splat-damage {
  color: #ff4d4d; /* Bright red */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

.splat-block {
  color: #6dafff; /* Bright blue */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

/* --- NEW: Item Context Menu --- */
#itemContextMenu {
  display: none;
  position: fixed;
  z-index: 3000;
  background: var(--panel-bg);
  border: 2px solid #453625;
  border-radius: 6px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  padding: 5px;
  min-width: 100px;
}
.context-menu-btn {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 4px;
  text-align: left;
  cursor: pointer;
  font-weight: 700;
}
.context-menu-btn:hover {
  background: var(--accent-hover);
}
/* --- END: Item Context Menu --- */

#bankGrid, #shopGrid {
  /* Set the number of columns */
  grid-template-columns: repeat(5, var(--slot-size)); 
  
  /* --- CRITICAL FIX: Re-add centering and set min-width on its WRAPPER --- */
  /* This ensures the grid is centered again */
  justify-content: center; 
}
/* --- END NEW RULE --- */

/* --- NEW: Bank UI Styles --- */

#bankContainer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
#bankGoldPanel {
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  /* This will put the input/button group on one side and "Banked Gold" on the other */
  justify-content: space-between; 
  align-items: center;
  flex-wrap: wrap;
  gap: 20px; /* Increased gap a bit for balance */
  margin-top: -10px;
}
#bankGoldPanel > div {
  text-align: center;
}
#bankGoldPanel .gold-display {
  font-size: 18px;
  font-weight: bold;
  color: var(--gold);
}
#bankGoldPanel input {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  width: 120px;
}
#bankGridPanels {
  display: flex;
  gap: 20px;
}
#bankPanel, #bankInventoryPanel {
  flex: 1;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  /* --- CRITICAL FIX: Add min-width to prevent panel from shrinking --- */
  min-width: 400px; 
}
#bankPanel h3, #bankInventoryPanel h3 {
  margin: 0 0 10px 0;
  text-align: center;
}
#bankGridWrap {
  /* flex: 1; <-- REMOVED */
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
  /* 4-row height */
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
}

#shopGridWrap {
  /* This wrap will now auto-size to its content */
  overflow-y: hidden; /* Prevent scrollbar */
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  height: auto !important; /* <-- THIS IS THE FIX */
  padding: var(--slot-gap);
  box-sizing: border-box;
}

#gameModalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4000;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  box-sizing: border-box;
}
.game-modal {
  padding: 20px;
  width: 100%;
  max-width: 450px;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.game-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.game-modal-content {
  font-size: 16px;
  line-height: 1.5;
  margin-bottom: 20px;
}
.game-modal-input {
  width: 100%;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 16px;
  box-sizing: border-box; /* Important */
}
.game-modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

#equipmentStats {
  /* This style is now used by the pop-up panel */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
}
.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 4px;
  font-size: 15px;
}
.stat-row:not(:last-child) {
  border-bottom: 1px solid var(--accent);
}
.stat-label {
  color: #efe3cf;
  font-weight: bold;
}
.stat-value {
  color: var(--gold);
  font-weight: bold;
}
/* --- END: Equipment Stats Display --- */

/* --- NEW: Locked Item/Vein Style --- */
.locked-item {
  opacity: 0.4;
  filter: grayscale(80%);
  cursor: not-allowed !important;
}
.locked-item:hover {
  background: var(--accent) !important; /* Prevents hover effect */
}
/* --- END: Locked Item/Vein Style --- */

.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

/* --- NEW: Smithing Tab Active State --- */
.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

#settingsBtn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: 2px; /* <-- FIX: Changed from 18px */
  width: 22px;
  height: 22px;
  background: transparent; 
  border: 0;
  outline: none;
  border-radius: 6px;
  cursor: pointer;
  padding: 0; 
  box-sizing: border-box;
  z-index: 10;
}
#settingsBtn:hover {
  background: transparent; /* <-- FIX: Keep background transparent on hover */
  opacity: 0.8; /* <-- Add a subtle hover effect instead */
}
#settingsBtn img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none; /* Let clicks pass to the button */
}

.setting-row label {
  font-weight: bold;
  font-size: 16px;
  flex-basis: 110px; /* Give labels a fixed width to align sliders */
  flex-shrink: 0;
}
.setting-mute-btn {
  min-width: 80px; /* Make mute buttons smaller */
  padding: 8px 10px;
  margin-left: 15px; /* Space from slider */
}

/* --- NEW: Settings Modal --- */
#settingsModalOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4500; /* Below session lock, above trade */
  justify-content: center;
  align-items: center;
}
.settings-modal {
  padding: 20px;
  width: 90%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
}
.settings-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
  gap: 15px;
}
.setting-row label {
  font-weight: bold;
  font-size: 16px;
}
.volume-slider {
  flex-grow: 1;
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 12px;
  background: #3f2b21;
  border: 1px solid #453625;
  border-radius: 6px;
  outline: none;
}
.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}
.volume-slider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}

/* --- NEW: Hub Screen Toggler --- */
.hub-screen {
  display: none; /* Hide all hubs by default */
  width: 100%;
  height: 100%;
  flex-direction: column;
}
.hub-screen.active {
  display: flex; /* Show the active one */
}
/* --- END NEW --- */

/* --- NEW: Stats Panel --- */
#statsPanel {
  visibility: hidden; /* <-- THIS IS THE FIX: Hide but keep space */
  display: flex;      /* <-- THIS IS THE FIX: Set the display type */
  
  /* This width perfectly matches the .sidebar panel above it */
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  
  /* This height perfectly matches the .chat-panel next to it */
  min-height: 200px; 
  
  /* New layout styles */
  padding: 16px;
  box-sizing: border-box;
  flex-direction: column;
  flex-shrink: 0;
  
  /* We remove all the 'position: fixed' rules */
}
#statsPanelHeader {
  font-size: 18px;
  font-weight: bold;
  color: var(--gold);
  margin: -5px -5px 10px -5px;
  padding: 5px 10px;
  border-bottom: 2px solid var(--accent);
  /* cursor: move;  <-- THIS LINE IS DELETED */
}
#statsPanelContent {
  /* We can re-use the .stat-row styles here */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
}
#statsPanelFooter {
  display: flex;
  justify-content: flex-end;
  margin-top: 15px;
}
/* --- END: Stats Panel --- */

/* --- NEW: Updates Panel --- */
#updatesContent {
  /* Set a fixed height to make it scrollable */
  height: 112px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  display: flex; 
  flex-direction: column; /* Normal top-to-bottom flow */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#updatesContent::-webkit-scrollbar { width: 8px; }
#updatesContent::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
#updatesContent::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }
#updatesContent::-webkit-scrollbar-thumb:hover { background: var(--accent-hover); }

.update-message {
  margin-bottom: 8px;
  line-height: 1.4;
  font-size: 13px;
  word-break: break-word;
  /* Add a small border like the leaderboard */
  padding-bottom: 8px;
  border-bottom: 1px dashed rgba(255,255,255,0.1);
}
.update-message:last-child {
  border-bottom: none;
  margin-bottom: 0;
}
.update-message strong {
  color: var(--gold);
  display: block; /* Timestamp on its own line */
  font-size: 12px;
  opacity: 0.8;
  margin-bottom: 3px;
}
/* --- END: Updates Panel --- */

/* --- NEW: Loading Bar --- */
#loading-bar-container {
  width: 100%;
  background: #3f2b21;
  border: 2px solid var(--accent);
  border-radius: 8px;
  padding: 3px;
  margin-top: 15px;
  box-sizing: border-box;
  position: relative;
  height: 28px;
}
#loading-bar-fill {
  width: 0%;
  height: 100%;
  background: var(--gold);
  border-radius: 4px;
  transition: width 0.1s ease-out; /* A fast transition */
}
#loading-progress-percent {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  color: #fff;
  font-weight: bold;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
}
/* --- END: Loading Bar --- */


</style>
</head>
<body>

<div id="loadingScreen" style="display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background: #3f2b21; z-index: 10000;">
  <!-- Make the container a bit wider to fit the bar -->
  <div style="text-align: center; color: var(--gold); font-size: 20px; font-weight: bold; width: 300px;">
    Loading assets...
    <!-- NEW Progress Bar Structure -->
    <div id="loading-bar-container">
      <div id="loading-bar-fill"></div>
      <div id="loading-progress-percent">0%</div>
    </div>
    <!-- END Progress Bar -->
  </div>
</div>

<div id="authScreen" style="display:none; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header" style="position: relative;">
          <h2 id="charName">Player</h2>
          <button id="settingsBtn" onmouseenter="showTooltip(event, 'Settings')" onmouseleave="hideTooltip()">
            <img src="images/gearicon.png" alt="Settings">
          </button>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-slot" id="necklace">
                  <img src="images/necklace.png" alt="Necklace">
                </div>
                <div class="equipment-slot" id="helmet">
                  <img src="images/helmet.png" alt="Helmet">
                </div>
                <div class="equipment-slot" id="cape">
                  <img src="images/cape.png" alt="Cape">
                </div>
                <div class="equipment-slot" id="weapon">
                  <img src="images/weapon.png" alt="Weapon">
                </div>
                <div class="equipment-slot" id="chest">
                  <img src="images/chestplate.png" alt="Chest">
                </div>
                <div class="equipment-slot" id="shield">
                  <img src="images/shield.png" alt="Shield">
                </div>
                <div class="equipment-slot" id="ring1">
                  <img src="images/ring.png" alt="Ring 1">
                </div>
                <div class="equipment-slot" id="legs">
                  <img src="images/legs.png" alt="Legs">
                </div>
                <div class="equipment-slot" id="ring2">
                  <img src="images/ring.png" alt="Ring 2">
                </div>
                <div class="equipment-slot" id="arrows">
                  <img src="images/arrows.png" alt="Arrows">
                </div>
                <div class="equipment-slot" id="boots">
                  <img src="images/boots.png" alt="Boots">
                </div>
              </div>
            </div>

            <div id="statsButtonContainer" style="display: flex; justify-content: flex-end; margin-top: 20px;">
                <button class="primary" id="toggleStatsBtn">Stats</button>
            </div>
            </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
  <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
    <img src="images/goldpouch.png" alt="Gold" style="width: 40px; height: 40px; object-fit: contain;">
    <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 0px;">0</span>
  </div>
              
</div>
            
          </div>
          
          <div id="skillsTab" style="display:none;">
            </div>
          
        </div>
      </div>

      <div class="main" id="mainArea">

        <div id="mainContentWrapper">
        
          <div id="hubActions" class="hub-screen">
            <div id="actionScreen" style="display: flex; gap: 10px; flex-wrap: wrap;">
              <img id="minesActionIcon" src="images/mines.png" alt="Mines" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="fishingActionIcon" src="images/fishingareasbutton.jpeg" alt="Fishing Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="forestActionIcon" src="images/foresticon.png" alt="Forest" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="blacksmithActionIcon" src="images/blacksmithicon.png" alt="Blacksmith" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="fletchingActionIcon" src="images/fletchingworkbench.png" alt="Fletching" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="kitchenActionIcon" src="images/kitchenbutton.png" alt="Kitchen" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="combatActionIcon" src="images/combatareas.png" alt="Combat Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="shopActionIcon" src="images/shopbutton.png" alt="Shop" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="bankActionIcon" src="images/bankbutton.png" alt="Bank" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="craftingActionIcon" src="images/craftingbenchbutton.png" alt="Crafting" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
            </div>
          </div>

          <div id="hubCrafting" class="hub-screen">
            <h2>Crafting Bench</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to craft.</div>
            <div id="craftingItemsContainer" class="action-buttons" style="margin-top: 14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubCrafting_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubMine" class="hub-screen">
            <h2>Mine</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a vein to mine.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="copperVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coppervein.png" alt="Copper Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="coalVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coalvein.png" alt="Coal Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="ironVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/ironvein.png" alt="Iron Vein" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubMine_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubBlacksmith" class="hub-screen">
            <h2>Blacksmithing</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to smith.</div>
            <div class="tabs" style="margin-top: 14px; margin-bottom: 14px; width: 100%;">
              <button id="smithCopperTab" class="active">Copper</button>
              <button id="smithIronTab">Iron</button>
            </div>
            <div id="smithingItemsContainer" class="action-buttons" style="margin-top: 0; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubBlacksmith_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>

          <div id="hubFletching" class="hub-screen">
            <h2>Fletching</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an item to fletch.</div>
            <div id="fletchingItemsContainer" class="action-buttons" style="margin-top: 14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubFletching_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubForest" class="hub-screen">
            <h2>Forest</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a tree to chop.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="softwoodTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/softwood.png" alt="Softwood Tree" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="oakTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/oak.png" alt="Oak Tree" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubForest_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubKitchen" class="hub-screen">
            <h2>Kitchen</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose something to cook.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              
              <button id="cookChickenBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedchicken.png" alt="Cooked Chicken" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>

              <button id="cookHerringBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedherring.png" alt="Cooked Herring" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="cookTroutBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedtrout.png" alt="Cooked Trout" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="cookSalmonBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/cookedsalmon.png" alt="Cooked Salmon" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
              </button>

            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubKitchen_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubCombat" class="hub-screen">
            <h2>Combat Areas</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fighting.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
              <button id="farmAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0;">
  <img src="images/farm.png" alt="Farm Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
</button>
              <button id="caveAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0; margin-top: 10px;">
  <img src="images/cave.png" alt="Cave Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
</button>
              <button id="hubCombat_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubCave" class="hub-screen">
            <h2>The Cave</h2>
            <div style="margin-top:8px; color:#efe3cf;">A dark, damp cave.</div>
            
            <div style="margin-top:20px; text-align:center; cursor:pointer;" onclick="openCombatInterface('Spider')">
              <img src="images/spidermonster.png" alt="Spider" style="height: 100px;">
              <div style="font-weight:bold;">Spider (Lvl 2)</div>
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubCave_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          <div id="hubShop" class="hub-screen">
            <h2>General Store</h2>
            
            <div style="display: flex; flex-direction: column; gap: 20px; margin-top: 16px; width: 100%;">
            
              <div style="background:rgba(0,0,0,0.1); border-radius:6px; padding: 10px 15px; display: flex; flex-direction: column;">
                <h3 style="margin:0 0 10px 0; color: var(--gold); text-align: center;">Items for Sale</h3>
                
                <div class="inventory-grid-wrap" id="shopGridWrap">
                  <div class="inventory-grid" id="shopGrid">
                    </div>
                </div>
              </div>
              
            </div>
            
            <div class="action-buttons" style="margin-top:20px;">
              <button id="hubShop_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          <div id="hubBank" class="hub-screen">
            <div id="bankContainer" style="width: 100%;">
              <div class="bank-content-wrapper"> 
                <div id="bankGoldPanel">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="number" id="bankGoldInput" min="0" placeholder="Amount...">
                    <button id="bankDepositGoldBtn" class="primary">Deposit</button>
                    <button id="bankWithdrawGoldBtn" class="primary">Withdraw</button>
                  </div>
                  <div>
                    <div>Banked Gold</div>
                    <div id="bankStoredGold" class="gold-display">0</div>
                  </div>
                </div>
                <div id="bankPanel">
                  <h3>Bank Storage</h3>
                  <div class="inventory-grid-wrap" id="bankGridWrap">
                    <div class="inventory-grid" id="bankGrid"></div>
                  </div>
                </div>
              </div>
              <div class="action-buttons" style="margin-top:0px; align-self: flex-start;">
                <button id="hubBank_ReturnBtn" class="primary" style="background:#666;">Return</button>
              </div>
            </div>
          </div>

          <div id="hubFarm" class="hub-screen">
            <h2>The Farm</h2>
            <div style="margin-top:8px; color:#efe3cf;">A peaceful farm, mostly.</div>
            
            <!-- NEW: Flex container for monsters -->
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Chicken')">
                <img src="images/chickenmonster.png" alt="Chicken" style="height: 100px;">
                <div style="font-weight:bold;">Chicken (Lvl 1)</div>
              </div>
              
              <div style="text-align:center; cursor:pointer;" onclick="openCombatInterface('Cow')">
                <img src="images/cowmonster.png" alt="Cow" style="height: 100px;">
                <div style="font-weight:bold;">Cow (Lvl 2)</div>
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubFarm_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          <div id="hubDynamic" class="hub-screen">
            </div>

          <div id="hubFishingAreas" class="hub-screen">
            <h2>Fishing Areas</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fishing.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
              
              <button id="oceanAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/oceanbutton.png" alt="Ocean Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="riverAreaBtn" class="primary" style="width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; padding: 0; margin-top: 10px;">
                <img src="images/riverbutton.jpeg" alt="River Area" style="width: 80px; height: 80px; border-radius: 4px; object-fit: contain;">
              </button>
              
              <button id="hubFishingAreas_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubOcean" class="hub-screen">
            <h2>The Ocean</h2>
            <div style="margin-top:8px; color:#efe3cf;">The vast, open ocean.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div id="fishHerringBtn" style="text-align:center; cursor:pointer;" onclick="openFishHerring()">
                <img src="images/herring.png" alt="Herring" style="height: 100px;">
                
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubOcean_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          <div id="hubRiver" class="hub-screen">
            <h2>The River</h2>
            <div style="margin-top:8px; color:#efe3cf;">A fast-flowing river.</div>
            
            <div style="margin-top:20px; display:flex; justify-content: center; align-items: flex-end; gap: 40px; flex-wrap: wrap;">
              
              <div id="fishTroutBtn" style="text-align:center; cursor:pointer;" onclick="openFishTrout()">
                <img src="images/trout.png" alt="Trout" style="height: 100px;">
              
              </div>
              
              <div id="fishSalmonBtn" style="text-align:center; cursor:pointer;" onclick="openFishSalmon()">
                <img src="images/salmon.png" alt="Salmon" style="height: 100px;">
                
              </div>
            
            </div>
            
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubRiver_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          </div> <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>

        <h3 style="margin: 20px 0 8px 0; font-size: 18px; color: #fff; border-top: 2px solid var(--accent); padding-top: 15px;">Latest Updates</h3>
        <div id="updatesContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading updates...</div>
        </div>
        <div style="height: 24px;"> <div id="saveTimerText" style="visibility: hidden; margin-top: 10px; text-align: right; font-size: 11px; color: #aaffaa; font-weight: bold;">
              Progress Saved!
          </div>
        </div>
        </div>

    </div> 
    
    <div id="bottom-row-chat">

      <div id="statsPanel">
  <div id="statsPanelHeader">Player Stats</div>
  <div id="statsPanelContent">
    <div class="stat-row">
      <span class="stat-label">Physical Damage</span>
      <span class="stat-value" id="stat-phys-dmg-panel">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Armor</span>
      <span class="stat-value" id="stat-armor-panel">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Speed Bonus</span>
      <span class="stat-value" id="stat-speed-panel">0</span>
    </div>
  </div>
  <div id="statsPanelFooter">
    <button id="closeStatsBtn" class="primary" style="background:#666;">Close</button>
  </div>
</div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div class="sidebar-spacer"></div>

    </div> 
    
  </div> 
</div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<div id="sessionLockOverlay" style="display: none;">
  <div>
    <h2>Session Active Elsewhere</h2>
    <p>This account is already being played in another tab or browser. To prevent data corruption, this tab has been disabled.</p>
    <button id="takeControlButton" class="primary">Take Control Here</button>
  </div>
</div>

<div id="deathOverlay" style="display: none;">
  <div>
    <h2>You died!</h2>
    <p>You lost all your inventory and gold.</p>
    <button id="reviveBtn" class="primary" onclick="revivePlayer()">Revive</button>
  </div>
</div>

<!-- NEW: Settings Modal -->
<div id="settingsModalOverlay">
  <div class="settings-modal">
    <div class="settings-modal-title">Settings</div>
    
    <div class="setting-row">
      <label for="sfxVolumeSlider">Sound Effects</label>
      <input type="range" id="sfxVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="sfxMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="setting-row">
      <label for="musicVolumeSlider">Music</label>
      <input type="range" id="musicVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="musicMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="action-buttons" style="margin-top: 10px; justify-content: flex-end;">
      <button id="closeSettingsBtn" class="primary" style="background:#666;">Close</button>
    </div>
  </div>
 
<div id="broadcastOverlay" style="display: none; z-index: 5002;"> <div>
    <h2 style="color: var(--gold);">System Update</h2>
    <p id="broadcastMessage" style="font-size: 16px; line-height: 1.5;">
      A new game update is live! Please refresh your browser to continue.
    </p>
    </div>
</div>
<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  settings: { 
    sfxVolume: 0.5, 
    isSfxMuted: false, 
    musicVolume: 0.15,  // <--- Changed this from 0.3
    isMusicMuted: false 
  },
  inventory: [], 
  inventoryCapacity: 39,
  gold: 0,
  // --- NEW BANK PROPERTIES ---
  bank: [],
  bankCapacity: 60, // Example: 80 slots
  bankGold: 0,
  // --- END NEW ---
  equipment: {
    necklace: null, // <-- NEW
    helmet: null,
    cape: null,     // <-- NEW
    weapon: null,
    chest: null,
    shield: null,   // <-- NEW
    ring1: null,    // <-- NEW
    legs: null,     // <-- NEW
    ring2: null,    // <-- NEW
    arrows: null,   // <-- NEW
    boots: null
  },
  mining: { level: 1, xp: 0, totalXP: 0 },
  blacksmith: { level: 1, xp: 0, totalXP: 0 },
  attack: { level: 1, xp: 0, totalXP: 0 }, 
  strength: { level: 1, xp: 0, totalXP: 0 }, 
  defence: { level: 1, xp: 0, totalXP: 0 }, 
  vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY SKILL +++
  cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING SKILL +++
  woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING SKILL +++
  miningActive: false,
  blacksmithingActive: false,
  cookingActive: false,
  woodcuttingActive: false, // +++ NEW WOODCUTTING STATE +++
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, 
  isAdmin: false,
  inCombat: false,
  playerAttackStyle: 'strength', // Default to strength
  currentEnemy: null,
  playerCombatInterval: null,
  enemyCombatInterval: null,
  wasMiningBeforeCombat: false, // Renamed from 'wasMiningBeforeTrade'
  wasSmithingBeforeCombat: false,
  wasWoodcuttingBeforeCombat: false,
  fletching: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW FLETCHING SKILL +++
  fletchingActive: false, // +++ NEW FLETCHING STATE +++
  wasFletchingBeforeCombat: false, // +++ NEW FLETCHING STATE +++

  // +++ NEW CRAFTING SKILL +++
  crafting: { level: 1, xp: 0, totalXP: 0 },
  craftingActive: false,
  wasCraftingBeforeCombat: false,
  
  // +++ NEW RANGED SKILL +++
  ranged: { level: 1, xp: 0, totalXP: 0 },
  
  // +++ NEW FISHING SKILL +++
  fishing: { level: 1, xp: 0, totalXP: 0 },
  fishingActive: false,
  wasFishingBeforeCombat: false,
  
  lastSmithingTab: 'copper',
  lastCombatAreaHub: 'hubActions', // +++ NEW +++
  
  // +++ NEW SESSION LOCK +++
  // This is a unique ID for this specific tab
  sessionLockId: (function() {
  let id = sessionStorage.getItem('gameSessionId');
  if (!id) {
    // No ID exists, so this is a new tab. Create one.
    id = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    sessionStorage.setItem('gameSessionId', id);
  }
  // Return the persistent ID for this tab
  return id;
})(),
// +++ END MODIFICATION +++

lockHeartbeat: null,    // This will hold the setInterval ID for the heartbeat
isSessionActive: false, // Is this tab the "master" tab?
isDragging: false,      // Are we currently dragging an item?

inTrade: false,
activeTradeSessionId: null,
activeTradeListener: null, 
myTradeRole: null, 
myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};
// +++ END MODIFICATION +++

game.inventory = new Array(game.inventoryCapacity).fill(null);
game.bank = new Array(game.bankCapacity).fill(null);

// --- NEW: Music Player State ---
const musicPlaylist = [
  'sounds/music/music1.mp3',
  'sounds/music/music2.mp3',
  'sounds/music/music3.mp3',
  'sounds/music/music4.mp3'
];
let currentTrackIndex = 0;
const musicPlayer = new Audio(); 
musicPlayer.loop = false;
let audioAutoplayBlocked = false; // We handle the loop to change tracks
// --- END NEW ---

/**
 * Finds the highest tier tool of a specific type in the player's inventory.
 * @param {('pickaxe'|'axe')} toolType - The type of tool to look for.
 * @returns {number} The tier level (0 for none, 1 for Bronze, 2 for Copper, etc.)
 */
function getBestTool(toolType) {
  const tiers = (toolType === 'pickaxe') ? PICKAXE_TIERS : AXE_TIERS;
  let bestTier = 0;

  for (const slot of game.inventory) {
    if (slot && tiers[slot.name]) {
      if (tiers[slot.name] > bestTier) {
        bestTier = tiers[slot.name];
      }
    }
  }
  return bestTier;
}

/**
 * Updates the music player's volume/mute state from game.settings
 */
function updateMusicPlayerState() {
  if (game.settings.isMusicMuted) {
    musicPlayer.volume = 0;
  } else {
    musicPlayer.volume = game.settings.musicVolume;
  }
}

/**
 * Plays the next track in the playlist.
 */
function playNextTrack() {
  if (musicPlaylist.length === 0) return; 

  currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
  musicPlayer.src = musicPlaylist[currentTrackIndex];

  updateMusicPlayerState(); // Apply current volume settings

  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- NEW "CLICK ANYWHERE" FIX ---
      if (!audioAutoplayBlocked) { // Only add this listener ONCE
        audioAutoplayBlocked = true;

        // Listen for the *first* click or tap anywhere
        const interactionListener = () => {
          resumeMusicAfterInteraction();
          // Clean up this listener so it doesn't run again
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- END NEW ---

    });
  }
}

/**
 * Starts the music playlist for the first time.
 */
function startMusicPlaylist() {
  // Set up the listener for *all future songs*
  musicPlayer.addEventListener('ended', playNextTrack);

  // Set the volume before playing
  updateMusicPlayerState(); 

  // --- NEW: Pick a random song to start ---
  currentTrackIndex = Math.floor(Math.random() * musicPlaylist.length);
  musicPlayer.src = musicPlaylist[currentTrackIndex];
  // --- END NEW ---

  // Manually start the first song (we copy this logic from playNextTrack)
  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- This is the "click anywhere" fix ---
      if (!audioAutoplayBlocked) { 
        audioAutoplayBlocked = true;

        const interactionListener = () => {
          resumeMusicAfterInteraction();
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- End fix ---

    });
  }
}

/**
 * Tries to resume music playback after a user interaction.
 */
function resumeMusicAfterInteraction() {
  // Check if music is supposed to be on but is paused
  if (!game.settings.isMusicMuted && musicPlayer.paused) {
    const resumePromise = musicPlayer.play();

    if (resumePromise !== undefined) {
      resumePromise.then(() => {
        // SUCCESS! Autoplay is now unblocked.
        audioAutoplayBlocked = false; 
      }).catch(e => {
        // Still failed? Oh well.
        console.warn("Could not resume music.", e);
      });
    }
  }
}

const VALID_ITEMS = [
  'Bronze Pickaxe', // +++ NEW +++
  'Bronze Axe',     // +++ NEW +++
  'Copper Pickaxe', // +++ NEW +++
  'Copper Axe',     // +++ NEW +++
  'Iron Pickaxe',   // +++ NEW +++
  'Iron Axe',       // +++ NEW +++
  'Softwood',
  'Oak',
  'Copper Ore',
  'Copper Bar',
  'Copper Chestplate',
  'Copper Shortsword',
  'Copper Helmet', 
  'Copper Boots', 
  'Raw Chicken',
  'Cooked Chicken',
  'Burnt Chicken',
  'Coal Ore',
  'Iron Ore',
  'Iron Bar',
  'Iron Helmet',
  'Iron Chestplate',
  'Iron Boots',
  'Iron Shortsword',
  'Feather', // +++ NEW +++
  'Arrow Shaft', // +++ NEW +++
  'Copper Arrow Tip', // +++ NEW +++
  'Unbound Arrow', // +++ NEW +++
  'Copper Arrow', // +++ NEW +++
  'Copper Platelegs', // +++ NEW +++
  'Iron Platelegs', // +++ NEW +++
  'Silk', // +++ NEW +++
  
  // +++ NEW CRAFTING/FLETCHING ITEMS +++
  'Bow String',
  'Unstrung Softwood Bow',
  'Unstrung Oak Bow',
  'Softwood Bow',
  'Oak Bow',
  
  // +++ NEW LEATHER ITEMS +++
  'Cow Hide',
  'Leather',
  'Leather Hood',
  'Leather Body',
  'Leather Chaps',
  'Leather Boots',
  
  // +++ NEW FISHING ITEMS +++
  'Herring',
  'Trout',
  'Salmon',
  'Fishing Pole',
  'Fishing Bait',

  // +++ NEW COOKED FISH +++
  'Cooked Herring',
  'Burnt Herring',
  'Cooked Trout',
  'Burnt Trout',
  'Cooked Salmon',
  'Burnt Salmon'
];

const XP_TABLE = [
  0,        // Level 1
  83,       // Level 2
  174,      // Level 3
  276,      // Level 4
  388,      // Level 5
  512,      // Level 6
  650,      // Level 7
  801,      // Level 8
  969,      // Level 9
  1154,     // Level 10
  1358,     // Level 11
  1584,     // Level 12
  1833,     // Level 13
  2107,     // Level 14
  2411,     // Level 15
  2746,     // Level 16
  3115,     // Level 17
  3523,     // Level 18
  3973,     // Level 19
  4470,     // Level 20
  5018,     // Level 21
  5624,     // Level 22
  6291,     // Level 23
  7028,     // Level 24
  7842,     // Level 25
  8740,     // Level 26
  9730,     // Level 27
  10824,    // Level 28
  12031,    // Level 29
  13363,    // Level 30
  14833,    // Level 31
  16456,    // Level 32
  18247,    // Level 33
  20224,    // Level 34
  22436,    // Level 35
  24898,    // Level 36
  27673,    // Level 37
  30779,    // Level 38
  33648,    // Level 39
  37224,    // Level 40
  41171,    // Level 41
  45542,    // Level 42
  50339,    // Level 43
  55649,    // Level 44
  61512,    // Level 45
  67983,    // Level 46
  75127,    // Level 47
  83014,    // Level 48
  91721,    // Level 49
  101333,   // Level 50
  111945,   // Level 51
  123660,   // Level 52
  136615,   // Level 53
  150872,   // Level 54
  166636,   // Level 55
  184040,   // Level 56
  203254,   // Level 57
  224446,   // Level 58
  247866,   // Level 59
  273742,   // Level 60
  302288,   // Level 61
  333804,   // Level 62
  368599,   // Level 63
  407015,   // Level 64
  449426,   // Level 65
  496254,   // Level 66
  547953,   // Level 67
  605032,   // Level 68
  668051,   // Level 69
  737637,   // Level 70
  814445,   // Level 71
  899252,   // Level 72
  992895,   // Level 73
  1096245,  // Level 74
  1210210,  // Level 75
  1336486,  // Level 76
  1475581,  // Level 77 (Using 1,475,581)
  1629200,  // Level 78 (Using 1,629,200)
  1798808,  // Level 79
  1986068,  // Level 80
  2192818,  // Level 81
  2421027,  // Level 82
  2673114,  // Level 83
  2951373,  // Level 84 (Using 2,951,373)
  3258594,  // Level 85
  3597292,  // Level 86
  3972294,  // Level 87 (Using 3,972,294)
  4385776,  // Level 88
  4842295,  // Level 89
  5346332,  // Level 90 (Using 5,346,332)
  5902831,  // Level 91
  6517253,  // Level 92
  7195629,  // Level 93
  7944614,  // Level 94
  8771588,  // Level 95
  9684577,  // Level 96
  10692629, // Level 97
  11805606, // Level 98
  13034031, // Level 99
  15000000  // Level 100: Custom value
];

// --- NEW: Fishing Level Requirements ---
const HERRING_FISH_LVL = 1;
const TROUT_FISH_LVL = 5;
const SALMON_FISH_LVL = 10;

// --- NEW: Fishing Action Constants ---
const FISHING_TIME_MS = 20000; // 20 seconds per fish

const HERRING_FISH_XP = 10;
const TROUT_FISH_XP = 20;
const SALMON_FISH_XP = 35;


const CHESTPLATE_BAR_COST = 10;
const CHESTPLATE_XP = 50; // Defining a standard XP gain for the item

// +++ NEW SHORTSWORD CONSTANTS +++
const SHORTSWORD_BAR_COST = 5;
const SHORTSWORD_XP = 32;
const SHORTSWORD_TIME_MS = 5000;
// +++ END NEW CONSTANTS +++
const HELMET_BAR_COST = 5;
const HELMET_XP = 32; // Same as shortsword
const HELMET_TIME_MS = 5000; // Same as shortsword
// +++ END NEW CONSTANTS +++

// +++ NEW BOOTS CONSTANTS +++
// +++ NEW BOOTS CONSTANTS +++
const BOOTS_BAR_COST = 4;
const BOOTS_XP = 26; // 4 bars (~6.5xp/bar)
const BOOTS_TIME_MS = 4000; // 4 bars (1s/bar)

// +++ NEW PLATELEGS CONSTANTS +++
const COPPER_PLATELEGS_BAR_COST = 6;
const COPPER_PLATELEGS_XP = 39; // 6 bars (~6.5xp/bar)
const COPPER_PLATELEGS_TIME_MS = 6000; // 6 bars (1s/bar)
// +++ END NEW CONSTANTS +++

// --- NEW: Mining Level Requirements ---
const COAL_MINE_LVL = 5;
const IRON_MINE_LVL = 10;

// --- NEW: Coal/Iron Mining Constants ---
const COAL_MINE_TIME_MS = 2000;
const COAL_MINE_XP = 20;
const COAL_MINE_ITEM = 'Coal Ore';

const IRON_MINE_TIME_MS = 3000;
const IRON_MINE_XP = 35;
const IRON_MINE_ITEM = 'Iron Ore';

const MINE_COOLDOWN_COPPER_MS = 1000; // 1.0s
const MINE_COOLDOWN_COAL_MS = 1500;   // 1.5s
const MINE_COOLDOWN_IRON_MS = 1500;   // 1.5s

// --- NEW: Blacksmith Level Requirements ---
const COPPER_BAR_LVL = 1;
const COPPER_PICKAXE_LVL = 2;
const COPPER_AXE_LVL = 2;
const COPPER_SWORD_LVL = 3;
const BLACKSMITH_COPPER_TIPS_LVL = 4; // +++ NEW +++
const COPPER_BOOTS_LVL = 5;
const COPPER_HELMET_LVL = 6;
const COPPER_PLATELEGS_LVL = 7; // +++ NEW +++
const COPPER_CHEST_LVL = 8;

const IRON_BAR_LVL = 11;
const IRON_PICKAXE_LVL = 12;
const IRON_AXE_LVL = 12;
const IRON_SWORD_LVL = 13;
const IRON_BOOTS_LVL = 15;
const IRON_HELMET_LVL = 16;
const IRON_PLATELEGS_LVL = 17; // +++ NEW +++
const IRON_CHEST_LVL = 18;

// --- NEW: Fletching Level Requirements ---
const FLETCHING_SHAFT_LVL = 1;
const FLETCHING_UNBOUND_LVL = 1;
const FLETCHING_COPPER_ARROW_LVL = 1;
const FLETCHING_UNSTRUNG_SOFTWOOD_LVL = 5; // +++ NEW +++
const FLETCHING_SOFTWOOD_BOW_LVL = 7;      // +++ NEW +++
const FLETCHING_UNSTRUNG_OAK_LVL = 15;     // +++ NEW +++
const FLETCHING_OAK_BOW_LVL = 17;          // +++ NEW +++

// --- NEW: Fletching Crafting Constants ---
const ARROW_SHAFT_WOOD_COST = 4;
const ARROW_SHAFT_YIELD = 10;
const ARROW_SHAFT_XP = 10;
const ARROW_SHAFT_TIME_MS = 3000;

const UNBOUND_ARROW_SHAFT_COST = 10;
const UNBOUND_ARROW_FEATHER_COST = 10;
const UNBOUND_ARROW_YIELD = 10;
const UNBOUND_ARROW_XP = 20;
const UNBOUND_ARROW_TIME_MS = 4000;

const COPPER_ARROW_UNBOUND_COST = 10;
const COPPER_ARROW_TIP_COST = 10;
const COPPER_ARROW_YIELD = 10;
const COPPER_ARROW_XP = 30;
const COPPER_ARROW_TIME_MS = 4000;

// +++ NEW: Bow Fletching Constants +++
const UNSTRUNG_SOFTWOOD_WOOD_COST = 1;
const UNSTRUNG_SOFTWOOD_YIELD = 1;
const UNSTRUNG_SOFTWOOD_XP = 20;
const UNSTRUNG_SOFTWOOD_TIME_MS = 3000;

const UNSTRUNG_OAK_WOOD_COST = 1;
const UNSTRUNG_OAK_YIELD = 1;
const UNSTRUNG_OAK_XP = 35;
const UNSTRUNG_OAK_TIME_MS = 4000;

const SOFTWOOD_BOW_UNSTRUNG_COST = 1;
const SOFTWOOD_BOW_STRING_COST = 1;
const SOFTWOOD_BOW_YIELD = 1;
const SOFTWOOD_BOW_XP = 25;
const SOFTWOOD_BOW_TIME_MS = 3000;

const OAK_BOW_UNSTRUNG_COST = 1;
const OAK_BOW_STRING_COST = 1;
const OAK_BOW_YIELD = 1;
const OAK_BOW_XP = 45;
const OAK_BOW_TIME_MS = 4000;

// --- NEW: Smithing Constants (Arrow Tips) ---
const COPPER_ARROW_TIP_BAR_COST = 4;
const COPPER_ARROW_TIP_YIELD = 10;
const COPPER_ARROW_TIP_XP = 20;
const COPPER_ARROW_TIP_TIME_MS = 3000;

// +++ NEW: Crafting Skill Constants +++
const CRAFTING_BOW_STRING_LVL = 1;
const BOW_STRING_SILK_COST = 2;
const BOW_STRING_YIELD = 1;
const BOW_STRING_XP = 15;
const BOW_STRING_TIME_MS = 2500;

// +++ NEW: Leather Crafting Constants +++
const CRAFTING_LEATHER_LVL = 1;
const LEATHER_HIDE_COST = 1;
const LEATHER_XP = 5;
const LEATHER_TIME_MS = 1500;

const CRAFTING_LEATHER_HOOD_LVL = 3;
const LEATHER_HOOD_LEATHER_COST = 2; // Changed from HIDE_COST
const LEATHER_HOOD_XP = 20;
const LEATHER_HOOD_TIME_MS = 3000;

const CRAFTING_LEATHER_BODY_LVL = 7;
const LEATHER_BODY_LEATHER_COST = 5; // Changed from HIDE_COST
const LEATHER_BODY_XP = 50;
const LEATHER_BODY_TIME_MS = 6000;

const CRAFTING_LEATHER_CHAPS_LVL = 5;
const LEATHER_CHAPS_LEATHER_COST = 3; // Changed from HIDE_COST
const LEATHER_CHAPS_XP = 30;
const LEATHER_CHAPS_TIME_MS = 4000;

const CRAFTING_LEATHER_BOOTS_LVL = 1;
const LEATHER_BOOTS_LEATHER_COST = 1; // Changed from HIDE_COST
const LEATHER_BOOTS_XP = 10;
const LEATHER_BOOTS_TIME_MS = 2000;


// --- NEW: Iron Smithing Constants ---
const IRON_BAR_ORE_COST = 1; // 1 Iron Ore
const IRON_BAR_COAL_COST = 2; // 1 Coal Ore
const IRON_BAR_XP = 30;
const IRON_BAR_TIME_MS = 6000;

const IRON_HELMET_BAR_COST = 5;
const IRON_HELMET_XP = 150; 
const IRON_HELMET_TIME_MS = 7000; 

const IRON_CHESTPLATE_BAR_COST = 10;
const IRON_CHESTPLATE_XP = 300; 
const IRON_CHESTPLATE_TIME_MS = 12000; 

const IRON_BOOTS_BAR_COST = 4;
const IRON_BOOTS_XP = 120; 
const IRON_BOOTS_TIME_MS = 6000; 

// +++ NEW PLATELEGS CONSTANTS +++
const IRON_PLATELEGS_BAR_COST = 6;
const IRON_PLATELEGS_XP = 180; // 6 bars (30xp/bar)
const IRON_PLATELEGS_TIME_MS = 9000; // 6 bars (1.5s/bar)
// +++ END NEW CONSTANTS +++ 

const IRON_SHORTSWORD_BAR_COST = 5;
const IRON_SHORTSWORD_XP = 150;
const IRON_SHORTSWORD_TIME_MS = 7000;

// --- NEW: Woodcutting Level Requirements ---
const SOFTWOOD_TREE_LVL = 1;
const OAK_TREE_LVL = 10;

// --- NEW: Woodcutting Chop Constants ---
const SOFTWOOD_CHOP_TIME_MS = 1500;
const SOFTWOOD_CHOP_XP = 15;
const SOFTWOOD_CHOP_ITEM = 'Softwood';

const OAK_CHOP_TIME_MS = 3000;
const OAK_CHOP_XP = 35;
const OAK_CHOP_ITEM = 'Oak';

const CHOP_COOLDOWN_SOFTWOOD_MS = 1000;
const CHOP_COOLDOWN_OAK_MS = 1500;

// --- NEW: Tool Crafting Requirements ---
const COPPER_AXE_BAR_COST = 3;
const COPPER_AXE_WOOD_COST = 2;
const COPPER_AXE_XP = 25;
const COPPER_AXE_TIME_MS = 4000;

const COPPER_PICKAXE_BAR_COST = 4;
const COPPER_PICKAXE_WOOD_COST = 2;
const COPPER_PICKAXE_XP = 30;
const COPPER_PICKAXE_TIME_MS = 4500;

const IRON_AXE_BAR_COST = 3;
const IRON_AXE_WOOD_COST = 2;
const IRON_AXE_XP = 120;
const IRON_AXE_TIME_MS = 6000;

const IRON_PICKAXE_BAR_COST = 4;
const IRON_PICKAXE_WOOD_COST = 2;
const IRON_PICKAXE_XP = 140;
const IRON_PICKAXE_TIME_MS = 6500;

// --- NEW: Tool Tier Definitions ---
const PICKAXE_TIERS = { "Bronze Pickaxe": 1, "Copper Pickaxe": 2, "Iron Pickaxe": 3 };
const AXE_TIERS = { "Bronze Axe": 1, "Copper Axe": 2, "Iron Axe": 3 };

// --- NEW: Central Item Stat Definitions ---
const ITEM_STATS = {
  // --- Copper (Fighter) ---
  'Copper Helmet': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Chestplate': {
    armor: 2,
    armorType: 'fighter'
  },
  'Copper Boots': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Platelegs': {
    armor: 1,
    armorType: 'fighter'
  },
  'Copper Shortsword': {
    damage: 1,
    styleBonus: 1, // Bonus for 'attack' style
    weaponType: 'melee'
  },
  
  // --- Iron (Fighter) ---
  'Iron Helmet': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Chestplate': {
    armor: 3,
    armorType: 'fighter'
  },
  'Iron Boots': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Platelegs': {
    armor: 2,
    armorType: 'fighter'
  },
  'Iron Shortsword': {
    damage: 2,
    styleBonus: 1, // Bonus for 'attack' style
    weaponType: 'melee'
  },
  
  // --- Leather (Ranged) ---
  'Leather Hood': {
    armor: 1,
    speed: 1,
    armorType: 'ranged'
  },
  'Leather Body': {
    armor: 2,
    speed: 2,
    armorType: 'ranged'
  },
  'Leather Chaps': {
    armor: 1,
    speed: 1,
    armorType: 'ranged'
  },
  'Leather Boots': {
    armor: 0,
    speed: 1,
    armorType: 'ranged'
  },

  // --- Bows (Ranged) ---
  'Softwood Bow': {
    damage: 2,
    speed: 3,
    weaponType: 'ranged'
  },
  'Oak Bow': {
    damage: 3,
    speed: 3,
    weaponType: 'ranged'
  }
};
const SHOP_INVENTORY = new Array(20).fill(null);
SHOP_INVENTORY[0] = { name: 'Bronze Pickaxe', price: 10 };
SHOP_INVENTORY[1] = { name: 'Bronze Axe', price: 10 };
SHOP_INVENTORY[2] = { name: 'Fishing Pole', price: 2500 };
SHOP_INVENTORY[3] = { name: 'Fishing Bait', price: 10 };
// You can add more items here like:
// SHOP_INVENTORY[4] = { name: 'Some Item', price: 50 };

// --- NEW: Item Sell Prices ---
const ITEM_SELL_PRICES = {
  'Silk': 2, // +++ NEW +++
  // Ores & Resources
  'Copper Ore': 1,
  'Coal Ore': 2,
  'Iron Ore': 4,
  'Softwood': 1,
  'Oak': 3,
  
  // Bars
  'Copper Bar': 3,
  'Iron Bar': 10,
  
  // Food
  'Raw Chicken': 1,
  'Cooked Chicken': 2,
  'Burnt Chicken': 1,
  
  // Bronze Tools (Shop items)
  'Bronze Pickaxe': 4,
  'Bronze Axe': 4,
  
  // Copper Items
  'Copper Pickaxe': 15,
  'Copper Axe': 15,
  'Copper Helmet': 20,
  'Copper Chestplate': 40,
  'Copper Platelegs': 25, // +++ NEW +++
  'Copper Boots': 15,
  'Copper Shortsword': 20,
  
  // Iron Items
  'Iron Pickaxe': 50,
  'Iron Axe': 50,
  'Iron Helmet': 60,
  'Iron Chestplate': 120,
  'Iron Platelegs': 75, // +++ NEW +++
  'Iron Boots': 55,
  'Iron Shortsword': 65,

  // Fletching Items
  'Feather': 1,
  'Arrow Shaft': 1,
  'Copper Arrow Tip': 2,
  'Unbound Arrow': 3,
  'Copper Arrow': 5,
  
  // +++ NEW CRAFTING/FLETCHING ITEM SELL PRICES +++
  'Bow String': 3,
  'Unstrung Softwood Bow': 5,
  'Unstrung Oak Bow': 10,
  'Softwood Bow': 10,
  'Oak Bow': 20,
  'Cow Hide': 4,
  'Leather': 6,
  'Leather Hood': 10,
  'Leather Body': 25,
  'Leather Chaps': 15,
  'Leather Boots': 8,
  
  // +++ NEW FISHING PRICES +++
  'Herring': 2,
  'Trout': 4,
  'Salmon': 8,
  
  // +++ NEW COOKED FISH PRICES +++
  'Cooked Herring': 3,
  'Burnt Herring': 1,
  'Cooked Trout': 6,
  'Burnt Trout': 2,
  'Cooked Salmon': 10,
  'Burnt Salmon': 4,
  
  // +++ NEW FISHING REQUIREMENTS SELL PRICES +++
  'Fishing Pole': 1000,
  'Fishing Bait': 4
};
// --- END: Item Sell Prices ---

// --- END: Item Stat Definitions ---

function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) return n.toString();
  if (n < 1000000) return parseFloat((n / 1000).toFixed(2)) + 'k';
  return parseFloat((n / 1000000).toFixed(2)) + 'M';
}

function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  renderEquipment(); // <-- ADD THIS
  backToActions(); 
}

function updateHPUI(){
  // Calculate new maxHP based on Vitality level (1 HP per level starting at Lvl 1)
  game.maxHP = 10 + (game.vitality ? (game.vitality.level - 1) : 0);
  
  // Ensure current HP doesn't exceed max HP after a level up
  game.hp = Math.min(game.hp, game.maxHP); 
  
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}


/**
 * Calculates all player combat stats based on levels and equipment.
 */
function getPlayerCombatStats() {
  // 1. Get equipped weapon type
  let equippedWeaponType = 'melee'; // Default
  if (game.equipment.weapon && ITEM_STATS[game.equipment.weapon.name]) {
    equippedWeaponType = ITEM_STATS[game.equipment.weapon.name].weaponType || 'melee';
  }
  
  // 2. Base Stats from *Equipment Only*
  let equipmentStats = {
    equipmentDamage: 0, 
    equipmentArmor: 0, 
    equipmentSpeed: 0,
  };

  // 3. Add Equipment Bonuses (with new penalty logic)
  for (const [slotType, item] of Object.entries(game.equipment)) {
    if (item && ITEM_STATS[item.name]) {
      const itemStats = ITEM_STATS[item.name];
      const itemArmorType = itemStats.armorType; // 'fighter', 'ranged', or undefined

      // --- Add Damage (no penalties) ---
      equipmentStats.equipmentDamage += itemStats.damage || 0;

      // --- Add Armor (no penalty) ---
      let armorBonus = itemStats.armor || 0;
      equipmentStats.equipmentArmor += armorBonus;
      
      // --- Add Speed (with penalty) ---
      let speedBonus = itemStats.speed || 0; // Get the item's base speed

      if (equippedWeaponType === 'melee' && itemArmorType === 'ranged') {
        // *** NEW MELEE PENALTY ***
        // Melee user wearing light armor gets a speed penalty.
        // This flat -3 penalty will add +0.3s to the attack time PER PIECE.
        speedBonus = -3;
        
      } else if (equippedWeaponType === 'ranged' && itemArmorType === 'fighter') {
        // *** NEW HARSH PENALTY ***
        // Ranged user wearing heavy armor gets a HUGE speed penalty.
        // This flat -7.5 penalty will add +0.75s to the attack time PER PIECE.
        speedBonus = -7.5; 
      }
      
      equipmentStats.equipmentSpeed += speedBonus;

      // --- Add Style Bonus (Melee only) ---
      if (itemStats.weaponType === 'melee' && game.playerAttackStyle === 'attack') {
        equipmentStats.equipmentDamage += itemStats.styleBonus || 0;
      }
    }
  }
  
  // 4. Calculate Final Stats (Base + Skills + Equipment)
  const finalStats = {};
  const isRanged = (equippedWeaponType === 'ranged');
  const style = game.playerAttackStyle;

  // --- Define Style Bonuses ---
  let styleDamageBonus = 0;
  let styleArmorBonus = 0;
  let styleAccuracyBonus = 0;
  let offensiveSkillLevel = 0; // This will be Ranged Lvl or Attack Lvl

  if (style === 'aggressive') {
    styleDamageBonus = 2;
    styleAccuracyBonus = -5;
  } else if (style === 'accurate') {
    styleDamageBonus = -1;
    styleAccuracyBonus = 10;
  } else if (style === 'defence') {
    styleDamageBonus = -1;
    styleArmorBonus = 2;
    styleAccuracyBonus = -5;
  }
  
  // --- Physical Damage ---
  let skillMaxHit = 0;
  if (isRanged) {
    skillMaxHit = 1 + Math.floor(game.ranged.level / 4);
    offensiveSkillLevel = game.ranged.level;
  } else {
    skillMaxHit = 1 + Math.floor(game.strength.level / 4);
    offensiveSkillLevel = game.attack.level;
  }
  finalStats.physicalDamage = Math.max(1, skillMaxHit + equipmentStats.equipmentDamage + styleDamageBonus);

  // --- Armor ---
  const skillArmor = Math.floor(game.defence.level / 5);
  finalStats.armor = skillArmor + equipmentStats.equipmentArmor + styleArmorBonus;
  
  // --- Attack Speed ---
  const speedReduction = equipmentStats.equipmentSpeed * 100; // 0.1s per speed point
  finalStats.attackSpeed = Math.max(1200, 4000 - speedReduction); // 4.0s base
  
  // --- Pass offensive skill and accuracy bonus ---
  finalStats.offensiveSkillLevel = offensiveSkillLevel;
  finalStats.accuracyBonus = styleAccuracyBonus;
  
  // Also pass through the equipment-only bonuses for the UI display
  finalStats.equipmentDamage = equipmentStats.equipmentDamage;
  finalStats.equipmentArmor = equipmentStats.equipmentArmor;
  finalStats.equipmentSpeed = equipmentStats.equipmentSpeed;
  
  return finalStats;
}


/**
 * Renders the equipment in both the main sidebar and combat UI.
 */
function renderEquipment() {
  // --- 1. Calculate current stats ---
  const stats = getPlayerCombatStats();
  
  // --- 2. Update the Stats Display (in the new panel) ---
  setText('stat-phys-dmg-panel', `+${stats.equipmentDamage}`);
  setText('stat-armor-panel', `+${stats.equipmentArmor}`);
  // --- MODIFICATION: Show equipment speed bonus, not final time ---
  const speedBonus = stats.equipmentSpeed;
  const speedText = speedBonus >= 0 ? `+${speedBonus}` : `${speedBonus}`; // Show + sign for positive
  setText('stat-speed-panel', speedText);
  // --- END MODIFICATION ---

  // --- NEW: Add tooltips to the stats panel rows ---
  
  // 1. Get the parent row for each stat
  const dmgRow = document.getElementById('stat-phys-dmg-panel')?.closest('.stat-row');
  const armorRow = document.getElementById('stat-armor-panel')?.closest('.stat-row');
  const speedRow = document.getElementById('stat-speed-panel')?.closest('.stat-row');

  // 2. Damage Tooltip
  if (dmgRow) {
    const dmgValue = stats.equipmentDamage >= 0 ? `+${stats.equipmentDamage}` : stats.equipmentDamage;
    dmgRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${dmgValue} Physical Damage</div>`);
    dmgRow.onmouseleave = hideTooltip;
  }

  // 3. Armor Tooltip
  if (armorRow) {
    const armorValue = stats.equipmentArmor >= 0 ? `+${stats.equipmentArmor}` : stats.equipmentArmor;
    armorRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${armorValue} Armor</div>`);
    armorRow.onmouseleave = hideTooltip;
  }

  // 4. Speed Tooltip (Shows final attack speed in seconds)
  if (speedRow) {
    const finalSpeedInSeconds = (stats.attackSpeed / 1000).toFixed(1);
    speedRow.onmouseenter = (evt) => showTooltip(evt, `<div style="color:#aaffaa;">${finalSpeedInSeconds}s Attack Speed</div>`);
    speedRow.onmouseleave = hideTooltip;
  }
  
  // --- END NEW ---

  // --- 3. Update Equipment Slots & Tooltips ---
  // <-- UPDATED this array with all new slots -->
  const slots = [
    'necklace', 'helmet', 'cape', 
    'weapon', 'chest', 'shield', 
    'ring1', 'legs', 'ring2', 
    'arrows', 'boots'
  ];
  
  // <-- UPDATED this map with existing item images -->
  const itemImageMap = {
    'Copper Helmet': 'copperhelmet',
    'Copper Chestplate': 'copperchestplate',
    'Copper Shortsword': 'coppershortsword',
    'Copper Boots': 'copperboots',
    'Iron Helmet': 'ironhelmet',
    'Iron Chestplate': 'ironchestplate',
    'Iron Shortsword': 'ironshortsword',
    'Iron Boots': 'ironboots',
    'Copper Platelegs': 'copperplatelegs', // +++ NEW +++
    'Iron Platelegs': 'ironplatelegs', // +++ NEW +++

    // +++ NEW BOWS +++
    'Softwood Bow': 'softwoodbow',
    'Oak Bow': 'oakbow',
    
    // +++ NEW ARROWS (THIS IS A FIX) +++
    'Copper Arrow': 'copperarrow',
    // +++ NEW LEATHER +++
    'Leather Hood': 'leatherhood',
    'Leather Body': 'leatherarmor',
    'Leather Chaps': 'leatherpants',
    'Leather Boots': 'leatherboots'
  };

  slots.forEach(slotType => {
    const item = game.equipment[slotType];
    
    // Get the Main Sidebar Slot
    const mainSlotEl = document.getElementById(slotType);
    
    let imgName = '';
    if (item) {
      imgName = itemImageMap[item.name];
    } else {
      // Use placeholder images
      if (slotType === 'helmet') imgName = 'helmet';
      else if (slotType === 'chest') imgName = 'chestplate';
      else if (slotType === 'weapon') imgName = 'weapon';
      else if (slotType === 'boots') imgName = 'boots';
      // <-- NEW: Added placeholders for new slots -->
      else if (slotType === 'necklace') imgName = 'necklace';
      else if (slotType === 'cape') imgName = 'cape';
      else if (slotType === 'shield') imgName = 'shield';
      else if (slotType === 'legs') imgName = 'legs';
      else if (slotType === 'ring1') imgName = 'ring';
      else if (slotType === 'ring2') imgName = 'ring';
      else if (slotType === 'arrows') imgName = 'arrows';
    }
    
    const imgHtml = `<img src="images/${imgName}.png" alt="${slotType}">`;
    const itemStats = item ? ITEM_STATS[item.name] : null;

    // --- Generate Stat Tooltip HTML ---
    let statsHtml = '';
    if (itemStats) {
      if (itemStats.damage) statsHtml += `<div style="color:#aaffaa;">+${itemStats.damage} Physical Damage</div>`;
      if (itemStats.styleBonus) statsHtml += `<div style="color:#aaffaa;">+${itemStats.styleBonus} Physical Damage (if accurate)</div>`;
      if (itemStats.armor) statsHtml += `<div style="color:#aaffaa;">+${itemStats.armor} Armor</div>`;
      if (itemStats.speed) statsHtml += `<div style="color:#aaffaa;">+${itemStats.speed} Speed</div>`;
    }
    
    // --- NEW: Add quantity string for arrows ---
    let qtyHtml = '';
    if (item && slotType === 'arrows') {
        qtyHtml = `<div style="color:#fff;">Amount: ${item.qty.toLocaleString()}</div>`;
    }
    // --- END NEW ---

    // Update Main Sidebar Slot
    if (mainSlotEl) {
      mainSlotEl.innerHTML = imgHtml; // Set the image first
      
      // --- NEW: Add quantity display for arrows ---
      if (item && slotType === 'arrows' && item.qty > 0) {
          const amt = document.createElement('div');
          amt.className = 'inv-amount';
          amt.innerText = formatAmount(item.qty); 
          mainSlotEl.appendChild(amt);
      }
      // --- END NEW ---
      
      mainSlotEl.onclick = () => unequipItem(slotType);
      
      if (item) {
        mainSlotEl.onmouseenter = (evt) => {
          const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
            ${qtyHtml} 
            ${statsHtml}
            <div style="color:#ffaaaa; margin-top: 5px;">Click to unequip...</div>
          `;
          showTooltip(evt, tooltipContent);
        };
        mainSlotEl.onmouseleave = hideTooltip;
      } else {
        mainSlotEl.onmouseenter = null;
        mainSlotEl.onmouseleave = null;
      }
    }
  });
}

function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount);
  updateGoldUI();
}

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;

  for(let i = 0; i < capacity; i++){
    const slotData = game.inventory[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    if(slotData){
      slot.draggable = true;
      const item = slotData;
      const img = document.createElement('img');
              let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
              if (item.name === 'Copper Bar') imgName = 'copperbar';
              else if (item.name === 'Copper Chestplate') imgName = 'copperchestplate';
              else if (item.name === 'Copper Shortsword') imgName = 'coppershortsword';
              else if (item.name === 'Copper Helmet') imgName = 'copperhelmet';
              else if (item.name === 'Copper Boots') imgName = 'copperboots';
              else if (item.name === 'Raw Chicken') imgName = 'rawchicken';
              else if (item.name === 'Cooked Chicken') imgName = 'cookedchicken';
              else if (item.name === 'Burnt Chicken') imgName = 'burntchicken';
              
              // +++ NEW COOKED FISH IMAGES +++
              else if (item.name === 'Cooked Herring') imgName = 'cookedherring';
              else if (item.name === 'Burnt Herring') imgName = 'burntherring';
              else if (item.name === 'Cooked Trout') imgName = 'cookedtrout';
              else if (item.name === 'Burnt Trout') imgName = 'burnttrout';
              else if (item.name === 'Cooked Salmon') imgName = 'cookedsalmon';
              else if (item.name === 'Burnt Salmon') imgName = 'burntsalmon';
              // +++ END NEW +++

              else if (item.name === 'Coal Ore') imgName = 'coalore';
              else if (item.name === 'Iron Ore') imgName = 'ironore';
              else if (item.name === 'Iron Bar') imgName = 'ironbar';
              else if (item.name === 'Iron Helmet') imgName = 'ironhelmet';
              else if (item.name === 'Iron Chestplate') imgName = 'ironchestplate';
              else if (item.name === 'Iron Boots') imgName = 'ironboots';
              else if (item.name === 'Iron Shortsword') imgName = 'ironshortsword';
              else if (item.name === 'Copper Platelegs') imgName = 'copperplatelegs'; // +++ NEW +++
              else if (item.name === 'Iron Platelegs') imgName = 'ironplatelegs'; // +++ NEW +++
              else if (item.name === 'Softwood') imgName = 'softwood';
              else if (item.name === 'Oak') imgName = 'oak';
              else if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe'; // +++ NEW +++
              else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe'; // +++ NEW +++
              else if (item.name === 'Copper Pickaxe') imgName = 'copperpickaxe'; // +++ NEW +++
              else if (item.name === 'Copper Axe') imgName = 'copperaxe'; // +++ NEW +++
              else if (item.name === 'Iron Pickaxe') imgName = 'ironpickaxe'; // +++ NEW +++
              else if (item.name === 'Iron Axe') imgName = 'ironaxe'; // +++ NEW +++
              else if (item.name === 'Feather') imgName = 'feather'; // +++ NEW +++
              else if (item.name === 'Arrow Shaft') imgName = 'arrowshaft'; // +++ NEW +++
              else if (item.name === 'Copper Arrow Tip') imgName = 'copperarrowtip'; // +++ NEW +++
              else if (item.name === 'Unbound Arrow') imgName = 'unboundarrow'; // +++ NEW +++
              else if (item.name === 'Copper Arrow') imgName = 'copperarrow'; // +++ NEW +++
              else if (item.name === 'Silk') imgName = 'silk'; // +++ NEW +++
              // --- THIS IS THE FIX ---
              else if (item.name === 'Bow String') {
                  imgName = 'bowstring';
              } else if (item.name === 'Unstrung Softwood Bow') {
                  imgName = 'unstrungsoftwoodbow';
              } else if (item.name === 'Unstrung Oak Bow') {
                  imgName = 'unstrungoakbow';
              } else if (item.name === 'Softwood Bow') {
                  imgName = 'softwoodbow';
              } else if (item.name === 'Oak Bow') {
                  imgName = 'oakbow';
              }

// +++ NEW LEATHER +++
              else if (item.name === 'Cow Hide') {
                  imgName = 'cowhide';
              } else if (item.name === 'Leather') {
                  imgName = 'leather';
              } else if (item.name === 'Leather Hood') {
                  imgName = 'leatherhood';
              } else if (item.name === 'Leather Body') {
                  imgName = 'leatherarmor';
              } else if (item.name === 'Leather Chaps') {
                  imgName = 'leatherpants';
              } else if (item.name === 'Leather Boots') {
                  imgName = 'leatherboots';
              }

              // +++ NEW FISHING ITEMS +++
              else if (item.name === 'Herring') {
                  imgName = 'herring';
              } else if (item.name === 'Trout') {
                  imgName = 'trout';
              } else if (item.name === 'Salmon') {
                  imgName = 'salmon';
              } else if (item.name === 'Fishing Pole') {
                  imgName = 'fishingpole';
              } else if (item.name === 'Fishing Bait') {
                  imgName = 'fishingbait';
              }

              // --- END OF FIX ---
              img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      let clickAction = '';
      const stats = ITEM_STATS[itemName];

      if (stats) {
        // This is equipable
        if (stats.damage) itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to equip...</div>';
      
      } else if (itemName === 'Cooked Chicken') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_CHICKEN_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Herring') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_HERRING_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Trout') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_TROUT_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      } else if (itemName === 'Cooked Salmon') {
        // This is consumable
        itemStats = `<div style="color:#aaffaa; margin-top:4px;">+${COOK_SALMON_HEAL} HP</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
        ${itemStats}
        ${clickAction}
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      
      const itemQty = item.qty; 
      const slotIndex = i; 
      slot.onclick = (event) => {
        handleItemClick(event, itemName, itemQty, slotIndex);
      };
    } else {
      slot.draggable = false;
    }
    grid.appendChild(slot);
  }
}

// =================================================================
// --- 1. REPLACED 'addItem' FUNCTION (non-module script) ---
// This function now correctly handles multiple stacks.
// =================================================================
function addItem(name, qty = 1) {
  let amountToAdd = qty;

  // 1. Try to stack in existing slots first
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      slot.qty += amountToAdd;
      amountToAdd = 0;
      break; // Found a stack, stop looking
    }
  }

  // 2. If items are left (no existing stack found), find an empty slot
  if (amountToAdd > 0) {
    let emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex > -1) {
      game.inventory[emptySlotIndex] = { name: name, qty: amountToAdd };
      amountToAdd = 0;
    } else {
      console.warn(`Inventory full! Could not add ${amountToAdd} ${name}`);
      // Note: We don't return, so the inventory still renders
    }
  }

  if (!game.isDragging) {
    renderInventoryGrid();
  }
}

// =================================================================
// --- 2. REPLACED 'removeItem' FUNCTION (non-module script) ---
// This function now correctly removes from multiple stacks.
// =================================================================
function removeItem(name, qty = 1) {
  let amountToRemove = qty;
  let totalAvailable = 0;

  // 1. First, check if we even have enough across ALL stacks
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      totalAvailable += slot.qty;
    }
  }

  if (totalAvailable < amountToRemove) {
    console.warn(`Tried to remove ${qty} ${name}, but only have ${totalAvailable}`);
    return false; // Not enough items
  }

  // 2. If we have enough, remove them. Iterate backwards is safer.
  for (let i = game.inventory.length - 1; i >= 0; i--) {
    const slot = game.inventory[i];
    if (slot && slot.name === name) {
      if (slot.qty > amountToRemove) {
        // This stack has more than we need
        slot.qty -= amountToRemove;
        amountToRemove = 0;
      } else {
        // This stack will be emptied
        amountToRemove -= slot.qty;
        game.inventory[i] = null; // Empty the slot
      }
    }
    if (amountToRemove === 0) break; // We're done
  }
  return true; // Successfully removed
}

/**
 * Checks if the inventory has space for a given item.
 * Returns true if there is an empty slot OR an existing stack of that item.
 * @param {string} itemName - The name of the item to check for.
 * @returns {boolean}
 */
function canReceiveItem(itemName) {
  let hasEmptySlot = false;
  let hasStack = false;

  for (const slot of game.inventory) {
    if (slot === null) {
      hasEmptySlot = true;
      break; // Found an empty slot, we can stop
    }
    if (slot.name === itemName) {
      hasStack = true;
      break; // Found an existing stack, we can stop
    }
  }
  return hasEmptySlot || hasStack;
}
// =================================================================
// --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
// =================================================================

async function handleSellItemClick(itemName, currentQty) {
  if (!game.shopOpen) return;
  
  // --- MODIFIED: Look up sell price in the new map ---
  const sellPrice = ITEM_SELL_PRICES[itemName] || 0;

  if (sellPrice <= 0) {
    await showGameAlert("Cannot Sell", "This shop doesn't buy that item."); // Replaced alert
    return;
  }
  // --- END MODIFICATION ---
  
  let totalQty = 0;
  for (const slot of game.inventory) {
      if(slot && slot.name === itemName) {
          totalQty += slot.qty;
      }
  }

  let qtyToSell = 0;
  if (totalQty === 1) {
    qtyToSell = 1;
  } else {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Sell ${itemName}`, 
      `How many ${itemName} do you want to sell? (You have: ${totalQty}) (Price: ${sellPrice}ea)`, 
      totalQty
    );
    if (input === null) return;
    qtyToSell = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToSell) || qtyToSell <= 0) return;
  if (qtyToSell > totalQty) {
    await showGameAlert("Invalid Amount", "You don't have that many to sell."); // Replaced alert
    return;
  }
  
  const totalGold = qtyToSell * sellPrice;
  
  const confirmed = await showGameConfirm( // <-- USE 'await showGameConfirm'
    "Confirm Sale", 
    `Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`
  );
  
  if (confirmed) {
    if (removeItem(itemName, qtyToSell)) {
        addGold(totalGold);
        hideTooltip(); 
        renderInventoryGrid();
        if (game.inTrade) {
          renderTradeInventory();
        }
        await showGameAlert("Sale Complete", `You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`); // Replaced alert
    } else {
        await showGameAlert("Error", "Something went wrong, the sale did not complete."); // Replaced alert
    }
  }
}

function handleItemClick(event, itemName, itemQty, slotIndex) {
  // Always close any open menu first
  hideItemContextMenu();

  // --- NEW: Define equipable items and their slots ---
  const equipableItems = {
    'Copper Helmet': 'helmet',
    'Copper Chestplate': 'chest',
    'Copper Shortsword': 'weapon',
    'Copper Boots': 'boots',
    'Iron Helmet': 'helmet',
    'Iron Chestplate': 'chest',
    'Iron Shortsword': 'weapon',
    'Iron Boots': 'boots',
    'Copper Platelegs': 'legs', // +++ NEW +++
    'Iron Platelegs': 'legs', // +++ NEW +++
    
    // +++ NEW BOWS +++
    'Softwood Bow': 'weapon',
    'Oak Bow': 'weapon',
    
    // +++ NEW ARROWS (THIS IS THE FIX) +++
    'Copper Arrow': 'arrows',
    // +++ NEW LEATHER +++
    'Leather Hood': 'helmet',
    'Leather Body': 'chest',
    'Leather Chaps': 'legs',
    'Leather Boots': 'boots'
  };
  const itemSlotType = equipableItems[itemName];
  // --- END NEW ---

  if (game.shopOpen) {
    // If shop is open, we're selling
    handleSellItemClick(itemName, itemQty);
  } else if (itemSlotType) {
    // --- NEW: This is an equipable item! ---
    // We pass the slot *type* (e.g., 'helmet') and the inventory *index*
    equipItem(itemSlotType, slotIndex);
  } else if (itemName === 'Cooked Chicken' || itemName === 'Cooked Herring' || itemName === 'Cooked Trout' || itemName === 'Cooked Salmon') {
    // Not in shop, not equipable, and it's food. Show eat menu.
    showItemContextMenu(event, itemName);
  }
  // Other items (like ores) do nothing when clicked.
}

// NEW: Shows the right-click-style menu
function showItemContextMenu(event, itemName) {
  const menu = document.getElementById('itemContextMenu');
  let menuContent = '';

  if (itemName === 'Cooked Chicken') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedChicken()">Eat</button>`;
  } else if (itemName === 'Cooked Herring') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedHerring()">Eat</button>`;
  } else if (itemName === 'Cooked Trout') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedTrout()">Eat</button>`;
  } else if (itemName === 'Cooked Salmon') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedSalmon()">Eat</button>`;
  }
  
  // We can add other options here later (e.g., "Drop")
  
  if (menuContent) {
    menu.innerHTML = menuContent;
    menu.style.display = 'block';
    
    // Position menu near the cursor
    const rect = document.body.getBoundingClientRect();
    menu.style.left = (event.clientX - rect.left + 5) + 'px';
    menu.style.top = (event.clientY - rect.top + 5) + 'px';

    // Add a one-time listener to close the menu
    // Use setTimeout to skip this current click event
    setTimeout(() => {
      document.addEventListener('click', hideItemContextMenu, { once: true });
    }, 0);
  }
}

// NEW: Hides the item context menu
function hideItemContextMenu() {
  const menu = document.getElementById('itemContextMenu');
  if (menu) menu.style.display = 'none';
  // Remove the listener just in case (though {once: true} should handle it)
  document.removeEventListener('click', hideItemContextMenu);
}

// NEW: The logic for eating the chicken
async function eatCookedChicken() {
  hideItemContextMenu(); // Close the menu

  // Check if HP is full
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }

  // Try to remove the item. If successful, heal the player.
  if (removeItem('Cooked Chicken', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_CHICKEN_HEAL); // <-- Use constant
    updateHPUI();
    
    // --- NEW FIX: Re-render inventory and save ---
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
    // --- END FIX ---

  } else {
    console.warn('Tried to eat Cooked Chicken, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Herring +++
async function eatCookedHerring() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Herring', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_HERRING_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Herring, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Trout +++
async function eatCookedTrout() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Trout', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_TROUT_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Trout, but removeItem failed.');
  }
}

// +++ NEW: Logic for eating Salmon +++
async function eatCookedSalmon() {
  hideItemContextMenu(); 
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full.");
    return;
  }
  if (removeItem('Cooked Salmon', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + COOK_SALMON_HEAL);
    updateHPUI();
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
  } else {
    console.warn('Tried to eat Cooked Salmon, but removeItem failed.');
  }
}

/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
async function equipItem(slotType, fromInvIndex) {
  const itemStack = game.inventory[fromInvIndex];
  if (!itemStack) return; // Item doesn't exist

  const itemBeingWorn = game.equipment[slotType]; // This is {name, qty} or null

  // --- Stop combat INTERVALS to prevent errors ---
  const wasInCombat = game.inCombat;
  if (wasInCombat) {
    // --- THIS IS THE FIX ---
    // We clear intervals, but DON'T call runFromCombat() which resets HP
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    // if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval); // <-- DO NOT CLEAR ENEMY TIMER
    game.playerCombatInterval = null;
    // game.enemyCombatInterval = null; // <-- DO NOT CLEAR ENEMY TIMER
    
    // Disable the RUN button briefly to prevent spam
    const runBtn = document.getElementById('combat-run-btn');
    if (runBtn) runBtn.disabled = true;
    // --- END FIX ---
  }
  // --- END ---

  // --- NEW LOGIC FOR STACKABLE ARROWS ---
  if (slotType === 'arrows') {
    const itemName = itemStack.name;
    
    if (itemBeingWorn && itemBeingWorn.name === itemName) {
      // --- STACKING ---
      // We are wearing the same arrows, so just add to the stack.
      game.equipment[slotType].qty += itemStack.qty; // Add full stack
      game.inventory[fromInvIndex] = null; // Clear inventory slot
    } else {
      // --- SWAPPING ---
      // We are equipping to an empty slot or swapping with different arrows.
      game.equipment[slotType] = { name: itemStack.name, qty: itemStack.qty }; // Equip full stack
      game.inventory[fromInvIndex] = itemBeingWorn; // Put old item (or null) back
    }
  } 
  // --- REGULAR EQUIPMENT LOGIC ---
  else {
    // Check for inventory space *before* equipping
    if (itemBeingWorn) {
      const canStackOnSelf = (itemStack.name === itemBeingWorn.name);
      const hasStackingSlot = game.inventory.find(slot => slot && slot.name === itemBeingWorn.name && slot !== itemStack);
      const hasEmptySlot = game.inventory.some(slot => slot === null);
      if (itemStack.qty > 1 && !canStackOnSelf && !hasStackingSlot && !hasEmptySlot) {
        await showGameAlert("Inventory Full", "You have no room to unequip your currently worn item.");
        // Restart combat if we stopped it
        if (wasInCombat) setTimeout(restartPlayerAttackInterval, 50); // <-- Use new function
        return;
      }
    }

    // 1. Create the new single item to wear
    const newItemToEquip = { name: itemStack.name, qty: 1 };
    
    // 2. Put the new item on the character
    game.equipment[slotType] = newItemToEquip;
    
    // 3. Decrement the inventory stack
    itemStack.qty -= 1;

    // 4. Handle the leftovers
    if (itemStack.qty <= 0) {
      // The stack is empty. Put the old item (or null) in its place.
      game.inventory[fromInvIndex] = itemBeingWorn;
    } else if (itemBeingWorn) {
      // The stack is NOT empty. We must add the old item back.
      // Use the "smart" unequip logic: try to stack first, then find empty slot.
      let stacked = false;
      for (const slot of game.inventory) {
        if (slot && slot.name === itemBeingWorn.name) {
          slot.qty += 1;
          stacked = true;
          break;
        }
      }
      if (!stacked) {
        // We already checked for an empty slot, so this is safe.
        const emptySlot = game.inventory.findIndex(s => s === null);
        if (emptySlot !== -1) {
           game.inventory[emptySlot] = itemBeingWorn;
        }
      }
    }
  }
  
  // 5. Re-render everything
  renderEquipment(); // This will update stats
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 6. Restart combat if we were in it
  if (wasInCombat) {
    // --- THIS IS THE FIX ---
    // Call the new restart function which does NOT reset enemy HP
    setTimeout(restartPlayerAttackInterval, 50); 
    // --- END FIX ---
  }
}

/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
async function unequipItem(slotType) {
  const itemToUnequip = game.equipment[slotType];
  if (!itemToUnequip) return; // Slot is already empty

  // --- NEW: Smart unequip logic ---
  // 1. Try to find an existing stack to add to
  let stacked = false;
  for (const slot of game.inventory) {
    if (slot && slot.name === itemToUnequip.name) {
      // --- THIS IS THE FIX for stacking arrows ---
      slot.qty += itemToUnequip.qty; // Add the full stack (works for 1 and for many)
      // --- END FIX ---
      stacked = true;
      break;
    }
  }

  // 2. If not stacked, find an empty slot
  if (!stacked) {
    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex === -1) {
      // Inventory is full
      await showGameAlert("Inventory Full", "You can't unequip this, your inventory is full.");
      return;
    }
    // Put item in the empty slot
    game.inventory[emptySlotIndex] = itemToUnequip;
  }
  // --- END: Smart unequip logic ---


  // --- Stop combat INTERVALS to prevent errors ---
  const wasInCombat = game.inCombat;
  if (wasInCombat) {
    // --- THIS IS THE FIX ---
    // We clear intervals, but DON'T call runFromCombat() which resets HP
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    // if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval); // <-- DO NOT CLEAR ENEMY TIMER
    game.playerCombatInterval = null;
    // game.enemyCombatInterval = null; // <-- DO NOT CLEAR ENEMY TIMER
    
    // Disable the RUN button briefly to prevent spam
    const runBtn = document.getElementById('combat-run-btn');
    if (runBtn) runBtn.disabled = true;
    // --- END FIX ---
  }
  // --- END ---
  
  // 3. Clear the equipment slot (since item is safely in inventory)
  game.equipment[slotType] = null; 
  
  // 4. Re-render everything
  renderEquipment(); // This will update stats
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 5. Restart combat if we were in it
  if (wasInCombat) {
    // --- THIS IS THE FIX ---
    // Call the new restart function which does NOT reset enemy HP
    setTimeout(restartPlayerAttackInterval, 50); 
    // --- END FIX ---
  }
}

const tooltip = document.getElementById('tooltip');
function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}
function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}
function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){
    // level is the CURRENT level (1-100)
    
    // Safety check for levels beyond the table
    if (level >= XP_TABLE.length) {
        return 0; 
    }

    // XP_TABLE[level] holds the total XP for level + 1
    const xpNeededForNextLevel = XP_TABLE[level]; 
    
    // XP_TABLE[level - 1] holds the total XP for the current level
    const xpAlreadyGained = XP_TABLE[level - 1] || 0; 

    return xpNeededForNextLevel - xpAlreadyGained;
}

function getTotalXPForLevel(level) {
    // level is the level we want the *cumulative* XP for (1-100)

    // The XP_TABLE is 0-indexed: Lvl 1 total XP is at index 0.
    const index = Math.min(level - 1, XP_TABLE.length - 1);

    return XP_TABLE[index] || 0;
}

function updateSkillUI(){
  const skillsTab = document.getElementById('skillsTab');
  if (!skillsTab) return;
  
  // Clear the tab and set up the header/container
  skillsTab.innerHTML = `
    <div id="skillIconsContainer" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; justify-content: center; margin-top: 12px;">
      </div>
  `;

  const container = document.getElementById('skillIconsContainer');

  /**
   * Helper function to create a skill icon with a tooltip
   * @param {string} skillName - The display name (e.g., "Mining")
   * @param {string} skillDataKey - The key in the game object (e.g., "mining")
   * @param {string} iconFileName - The name of the icon file in /images/
   */
  const createSkillIcon = (skillName, skillDataKey, iconFileName) => {
    const data = game[skillDataKey];
    const iconWrapper = document.createElement('button');
    iconWrapper.className = ''; // <-- FIX: Removed 'primary' class
    iconWrapper.style.cssText = `
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 5px; 
      /* padding: 8px 10px; -- REMOVED */
      /* height: 80px; -- REMOVED */
      /* width: 80px; -- REMOVED */
      justify-content: center;
      font-size: 13px;
      background: transparent; /* <-- FIX: No background */
      border: none; /* <-- FIX: No border */
      cursor: pointer; /* <-- Keep this for hover/tooltip */
      transition: all 0.15s ease;
    `;
    
    // --- Create the tooltip content ---
    const nextXP = getNextXP(data.level);
    // Calculate progress percentage, ensuring it doesn't exceed 100%
    const progressPercent = Math.min(100, (data.xp / nextXP) * 100);
    
    const tooltipContent = `
      <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${skillName}</div>
      <div style="font-size: 14px; margin-bottom: 6px;">Level: <span style="font-weight: bold;">${data.level}</span></div>
      <div>XP: ${data.xp.toLocaleString()} / ${nextXP.toLocaleString()}</div>
      <div>(Total XP: ${data.totalXP.toLocaleString()})</div>
      
      <div style="width: 100%; height: 8px; background: #555; border-radius: 4px; margin-top: 8px; border: 1px solid #333;">
        <div style="height: 100%; width: ${progressPercent}%; background: #4caf50; border-radius: 4px; transition: width 0.2s;"></div>
      </div>
    `;

    // Set up hover/tooltip events
    iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
    iconWrapper.onmouseleave = hideTooltip;

    // Create and append icon image
    const img = document.createElement('img');
    img.src = `images/${iconFileName}`;
    img.alt = skillName;
    img.style.cssText = 'width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; pointer-events: none;';
    img.onerror = function(){ this.style.opacity='0.1'; this.style.filter='grayscale(100%)'; }; // Fallback
    iconWrapper.appendChild(img);

    // Append level text
    const levelText = document.createElement('span');
    levelText.innerText = data.level; // <-- FIX: Removed "Lvl "
    levelText.style.fontWeight = 'bold';
    levelText.style.pointerEvents = 'none';
    levelText.style.color = '#fff'; // <-- THIS IS THE FIX
    iconWrapper.appendChild(levelText);

    container.appendChild(iconWrapper);
  };

  // --- Call the function for each of your skills ---
  createSkillIcon('Mining', 'mining', 'miningskillicon.png');
  createSkillIcon('Blacksmith', 'blacksmith', 'blacksmithskillicon.png');
  createSkillIcon('Attack', 'attack', 'attackskillicon.jpeg'); 
  createSkillIcon('Strength', 'strength', 'strengthskillicon.png'); 
  createSkillIcon('Defence', 'defence', 'defenseskillicon.png'); 
  createSkillIcon('Vitality', 'vitality', 'vitalityskillicon.png'); // +++ NEW VITALITY SKILL CALL +++
  createSkillIcon('Cooking', 'cooking', 'cookingskillicon.png'); // +++ NEW COOKING SKILL CALL +++
  createSkillIcon('Woodcutting', 'woodcutting', 'woodcuttingskillicon.jpeg'); // +++ NEW WOODCUTTING SKILL CALL +++
  createSkillIcon('Fletching', 'fletching', 'fletchingskillicon.jpeg'); // +++ NEW FLETCHING SKILL CALL +++
  
  // +++ NEW SKILL ICONS +++
  createSkillIcon('Crafting', 'crafting', 'craftingskillicon.png');
  createSkillIcon('Ranged', 'ranged', 'rangedskillicon.jpeg');
  
  // +++ NEW FISHING SKILL ICON +++
  createSkillIcon('Fishing', 'fishing', 'fishingskillicon.jpeg');
}

function showItemPopup(text, progressElementId, delay = 0) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.innerHTML = text; // Allow HTML
popup.style.lineHeight = '1.4';
    const bar = document.getElementById(progressElementId);
    if (bar) {
        const barRect = bar.getBoundingClientRect();
        const mainRect = main.getBoundingClientRect();
        const relativeX = barRect.left - mainRect.left;
        const relativeY = barRect.top - mainRect.top;
        popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
        popup.style.top = (relativeY - 30) + 'px';
    } else {
        popup.style.left = '50%';
        popup.style.top = '120px';
        popup.style.transform = 'translateX(-50%)';
    }
    if (delay > 0) {
    setTimeout(() => {
      main.appendChild(popup);
      setTimeout(() => popup.remove(), 850); // 850 to match splat
    }, delay);
  } else {
    main.appendChild(popup);
    setTimeout(() => popup.remove(), 850); // 850 to match splat
  }
}

// --- NEW WARNING POPUP FUNCTION ---
/**
 * Shows a short-lived warning popup in the main area.
 * @param {string} text - The warning message to display.
 */
function showWarningPopup(text) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'warning-popup';
    popup.innerHTML = text;
    
    // Position it in the top-center of the main panel
    popup.style.left = '50%';
    popup.style.top = '60px'; // A bit lower than XP popups
    popup.style.transform = 'translateX(-50%)';
    
    main.appendChild(popup);
    
    // Remove after animation (3s)
    setTimeout(() => popup.remove(), 2950);
}
// --- END NEW ---

function addXP(skill, amount, delay = 0){
  if (!game[skill]) {
      console.warn(`Skill "${skill}" does not exist.`);
      return;
  }
  game[skill].totalXP += amount; 
  game[skill].xp += amount;
  
  let leveledUp = false; // --- NEW: Add a flag ---
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
    leveledUp = true; // --- NEW: Set the flag ---
  }
  
  // --- NEW: Check if vitality leveled up and update HP ---
  if (leveledUp && skill === 'vitality') {
    updateHPUI();
  }
  // --- END NEW ---

  updateSkillUI();
  let barId = '';
  if (skill === 'mining') barId = 'mineProgress';
  if (skill === 'blacksmith') barId = 'smithProgress';
  if (skill === 'woodcutting') barId = 'woodcutProgress';
  if (skill === 'crafting') barId = 'craftProgress'; // +++ NEW +++
  
  // +++ ADDED 'crafting', 'fletching', 'fishing' TO THIS LIST +++
  if (skill !== 'blacksmith' && skill !== 'mining' && skill !== 'cooking' && skill !== 'woodcutting' && skill !== 'crafting' && skill !== 'fletching' && skill !== 'fishing') { // Don't show popup for skilling actions
    if (delay > 0) {
      setTimeout(() => {
        showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
      }, delay);
    } else {
      showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
    }
 }

 }

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

/**
* NEW: A reusable loop to show a cooldown timer in the mining UI.
 * @param {number} timestamp - The current frame's timestamp.
 * @param {number} startTime - The timestamp when the cooldown began.
 * @param {number} duration - The total duration of the cooldown (in ms).
 * @param {string} progressTextId - The ID of the text element (e.g., 'mineProgressText').
 * @param {function} nextLoopFunction - The mining loop to call when finished (e.g., miningLoop).
 */

function miningCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.miningActive) { // Check if stop was pressed
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = timestamp - startTime;
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    // Cooldown finished, clear text and start the next mining loop
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    game.progressFrame = requestAnimationFrame((now) => nextLoopFunction(now, now));
  } else {
    // Cooldown active, update timer
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    // Continue the cooldown loop
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, startTime, duration, progressTextId, nextLoopFunction)
    );
  }
}

// --- MODIFIED: Added Session Lock Check ---
async function startMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(MINE_ITEM, 1); // Uses new addItem
    addXP('mining', MINE_XP); // This now adds XP without a popup

    // NEW: Create two separate, delayed popups
    showItemPopup(`+${MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 Copper Ore`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_COPPER_MS, 'mineProgressText', miningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, startTime));
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const textEl = document.getElementById('mineProgressText'); // <-- ADD THIS
  if (textEl) textEl.innerText = '';                        // <-- ADD THIS

  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// +++ NEW CRAFTING FUNCTION BLOCK TO INSERT +++
const CHESTPLATE_TIME_MS = 10000; 

// +++ END NEW CRAFTING FUNCTION +++


// +++ END NEW SHORTSWORD CRAFTING FUNCTION +++

function openCopperHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${HELMET_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn'); 
  showMainScreen('hubDynamic');
}
// +++ END NEW HELMET CRAFTING FUNCTION +++

async function startHelmetCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Helmet')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < HELMET_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${HELMET_BAR_COST} Copper Bars to craft a helmet.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startHelmetBtn');
  const stopBtn = document.getElementById('stopHelmetBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => helmetCraftingLoop(now, now));
}

async function helmetCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / HELMET_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < HELMET_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
        return;
    }
    
    removeItem('Copper Bar', HELMET_BAR_COST);
    addItem('Copper Helmet', 1);
    addXP('blacksmith', HELMET_XP);
    
    showItemPopup(`+${HELMET_XP} Blacksmith XP`, 'helmetProgress', 0);
    showItemPopup(`+1 Copper Helmet`, 'helmetProgress', 450);
    
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < HELMET_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another helmet.");
        stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => helmetCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => helmetCraftingLoop(now, startTime));
  }
}

// +++ NEW COPPER BOOTS UI +++
function openCopperBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${BOOTS_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn'); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${BOOTS_BAR_COST} Copper Bars to craft boots.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, now));
}

async function bootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / BOOTS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Bar', BOOTS_BAR_COST);
    addItem('Copper Boots', 1);
    addXP('blacksmith', BOOTS_XP);
    
    showItemPopup(`+${BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Copper Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, startTime));
  }
}

// +++ NEW COPPER PLATELEGS UI +++
function openCopperPlatelegsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Platelegs</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_PLATELEGS_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="platelegsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPlatelegsBtn" class="primary">Start Crafting</button>
      <button id="stopPlatelegsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPlatelegsBtn').onclick = startCopperPlatelegsCrafting;
  document.getElementById('stopPlatelegsBtn').onclick = () => stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); 
  showMainScreen('hubDynamic');
}

async function startCopperPlatelegsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Platelegs')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < COPPER_PLATELEGS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${COPPER_PLATELEGS_BAR_COST} Copper Bars to craft platelegs.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startPlatelegsBtn');
  const stopBtn = document.getElementById('stopPlatelegsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => copperPlatelegsCraftingLoop(now, now));
}

async function copperPlatelegsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_PLATELEGS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < COPPER_PLATELEGS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); // <-- FIX: Pass correct IDs
        return;
    }
    
    removeItem('Copper Bar', COPPER_PLATELEGS_BAR_COST);
    addItem('Copper Platelegs', 1);
    addXP('blacksmith', COPPER_PLATELEGS_XP);
    
    showItemPopup(`+${COPPER_PLATELEGS_XP} Blacksmith XP`, 'platelegsProgress', 0);
    showItemPopup(`+1 Copper Platelegs`, 'platelegsProgress', 450);
    
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < COPPER_PLATELEGS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more platelegs.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); // <-- FIX: Pass correct IDs
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => copperPlatelegsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => copperPlatelegsCraftingLoop(now, startTime));
  }
}
// +++ END NEW COPPER PLATELEGS +++

// --- NEW: Iron Bar Crafting Logic ---
async function startIronBarCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Bar')) {
    await showGameAlert("Inventory Full", "You have no room to smith this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalIronOre = 0;
  let totalCoalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
      if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
  }

  if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BAR_ORE_COST} Iron Ore and ${IRON_BAR_COAL_COST} Coal Ore.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, now));
}


async function ironBarCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_BAR_TIME_MS) * 100;

  if (progress >= 100) {
    let totalIronOre = 0;
    let totalCoalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
    }
    if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
        await showGameAlert("Out of Materials", "You've run out of ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Ore', IRON_BAR_ORE_COST);
    removeItem('Coal Ore', IRON_BAR_COAL_COST);
    addItem('Iron Bar', 1);
    addXP('blacksmith', IRON_BAR_XP);
    
    showItemPopup(`+${IRON_BAR_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Iron Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    let totalIronAfter = 0;
    let totalCoalAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronAfter += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalAfter += slot.qty;
    }
    if (totalIronAfter < IRON_BAR_ORE_COST || totalCoalAfter < IRON_BAR_COAL_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Helmet Crafting Logic ---
async function startIronHelmetCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Helmet')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_HELMET_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_HELMET_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startHelmetBtn');
  const stopBtn = document.getElementById('stopHelmetBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, now));
}


async function ironHelmetCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_HELMET_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_HELMET_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_HELMET_BAR_COST);
    addItem('Iron Helmet', 1);
    addXP('blacksmith', IRON_HELMET_XP);
    
    showItemPopup(`+${IRON_HELMET_XP} Blacksmith XP`, 'helmetProgress', 0);
    showItemPopup(`+1 Iron Helmet`, 'helmetProgress', 450);
    
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_HELMET_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another helmet.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Chestplate Crafting Logic ---
async function startIronChestplateCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Chestplate')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_CHESTPLATE_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_CHESTPLATE_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, now));
}

async function ironChestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_CHESTPLATE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_CHESTPLATE_BAR_COST);
    addItem('Iron Chestplate', 1);
    addXP('blacksmith', IRON_CHESTPLATE_XP);
    
    showItemPopup(`+${IRON_CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Iron Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another chestplate.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Boots Crafting Logic ---
async function startIronBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BOOTS_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, now));
}


async function ironBootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_BOOTS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_BOOTS_BAR_COST);
    addItem('Iron Boots', 1);
    addXP('blacksmith', IRON_BOOTS_XP);
    
    showItemPopup(`+${IRON_BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Iron Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, startTime));
  }
}

// +++ NEW IRON PLATELEGS UI +++
function openIronPlatelegsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Iron Platelegs</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_PLATELEGS_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="platelegsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPlatelegsBtn" class="primary">Start Crafting</button>
      <button id="stopPlatelegsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPlatelegsBtn').onclick = startIronPlatelegsCrafting;
  document.getElementById('stopPlatelegsBtn').onclick = () => stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); 
  showMainScreen('hubDynamic');
}

async function startIronPlatelegsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Platelegs')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < IRON_PLATELEGS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_PLATELEGS_BAR_COST} Iron Bars to craft platelegs.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startPlatelegsBtn');
  const stopBtn = document.getElementById('stopPlatelegsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironPlatelegsCraftingLoop(now, now));
}

async function ironPlatelegsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_PLATELEGS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < IRON_PLATELEGS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); // <-- FIX: Pass correct IDs
        return;
    }
    
    removeItem('Iron Bar', IRON_PLATELEGS_BAR_COST);
    addItem('Iron Platelegs', 1);
    addXP('blacksmith', IRON_PLATELEGS_XP);
    
    showItemPopup(`+${IRON_PLATELEGS_XP} Blacksmith XP`, 'platelegsProgress', 0);
    showItemPopup(`+1 Iron Platelegs`, 'platelegsProgress', 450);
    
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < IRON_PLATELEGS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more platelegs.");
        stopBlacksmithing('platelegsProgress', 'startPlatelegsBtn', 'stopPlatelegsBtn'); // <-- FIX: Pass correct IDs
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironPlatelegsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('platelegsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironPlatelegsCraftingLoop(now, startTime));
  }
}
// +++ END NEW IRON PLATELEGS +++

// --- NEW: Iron Shortsword Crafting Logic ---
async function startIronShortswordCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Shortsword')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_SHORTSWORD_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_SHORTSWORD_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, now));
}


async function ironShortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_SHORTSWORD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_SHORTSWORD_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_SHORTSWORD_BAR_COST);
    addItem('Iron Shortsword', 1);
    addXP('blacksmith', IRON_SHORTSWORD_XP);
    
    showItemPopup(`+${IRON_SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Iron Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
   // Check for materials for the *next* loop
let totalBarsAfter = 0;
for (const slot of game.inventory) {
    if (slot && slot.name === 'Iron Bar') {
        totalBarsAfter += slot.qty;
    }
}
if (totalBarsAfter < IRON_SHORTSWORD_BAR_COST) {
    await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another shortsword.");
    stopBlacksmithing();
    return;
}
// Continue looping
game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, now));

  } else {
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, startTime));
  }
}

const SMITH_TIME_MS = 5000;
const SMITH_XP = 25;
const SMITH_ORE_COST = 2;
const SMITH_BAR_ITEM = 'Copper Bar';

// --- MODIFIED: Added Session Lock Check ---
async function startBlacksmithing() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(SMITH_BAR_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to smith this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Ore') {
          totalOre += slot.qty;
      }
  }

  if (totalOre < SMITH_ORE_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${SMITH_ORE_COST} Copper Ore to smith a bar.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
}

async function blacksmithingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SMITH_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check total ore again ---
    let totalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOre += slot.qty;
        }
    }
    if (totalOre < SMITH_ORE_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Ore', SMITH_ORE_COST); // Uses new removeItem
    addItem(SMITH_BAR_ITEM, 1); // Uses new addItem
    addXP('blacksmith', SMITH_XP); // This now adds XP without a popup
    
    // NEW: Create two separate, delayed popups
    showItemPopup(`+${SMITH_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Copper Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalOreAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOreAfter += slot.qty;
        }
    }
    if (totalOreAfter < SMITH_ORE_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, startTime));
  }
}

function stopBlacksmithing(progressId = 'smithProgress', startBtnId = 'startSmithBtn', stopBtnId = 'stopSmithBtn'){
  game.blacksmithingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

const COOK_CHICKEN_TIME_MS = 3000;
const COOK_CHICKEN_XP = 30;
const COOK_CHICKEN_HEAL = 3; // <-- ADD THIS

// --- NEW: Herring Cooking Constants ---
const COOK_HERRING_LVL = 1;
const COOK_HERRING_TIME_MS = 3000; // Same as chicken
const COOK_HERRING_XP = 30;        // Same as chicken
const COOK_HERRING_HEAL = 3;
const COOK_HERRING_ITEM_RAW = 'Herring';
const COOK_HERRING_ITEM_COOKED = 'Cooked Herring';
const COOK_HERRING_ITEM_BURNT = 'Burnt Herring';

// --- NEW: Trout Cooking Constants ---
const COOK_TROUT_LVL = 5;
const COOK_TROUT_TIME_MS = 3500; // Slightly longer
const COOK_TROUT_XP = 40;        // 4 HP heal
const COOK_TROUT_HEAL = 4;
const COOK_TROUT_ITEM_RAW = 'Trout';
const COOK_TROUT_ITEM_COOKED = 'Cooked Trout';
const COOK_TROUT_ITEM_BURNT = 'Burnt Trout';

// --- NEW: Salmon Cooking Constants ---
const COOK_SALMON_LVL = 10;
const COOK_SALMON_TIME_MS = 3500; // Same as trout
const COOK_SALMON_XP = 45;        // 4 HP heal
const COOK_SALMON_HEAL = 4;
const COOK_SALMON_ITEM_RAW = 'Salmon';
const COOK_SALMON_ITEM_COOKED = 'Cooked Salmon';
const COOK_SALMON_ITEM_BURNT = 'Burnt Salmon';


// --- NEW COOKING FUNCTIONS ---
async function startCookingChicken() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem('Cooked Chicken') && !canReceiveItem('Burnt Chicken')) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // --- Check for Raw Chicken ---
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Raw Chicken') {
          totalRaw += slot.qty;
      }
  }

  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 Raw Chicken to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
}

async function cookingChickenLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_CHICKEN_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check materials again ---
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", "You've run out of Raw Chicken.");
        stopCookingChicken();
        return;
    }
    
    removeItem('Raw Chicken', 1); // Consume 1 raw chicken
    addXP('cooking', COOK_CHICKEN_XP); // Always award XP (no popup thanks to Step 1)
    
    // Calculate success rate (50% at Lvl 1, 100% at Lvl 10)
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    // NEW: Create two separate, delayed popups
    if (Math.random() * 100 < successRate) {
      // Success
      addItem('Cooked Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Cooked Chicken`, 'cookProgress', 450);
    } else {
      // Burnt
      addItem('Burnt Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Burnt Chicken`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", "You don't have any more Raw Chicken to cook.");
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, startTime));
  }
}

function stopCookingChicken(){
  game.cookingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('cookProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCookBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCookBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function openCookChicken(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing(); // Also stop smithing
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Cooking - Chicken</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 Raw Chicken.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingChicken;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// +++ NEW: HERRING COOKING UI +++
function openCookHerring(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Herring</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_HERRING_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingHerring;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: TROUT COOKING UI +++
function openCookTrout(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Trout</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_TROUT_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingTrout;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: SALMON COOKING UI +++
function openCookSalmon(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Cooking - Salmon</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 ${COOK_SALMON_ITEM_RAW}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingSalmon;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken; // Re-uses the same stop function
  showMainScreen('hubDynamic');
}

// +++ NEW: HERRING COOKING LOGIC +++
async function startCookingHerring() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_HERRING_ITEM_COOKED) && !canReceiveItem(COOK_HERRING_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_HERRING_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_HERRING_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_HERRING_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingHerringLoop(now, now));
}

async function cookingHerringLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_HERRING_TIME_MS) * 100;

  if (progress >= 100) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_HERRING_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_HERRING_ITEM_RAW, 1);
    addXP('cooking', COOK_HERRING_XP);
    
    // Burn chance: 50% at Lvl 1, 0% at Lvl 10
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    if (Math.random() * 100 < successRate) {
      addItem(COOK_HERRING_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_HERRING_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_HERRING_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_HERRING_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_HERRING_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_HERRING_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_HERRING_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_HERRING_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingHerringLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingHerringLoop(now, startTime));
  }
}

// +++ NEW: TROUT COOKING LOGIC +++
async function startCookingTrout() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_TROUT_ITEM_COOKED) && !canReceiveItem(COOK_TROUT_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_TROUT_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_TROUT_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_TROUT_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingTroutLoop(now, now));
}

async function cookingTroutLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_TROUT_TIME_MS) * 100;

  if (progress >= 100) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_TROUT_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_TROUT_ITEM_RAW, 1);
    addXP('cooking', COOK_TROUT_XP);
    
    // Burn chance: 50% at Lvl 5, 0% at Lvl 15
    const successRate = Math.min(100, 50 + ((game.cooking.level - 5) * (50/9)));
    
    if (Math.random() * 100 < successRate || game.cooking.level < COOK_TROUT_LVL) {
      addItem(COOK_TROUT_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_TROUT_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_TROUT_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_TROUT_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_TROUT_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_TROUT_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_TROUT_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_TROUT_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingTroutLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingTroutLoop(now, startTime));
  }
}

// +++ NEW: SALMON COOKING LOGIC +++
async function startCookingSalmon() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK (checks for both outcomes) +++
  if (!canReceiveItem(COOK_SALMON_ITEM_COOKED) && !canReceiveItem(COOK_SALMON_ITEM_BURNT)) {
    await showGameAlert("Inventory Full", "You have no room to cook this. Make space for the cooked or burnt item.");
    return;
  }
  // +++ END NEW +++
  
  if (game.cookingActive) return;

  // Check level
  if (game.cooking.level < COOK_SALMON_LVL) {
    await showGameAlert("Level Required", `You need a Cooking level of ${COOK_SALMON_LVL} to cook this.`);
    return;
  }
  
  // Check for Raw Item
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
          totalRaw += slot.qty;
      }
  }
  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 ${COOK_SALMON_ITEM_RAW} to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingSalmonLoop(now, now));
}

async function cookingSalmonLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_SALMON_TIME_MS) * 100;

  if (progress >= 100) {
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", `You've run out of ${COOK_SALMON_ITEM_RAW}.`);
        stopCookingChicken();
        return;
    }
    
    removeItem(COOK_SALMON_ITEM_RAW, 1);
    addXP('cooking', COOK_SALMON_XP);
    
    // Burn chance: 50% at Lvl 10, 0% at Lvl 20
    const successRate = Math.min(100, 50 + ((game.cooking.level - 10) * (50/9)));
    
    if (Math.random() * 100 < successRate || game.cooking.level < COOK_SALMON_LVL) {
      addItem(COOK_SALMON_ITEM_COOKED, 1);
      showItemPopup(`+${COOK_SALMON_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_SALMON_ITEM_COOKED}`, 'cookProgress', 450);
    } else {
      addItem(COOK_SALMON_ITEM_BURNT, 1);
      showItemPopup(`+${COOK_SALMON_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 ${COOK_SALMON_ITEM_BURNT}`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === COOK_SALMON_ITEM_RAW) {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", `You don't have any more ${COOK_SALMON_ITEM_RAW} to cook.`);
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingSalmonLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingSalmonLoop(now, startTime));
  }
}


function openKitchenHub() {
  showMainScreen('hubKitchen');
}

function openCopperBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 2 Copper Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startBlacksmithing;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// +++ NEW COPPER CHESTPLATE UI +++
function openCopperChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${CHESTPLATE_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER CHESTPLATE UI +++

async function startChestplateCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Chestplate')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < CHESTPLATE_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${CHESTPLATE_BAR_COST} Copper Bars to craft a chestplate.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, now));
}

async function chestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / CHESTPLATE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < CHESTPLATE_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
        return;
    }
    
    removeItem('Copper Bar', CHESTPLATE_BAR_COST);
    addItem('Copper Chestplate', 1);
    addXP('blacksmith', CHESTPLATE_XP);
    
    showItemPopup(`+${CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Copper Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < CHESTPLATE_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another chestplate.");
        stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => chestplateCraftingLoop(now, startTime));
  }
}

// +++ NEW COPPER SHORTSWORD UI +++
function openCopperShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SHORTSWORD_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER SHORTSWORD UI +++

async function startShortswordCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Shortsword')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < SHORTSWORD_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${SHORTSWORD_BAR_COST} Copper Bars to craft a shortsword.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, now));
}

async function shortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SHORTSWORD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < SHORTSWORD_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
        return;
    }
    
    removeItem('Copper Bar', SHORTSWORD_BAR_COST);
    addItem('Copper Shortsword', 1);
    addXP('blacksmith', SHORTSWORD_XP);
    
    showItemPopup(`+${SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Copper Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < SHORTSWORD_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another shortsword.");
        stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => shortswordCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Bar UI ---
function openIronBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startIronBarCrafting;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Helmet UI ---
function openIronHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_HELMET_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startIronHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Chestplate UI ---
function openIronChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startIronChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Boots UI ---
function openIronBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BOOTS_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startIronBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Shortsword UI ---
function openIronShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startIronShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
  }

// +++ NEW: COPPER AXE UI +++
function openCopperAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startCopperAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// This is the logic function, now separate
async function startCopperAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Axe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_AXE_BAR_COST} Copper Bars and ${COPPER_AXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, now));
}

async function copperAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_AXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_AXE_BAR_COST);
    removeItem('Softwood', COPPER_AXE_WOOD_COST);
    addItem('Copper Axe', 1);
    addXP('blacksmith', COPPER_AXE_XP);
    
    showItemPopup(`+${COPPER_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Copper Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_AXE_BAR_COST || totalWoodAfter < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, now));
  } else {
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: COPPER PICKAXE UI +++
function openCopperPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startCopperPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startCopperPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Pickaxe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_PICKAXE_BAR_COST} Copper Bars and ${COPPER_PICKAXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, now));
}

async function copperPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_PICKAXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_PICKAXE_BAR_COST);
    removeItem('Softwood', COPPER_PICKAXE_WOOD_COST);
    addItem('Copper Pickaxe', 1);
    addXP('blacksmith', COPPER_PICKAXE_XP);
    
    showItemPopup(`+${COPPER_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Copper Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_PICKAXE_BAR_COST || totalWoodAfter < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, now));
  } else {
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: IRON AXE UI +++
function openIronAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startIronAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Axe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_AXE_BAR_COST} Iron Bars and ${IRON_AXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, now));
}

async function ironAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_AXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_AXE_BAR_COST);
    removeItem('Oak', IRON_AXE_WOOD_COST);
    addItem('Iron Axe', 1);
    addXP('blacksmith', IRON_AXE_XP);
    
    showItemPopup(`+${IRON_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Iron Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_AXE_BAR_COST || totalWoodAfter < IRON_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, now));
  } else {
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: IRON PICKAXE UI +++
function openIronPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startIronPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Iron Pickaxe')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_PICKAXE_BAR_COST} Iron Bars and ${IRON_PICKAXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, now));
}

async function ironPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_PICKAXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_PICKAXE_BAR_COST);
    removeItem('Oak', IRON_PICKAXE_WOOD_COST);
    addItem('Iron Pickaxe', 1);
    addXP('blacksmith', IRON_PICKAXE_XP);
    
    showItemPopup(`+${IRON_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Iron Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_PICKAXE_BAR_COST || totalWoodAfter < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, now));
  } else {
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, startTime));
  }
}

// +++ END NEW COPPER SHORTSWORD UI +++

function openBlacksmithHub() {
  showMainScreen('hubBlacksmith');
}

// +++ NEW: COPPER ARROW TIP UI (Blacksmith) +++
function openSmithCopperArrowTip(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Arrow Tip</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_ARROW_TIP_BAR_COST} Copper Bars. Yields ${COPPER_ARROW_TIP_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="arrowTipProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startArrowTipBtn" class="primary">Start Crafting</button>
      <button id="stopArrowTipBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startArrowTipBtn').onclick = startSmithingCopperArrowTip;
  document.getElementById('stopArrowTipBtn').onclick = () => stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
  showMainScreen('hubDynamic');
}

async function startSmithingCopperArrowTip() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Arrow Tip')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < COPPER_ARROW_TIP_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${COPPER_ARROW_TIP_BAR_COST} Copper Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startArrowTipBtn');
  const stopBtn = document.getElementById('stopArrowTipBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => smithingCopperArrowTipLoop(now, now));
}

async function smithingCopperArrowTipLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_ARROW_TIP_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < COPPER_ARROW_TIP_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_ARROW_TIP_BAR_COST);
    addItem('Copper Arrow Tip', COPPER_ARROW_TIP_YIELD);
    addXP('blacksmith', COPPER_ARROW_TIP_XP);
    
    showItemPopup(`+${COPPER_ARROW_TIP_XP} Blacksmith XP`, 'arrowTipProgress', 0);
    showItemPopup(`+${COPPER_ARROW_TIP_YIELD} Copper Arrow Tip`, 'arrowTipProgress', 450);
    
    const bar = document.getElementById('arrowTipProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < COPPER_ARROW_TIP_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more.");
        stopBlacksmithing('arrowTipProgress', 'startArrowTipBtn', 'stopArrowTipBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => smithingCopperArrowTipLoop(now, now));
  } else {
    const bar = document.getElementById('arrowTipProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => smithingCopperArrowTipLoop(now, startTime));
  }
}
// +++ END: COPPER ARROW TIP UI (Blacksmith) +++


// +++ NEW: FLETCHING HUB FUNCTIONS +++
function openFletchingHub() {
  showMainScreen('hubFletching');
  // Render the items for the hub
  renderFletchingItems();
}

function stopFletching(progressId = 'fletchProgress', startBtnId = 'startFletchBtn', stopBtnId = 'stopFletchBtn'){
  game.fletchingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function renderFletchingItems() {
  const container = document.getElementById('fletchingItemsContainer');
  if (!container) return;
  
  const fletchLvl = game.fletching.level;
  
  const setupFletchButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => {
    const btn = document.getElementById(btnId);
    if (btn) {
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      if (locked) {
        btn.onclick = null;
        const lockedTT = nameHtml + `Requires Fletching Lvl: ${levelReq}`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  // --- Fletching Level Locks ---
  const shaftLocked = fletchLvl < FLETCHING_SHAFT_LVL;
  const unboundLocked = fletchLvl < FLETCHING_UNBOUND_LVL;
  const copperArrowLocked = fletchLvl < FLETCHING_COPPER_ARROW_LVL;
  const unstrungSoftwoodLocked = fletchLvl < FLETCHING_UNSTRUNG_SOFTWOOD_LVL; // +++ NEW +++
  const softwoodBowLocked = fletchLvl < FLETCHING_SOFTWOOD_BOW_LVL;         // +++ NEW +++
  const unstrungOakLocked = fletchLvl < FLETCHING_UNSTRUNG_OAK_LVL;         // +++ NEW +++
  const oakBowLocked = fletchLvl < FLETCHING_OAK_BOW_LVL;                 // +++ NEW +++
  
  container.innerHTML = `
    <button id="fletchShaftBtn" class="primary ${shaftLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/arrowshaft.png" alt="Arrow Shaft" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchUnboundBtn" class="primary ${unboundLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unboundarrow.png" alt="Unbound Arrow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchCopperArrowBtn" class="primary ${copperArrowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/copperarrow.png" alt="Copper Arrow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    
    <button id="fletchUnstrungSoftwoodBtn" class="primary ${unstrungSoftwoodLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unstrungsoftwoodbow.png" alt="Unstrung Softwood Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchSoftwoodBowBtn" class="primary ${softwoodBowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/softwoodbow.png" alt="Softwood Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchUnstrungOakBtn" class="primary ${unstrungOakLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/unstrungoakbow.png" alt="Unstrung Oak Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="fletchOakBowBtn" class="primary ${oakBowLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/oakbow.png" alt="Oak Bow" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
  `;
  
  // --- Re-attach listeners for fletching items ---
  setupFletchButton('fletchShaftBtn', shaftLocked, openFletchArrowShaft, FLETCHING_SHAFT_LVL, `Requires: ${ARROW_SHAFT_WOOD_COST} Softwood`, `Arrow Shaft x${ARROW_SHAFT_YIELD}`);
  setupFletchButton('fletchUnboundBtn', unboundLocked, openFletchUnboundArrow, FLETCHING_UNBOUND_LVL, `Requires: ${UNBOUND_ARROW_SHAFT_COST} Arrow Shafts, <br>${UNBOUND_ARROW_FEATHER_COST} Feathers`, `Unbound Arrow x${UNBOUND_ARROW_YIELD}`);
  setupFletchButton('fletchCopperArrowBtn', copperArrowLocked, openFletchCopperArrow, FLETCHING_COPPER_ARROW_LVL, `Requires: ${COPPER_ARROW_UNBOUND_COST} Unbound Arrows, <br>${COPPER_ARROW_TIP_COST} Copper Arrow Tips`, `Copper Arrow x${COPPER_ARROW_YIELD}`);

  // +++ NEW: Bow Listeners +++
  setupFletchButton('fletchUnstrungSoftwoodBtn', unstrungSoftwoodLocked, openFletchUnstrungSoftwoodBow, FLETCHING_UNSTRUNG_SOFTWOOD_LVL, `Requires: ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood`, `Unstrung Softwood Bow x${UNSTRUNG_SOFTWOOD_YIELD}`);
  setupFletchButton('fletchSoftwoodBowBtn', softwoodBowLocked, openFletchSoftwoodBow, FLETCHING_SOFTWOOD_BOW_LVL, `Requires: ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow, <br>${SOFTWOOD_BOW_STRING_COST} Bow String`, `Softwood Bow x${SOFTWOOD_BOW_YIELD}`);
  setupFletchButton('fletchUnstrungOakBtn', unstrungOakLocked, openFletchUnstrungOakBow, FLETCHING_UNSTRUNG_OAK_LVL, `Requires: ${UNSTRUNG_OAK_WOOD_COST} Oak`, `Unstrung Oak Bow x${UNSTRUNG_OAK_YIELD}`);
  setupFletchButton('fletchOakBowBtn', oakBowLocked, openFletchOakBow, FLETCHING_OAK_BOW_LVL, `Requires: ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow, <br>${OAK_BOW_STRING_COST} Bow String`, `Oak Bow x${OAK_BOW_YIELD}`);
}

// --- Arrow Shaft UI & Logic ---
function openFletchArrowShaft(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Arrow Shaft</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${ARROW_SHAFT_WOOD_COST} Softwood. Yields ${ARROW_SHAFT_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingArrowShaft;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingArrowShaft() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Arrow Shaft')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalWood < ARROW_SHAFT_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${ARROW_SHAFT_WOOD_COST} Softwood.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingArrowShaftLoop(now, now));
}

async function fletchingArrowShaftLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / ARROW_SHAFT_TIME_MS) * 100;

  if (progress >= 100) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalWood < ARROW_SHAFT_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Softwood.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Softwood', ARROW_SHAFT_WOOD_COST);
    addItem('Arrow Shaft', ARROW_SHAFT_YIELD);
    addXP('fletching', ARROW_SHAFT_XP);
    
    showItemPopup(`+${ARROW_SHAFT_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${ARROW_SHAFT_YIELD} Arrow Shaft`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < ARROW_SHAFT_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Softwood to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingArrowShaftLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingArrowShaftLoop(now, startTime));
  }
}

// --- Unbound Arrow UI & Logic ---
function openFletchUnboundArrow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unbound Arrow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNBOUND_ARROW_SHAFT_COST} Arrow Shaft, ${UNBOUND_ARROW_FEATHER_COST} Feather. Yields ${UNBOUND_ARROW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnboundArrow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnboundArrow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unbound Arrow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalShafts = 0;
  let totalFeathers = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Arrow Shaft') totalShafts += slot.qty;
      if (slot && slot.name === 'Feather') totalFeathers += slot.qty;
  }

  if (totalShafts < UNBOUND_ARROW_SHAFT_COST || totalFeathers < UNBOUND_ARROW_FEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need ${UNBOUND_ARROW_SHAFT_COST} Arrow Shafts and ${UNBOUND_ARROW_FEATHER_COST} Feathers.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingUnboundArrowLoop(now, now));
}

async function fletchingUnboundArrowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / UNBOUND_ARROW_TIME_MS) * 100;

  if (progress >= 100) {
    let totalShafts = 0;
    let totalFeathers = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Arrow Shaft') totalShafts += slot.qty;
        if (slot && slot.name === 'Feather') totalFeathers += slot.qty;
    }
    if (totalShafts < UNBOUND_ARROW_SHAFT_COST || totalFeathers < UNBOUND_ARROW_FEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Arrow Shaft', UNBOUND_ARROW_SHAFT_COST);
    removeItem('Feather', UNBOUND_ARROW_FEATHER_COST);
    addItem('Unbound Arrow', UNBOUND_ARROW_YIELD);
    addXP('fletching', UNBOUND_ARROW_XP);
    
    showItemPopup(`+${UNBOUND_ARROW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNBOUND_ARROW_YIELD} Unbound Arrow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalShaftsAfter = 0;
    let totalFeathersAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Arrow Shaft') totalShaftsAfter += slot.qty;
        if (slot && slot.name === 'Feather') totalFeathersAfter += slot.qty;
    }
    if (totalShaftsAfter < UNBOUND_ARROW_SHAFT_COST || totalFeathersAfter < UNBOUND_ARROW_FEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingUnboundArrowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingUnboundArrowLoop(now, startTime));
  }
}

// --- Copper Arrow UI & Logic ---
function openFletchCopperArrow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Copper Arrow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_ARROW_UNBOUND_COST} Unbound Arrow, ${COPPER_ARROW_TIP_COST} Copper Arrow Tip. Yields ${COPPER_ARROW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingCopperArrow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingCopperArrow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Copper Arrow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnbound = 0;
  let totalTips = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unbound Arrow') totalUnbound += slot.qty;
      if (slot && slot.name === 'Copper Arrow Tip') totalTips += slot.qty;
  }

  if (totalUnbound < COPPER_ARROW_UNBOUND_COST || totalTips < COPPER_ARROW_TIP_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_ARROW_UNBOUND_COST} Unbound Arrows and ${COPPER_ARROW_TIP_COST} Copper Arrow Tips.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingCopperArrowLoop(now, now));
}

async function fletchingCopperArrowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_ARROW_TIME_MS) * 100;

  if (progress >= 100) {
    let totalUnbound = 0;
    let totalTips = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unbound Arrow') totalUnbound += slot.qty;
        if (slot && slot.name === 'Copper Arrow Tip') totalTips += slot.qty;
    }
    if (totalUnbound < COPPER_ARROW_UNBOUND_COST || totalTips < COPPER_ARROW_TIP_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unbound Arrow', COPPER_ARROW_UNBOUND_COST);
    removeItem('Copper Arrow Tip', COPPER_ARROW_TIP_COST);
    addItem('Copper Arrow', COPPER_ARROW_YIELD);
    addXP('fletching', COPPER_ARROW_XP);
    
    showItemPopup(`+${COPPER_ARROW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${COPPER_ARROW_YIELD} Copper Arrow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalUnboundAfter = 0;
    let totalTipsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unbound Arrow') totalUnboundAfter += slot.qty;
        if (slot && slot.name === 'Copper Arrow Tip') totalTipsAfter += slot.qty;
    }
    if (totalUnboundAfter < COPPER_ARROW_UNBOUND_COST || totalTipsAfter < COPPER_ARROW_TIP_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingCopperArrowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingCopperArrowLoop(now, startTime));
  }
}
// +++ END: FLETCHING HUB FUNCTIONS +++

// +++ NEW: CRAFTING HUB FUNCTIONS +++
function openCraftingHub() {
  showMainScreen('hubCrafting');
  // Render the items for the hub
  renderCraftingItems();
}

/**
 * Stops the bow string crafting loop (used by other functions)
 */
window.stopCraftingBowString = function(){
  game.craftingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const bar = document.getElementById('craftProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCraftBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCraftBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

/**
 * Renders the items available at the Crafting Bench
 */
function renderCraftingItems() {
  const container = document.getElementById('craftingItemsContainer');
  if (!container) return;
  
  const craftLvl = game.crafting.level;
  
  const setupCraftButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => {
    const btn = document.getElementById(btnId);
    if (btn) {
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      if (locked) {
        btn.onclick = null;
        const lockedTT = nameHtml + `Requires Crafting Lvl: ${levelReq}`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  // --- Crafting Level Locks ---
  const bowStringLocked = craftLvl < CRAFTING_BOW_STRING_LVL;
  const leatherLocked = craftLvl < CRAFTING_LEATHER_LVL; // +++ NEW +++
  const leatherBootsLocked = craftLvl < CRAFTING_LEATHER_BOOTS_LVL;
  const leatherHoodLocked = craftLvl < CRAFTING_LEATHER_HOOD_LVL;
  const leatherChapsLocked = craftLvl < CRAFTING_LEATHER_CHAPS_LVL;
  const leatherBodyLocked = craftLvl < CRAFTING_LEATHER_BODY_LVL;

  container.innerHTML = `
    <button id="craftBowStringBtn" class="primary ${bowStringLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/bowstring.png" alt="Bow String" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBtn" class="primary ${leatherLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leather.png" alt="Leather" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBootsBtn" class="primary ${leatherBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherboots.png" alt="Leather Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherHoodBtn" class="primary ${leatherHoodLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherhood.png" alt="Leather Hood" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherChapsBtn" class="primary ${leatherChapsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherpants.png" alt="Leather Chaps" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
    <button id="craftLeatherBodyBtn" class="primary ${leatherBodyLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
      <img src="images/leatherarmor.png" alt="Leather Body" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
    </button>
  `;
  
  // --- Re-attach listeners for crafting items ---
  setupCraftButton('craftBowStringBtn', bowStringLocked, openCraftBowString, CRAFTING_BOW_STRING_LVL, `Requires: ${BOW_STRING_SILK_COST} Silk`, `Bow String x${BOW_STRING_YIELD}`);
  // +++ NEW/UPDATED LISTENERS +++
  setupCraftButton('craftLeatherBtn', leatherLocked, openCraftLeather, CRAFTING_LEATHER_LVL, `Requires: ${LEATHER_HIDE_COST} Cow Hide`, 'Leather');
  setupCraftButton('craftLeatherBootsBtn', leatherBootsLocked, openCraftLeatherBoots, CRAFTING_LEATHER_BOOTS_LVL, `Requires: ${LEATHER_BOOTS_LEATHER_COST} Leather`, 'Leather Boots');
  setupCraftButton('craftLeatherHoodBtn', leatherHoodLocked, openCraftLeatherHood, CRAFTING_LEATHER_HOOD_LVL, `Requires: ${LEATHER_HOOD_LEATHER_COST} Leather`, 'Leather Hood');
  setupCraftButton('craftLeatherChapsBtn', leatherChapsLocked, openCraftLeatherChaps, CRAFTING_LEATHER_CHAPS_LVL, `Requires: ${LEATHER_CHAPS_LEATHER_COST} Leather`, 'Leather Chaps');
  setupCraftButton('craftLeatherBodyBtn', leatherBodyLocked, openCraftLeatherBody, CRAFTING_LEATHER_BODY_LVL, `Requires: ${LEATHER_BODY_LEATHER_COST} Leather`, 'Leather Body');
}

// --- Bow String UI & Logic ---
function openCraftBowString(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching(); // Stop other skills
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Bow String</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${BOW_STRING_SILK_COST} Silk. Yields ${BOW_STRING_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingBowString;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Use the global-scoped function
  showMainScreen('hubDynamic');
}

async function startCraftingBowString() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Bow String')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalSilk = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Silk') totalSilk += slot.qty;
  }

  if (totalSilk < BOW_STRING_SILK_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${BOW_STRING_SILK_COST} Silk.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingBowStringLoop(now, now));
}

async function craftingBowStringLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / BOW_STRING_TIME_MS) * 100;

  if (progress >= 100) {
    let totalSilk = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilk += slot.qty;
    }
    if (totalSilk < BOW_STRING_SILK_COST) {
        await showGameAlert("Out of Materials", "You've run out of Silk.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Silk', BOW_STRING_SILK_COST);
    addItem('Bow String', BOW_STRING_YIELD);
    addXP('crafting', BOW_STRING_XP);
    
    showItemPopup(`+${BOW_STRING_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+${BOW_STRING_YIELD} Bow String`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalSilkAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Silk') totalSilkAfter += slot.qty;
    }
    if (totalSilkAfter < BOW_STRING_SILK_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Silk to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingBowStringLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingBowStringLoop(now, startTime));
  }
}
// +++ END: CRAFTING HUB FUNCTIONS +++

// +++ NEW: LEATHER CRAFTING FUNCTIONS +++

// --- Leather Boots UI & Logic ---
function openCraftLeatherBoots(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_BOOTS_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherBoots;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString; // Can reuse the same stop function
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherBoots() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Boots')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_BOOTS_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_BOOTS_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingLeatherBootsLoop(now, now));
}

async function craftingLeatherBootsLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / LEATHER_BOOTS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_BOOTS_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_BOOTS_LEATHER_COST);
    addItem('Leather Boots', 1);
    addXP('crafting', LEATHER_BOOTS_XP);
    
    showItemPopup(`+${LEATHER_BOOTS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Boots`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_BOOTS_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherBootsLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherBootsLoop(now, startTime));
  }
}

// --- Leather Hood UI & Logic ---
function openCraftLeatherHood(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Hood</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_HOOD_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherHood;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherHood() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Hood')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_HOOD_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_HOOD_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingLeatherHoodLoop(now, now));
}

async function craftingLeatherHoodLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / LEATHER_HOOD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_HOOD_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_HOOD_LEATHER_COST);
    addItem('Leather Hood', 1);
    addXP('crafting', LEATHER_HOOD_XP);
    
    showItemPopup(`+${LEATHER_HOOD_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Hood`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_HOOD_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherHoodLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherHoodLoop(now, startTime));
  }
}

// --- Leather Chaps UI & Logic ---
function openCraftLeatherChaps(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Chaps</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_CHAPS_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherChaps;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherChaps() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Chaps')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_CHAPS_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_CHAPS_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingLeatherChapsLoop(now, now));
}

async function craftingLeatherChapsLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / LEATHER_CHAPS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_CHAPS_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_CHAPS_LEATHER_COST);
    addItem('Leather Chaps', 1);
    addXP('crafting', LEATHER_CHAPS_XP);
    
    showItemPopup(`+${LEATHER_CHAPS_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Chaps`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_CHAPS_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherChapsLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherChapsLoop(now, startTime));
  }
}

// --- Leather Body UI & Logic ---
function openCraftLeatherBody(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather Body</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_BODY_LEATHER_COST} Leather.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeatherBody;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeatherBody() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather Body')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalLeather = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Leather') totalLeather += slot.qty;
  }

  if (totalLeather < LEATHER_BODY_LEATHER_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_BODY_LEATHER_COST} Leather.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingLeatherBodyLoop(now, now));
}

async function craftingLeatherBodyLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / LEATHER_BODY_TIME_MS) * 100;

  if (progress >= 100) {
    let totalLeather = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeather += slot.qty;
    }
    if (totalLeather < LEATHER_BODY_LEATHER_COST) {
        await showGameAlert("Out of Materials", "You've run out of Leather.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Leather', LEATHER_BODY_LEATHER_COST);
    addItem('Leather Body', 1);
    addXP('crafting', LEATHER_BODY_XP);
    
    showItemPopup(`+${LEATHER_BODY_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather Body`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalLeatherAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Leather') totalLeatherAfter += slot.qty;
    }
    if (totalLeatherAfter < LEATHER_BODY_LEATHER_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Leather to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherBodyLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherBodyLoop(now, startTime));
  }
}

// --- Craft Leather (from Hide) UI & Logic ---
function openCraftLeather(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Crafting - Leather</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${LEATHER_HIDE_COST} Cow Hide.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="craftProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCraftBtn" class="primary">Start Crafting</button>
      <button id="stopCraftBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openCraftingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCraftBtn').onclick = startCraftingLeather;
  document.getElementById('stopCraftBtn').onclick = window.stopCraftingBowString;
  showMainScreen('hubDynamic');
}

async function startCraftingLeather() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Leather')) {
    await showGameAlert("Inventory Full", "You have no room to craft this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.craftingActive) return;

  let totalHide = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Cow Hide') totalHide += slot.qty;
  }

  if (totalHide < LEATHER_HIDE_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${LEATHER_HIDE_COST} Cow Hide.`);
      return;
  }
  
  game.craftingActive = true;
  document.getElementById('startCraftBtn').style.display = 'none';
  document.getElementById('stopCraftBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => craftingLeatherLoop(now, now));
}

async function craftingLeatherLoop(timestamp, startTime) {
  if (!game.craftingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / LEATHER_TIME_MS) * 100;

  if (progress >= 100) {
    let totalHide = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cow Hide') totalHide += slot.qty;
    }
    if (totalHide < LEATHER_HIDE_COST) {
        await showGameAlert("Out of Materials", "You've run out of Cow Hide.");
        stopCraftingBowString();
        return;
    }
    
    removeItem('Cow Hide', LEATHER_HIDE_COST);
    addItem('Leather', 1);
    addXP('crafting', LEATHER_XP);
    
    showItemPopup(`+${LEATHER_XP} Crafting XP`, 'craftProgress', 0);
    showItemPopup(`+1 Leather`, 'craftProgress', 450);
    
    document.getElementById('craftProgress').style.width = '0%';
    
    let totalHideAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Cow Hide') totalHideAfter += slot.qty;
    }
    if (totalHideAfter < LEATHER_HIDE_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Cow Hide to make more.");
        stopCraftingBowString();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherLoop(now, now));
  } else {
    document.getElementById('craftProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => craftingLeatherLoop(now, startTime));
  }
}

// +++ END: LEATHER CRAFTING FUNCTIONS +++


// =================================================================
// --- 5. NEW FISHING FUNCTIONS ---
// =================================================================

/**
 * Main function to open the Fishing Areas Hub
 */
function openFishingHub() {
  showMainScreen('hubFishingAreas');
}

/**
 * Opens the Ocean fishing area
 */
function openOceanFishingArea() {
  showMainScreen('hubOcean');
}

/**
 * Opens the River fishing area
 */
function openRiverFishingArea() {
  showMainScreen('hubRiver');
}

/**
 * Generic function to stop any fishing action
 */
function stopFishing(progressId = 'fishProgress', startBtnId = 'startFishBtn', stopBtnId = 'stopFishBtn') {
  game.fishingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// --- Herring (Ocean) UI & Logic ---
function openFishHerring(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Herring</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common ocean fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openOceanFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingHerring;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingHerring() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Herring')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fishingHerringLoop(now, now));
}

async function fishingHerringLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / FISHING_TIME_MS) * 100;

  if (progress >= 100) {
    
    // --- NEW: Check for bait ---
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    removeItem('Fishing Bait', 1); // Consume bait
    addItem('Herring', 1);
    addXP('fishing', HERRING_FISH_XP);
    
    showItemPopup(`+${HERRING_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Herring`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    // --- NEW: Check for bait for *next* loop ---
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Herring');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fishingHerringLoop(now, now));
  } else {
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fishingHerringLoop(now, startTime));
  }
}

// --- Trout (River) UI & Logic ---
function openFishTrout(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Trout</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common river fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openRiverFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingTrout;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingTrout() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Trout')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fishingTroutLoop(now, now));
}

async function fishingTroutLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / FISHING_TIME_MS) * 100;

  if (progress >= 100) {

    // --- NEW: Check for bait ---
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    removeItem('Fishing Bait', 1); // Consume bait
    addItem('Trout', 1);
    addXP('fishing', TROUT_FISH_XP);
    
    showItemPopup(`+${TROUT_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Trout`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    // --- NEW: Check for bait for *next* loop ---
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Trout');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fishingTroutLoop(now, now));
  } else {
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fishingTroutLoop(now, startTime));
  }
}

// --- Salmon (River) UI & Logic ---
function openFishSalmon(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  stopFletching();
  stopCraftingBowString();
  
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fishing - Salmon</h2>
    <div style="margin-top:8px; color:#efe3cf;">A large, strong river fish.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fishProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFishBtn" class="primary">Start Fishing</button>
      <button id="stopFishBtn" class="primary" style="background:#555; display:none;">Stop Fishing</button>
      <button onclick="openRiverFishingArea()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFishBtn').onclick = startFishingSalmon;
  document.getElementById('stopFishBtn').onclick = stopFishing;
  showMainScreen('hubDynamic');
}

async function startFishingSalmon() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Salmon')) {
    await showGameAlert("Inventory Full", "You have no room to fish this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fishingActive) return;

  // --- NEW: Check for Fishing Pole ---
  let hasPole = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Pole') {
          hasPole = true;
          break;
      }
  }
  if (!hasPole) {
      await showGameAlert("Tool Required", "You need a Fishing Pole in your inventory to fish.");
      return;
  }
  // --- END NEW ---

  // --- NEW: Check for Fishing Bait ---
  let hasBait = false;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Fishing Bait') {
          hasBait = true;
          break;
      }
  }
  if (!hasBait) {
      await showGameAlert("Material Required", "You need Fishing Bait in your inventory to fish.");
      return;
  }
  // --- END NEW ---
  
  game.fishingActive = true;
  document.getElementById('startFishBtn').style.display = 'none';
  document.getElementById('stopFishBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fishingSalmonLoop(now, now));
}

async function fishingSalmonLoop(timestamp, startTime) {
  if (!game.fishingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / FISHING_TIME_MS) * 100;

  if (progress >= 100) {
    
    // --- NEW: Check for bait ---
    let hasBait = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBait = true;
            break;
        }
    }
    if (!hasBait) {
        await showGameAlert("Out of Materials", "You've run out of Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    removeItem('Fishing Bait', 1); // Consume bait
    addItem('Salmon', 1);
    addXP('fishing', SALMON_FISH_XP);
    
    showItemPopup(`+${SALMON_FISH_XP} Fishing XP`, 'fishProgress', 0);
    showItemPopup(`+1 Salmon`, 'fishProgress', 450);
    
    document.getElementById('fishProgress').style.width = '0%';
    
    // --- NEW: Check for bait for *next* loop ---
    let hasBaitAfter = false;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Fishing Bait') {
            hasBaitAfter = true;
            break;
        }
    }
    if (!hasBaitAfter) {
        await showGameAlert("Not Enough Materials", "You don't have any more Fishing Bait.");
        stopFishing();
        return;
    }
    // --- END NEW ---

    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    const stackIndex = game.inventory.findIndex(slot => slot && slot.name === 'Salmon');
    if (emptySlotIndex === -1 && stackIndex === -1) {
        await showGameAlert("Inventory Full", "Your inventory is full.");
        stopFishing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fishingSalmonLoop(now, now));
  } else {
    document.getElementById('fishProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fishingSalmonLoop(now, startTime));
  }
}

// =================================================================
// --- END NEW FISHING FUNCTIONS ---
// =================================================================


// --- Unstrung Softwood Bow UI & Logic ---
function openFletchUnstrungSoftwoodBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unstrung Softwood Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood. Yields ${UNSTRUNG_SOFTWOOD_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnstrungSoftwoodBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnstrungSoftwoodBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unstrung Softwood Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalWood < UNSTRUNG_SOFTWOOD_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${UNSTRUNG_SOFTWOOD_WOOD_COST} Softwood.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungSoftwoodBowLoop(now, now));
}

async function fletchingUnstrungSoftwoodBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / UNSTRUNG_SOFTWOOD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalWood < UNSTRUNG_SOFTWOOD_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Softwood.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Softwood', UNSTRUNG_SOFTWOOD_WOOD_COST);
    addItem('Unstrung Softwood Bow', UNSTRUNG_SOFTWOOD_YIELD);
    addXP('fletching', UNSTRUNG_SOFTWOOD_XP);
    
    showItemPopup(`+${UNSTRUNG_SOFTWOOD_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNSTRUNG_SOFTWOOD_YIELD} Unstrung Softwood Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < UNSTRUNG_SOFTWOOD_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Softwood to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungSoftwoodBowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungSoftwoodBowLoop(now, startTime));
  }
}

// --- Softwood Bow UI & Logic ---
function openFletchSoftwoodBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Softwood Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow, ${SOFTWOOD_BOW_STRING_COST} Bow String. Yields ${SOFTWOOD_BOW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingSoftwoodBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingSoftwoodBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Softwood Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnstrung = 0;
  let totalStrings = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrung += slot.qty;
      if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
  }

  if (totalUnstrung < SOFTWOOD_BOW_UNSTRUNG_COST || totalStrings < SOFTWOOD_BOW_STRING_COST) {
      await showGameAlert("Not Enough Materials", `You need ${SOFTWOOD_BOW_UNSTRUNG_COST} Unstrung Softwood Bow and ${SOFTWOOD_BOW_STRING_COST} Bow String.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingSoftwoodBowLoop(now, now));
}

async function fletchingSoftwoodBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SOFTWOOD_BOW_TIME_MS) * 100;

  if (progress >= 100) {
    let totalUnstrung = 0;
    let totalStrings = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrung += slot.qty;
        if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
    }
    if (totalUnstrung < SOFTWOOD_BOW_UNSTRUNG_COST || totalStrings < SOFTWOOD_BOW_STRING_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unstrung Softwood Bow', SOFTWOOD_BOW_UNSTRUNG_COST);
    removeItem('Bow String', SOFTWOOD_BOW_STRING_COST);
    addItem('Softwood Bow', SOFTWOOD_BOW_YIELD);
    addXP('fletching', SOFTWOOD_BOW_XP);
    
    showItemPopup(`+${SOFTWOOD_BOW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${SOFTWOOD_BOW_YIELD} Softwood Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalUnstrungAfter = 0;
    let totalStringsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Softwood Bow') totalUnstrungAfter += slot.qty;
        if (slot && slot.name === 'Bow String') totalStringsAfter += slot.qty;
    }
    if (totalUnstrungAfter < SOFTWOOD_BOW_UNSTRUNG_COST || totalStringsAfter < SOFTWOOD_BOW_STRING_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingSoftwoodBowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingSoftwoodBowLoop(now, startTime));
  }
}

// --- Unstrung Oak Bow UI & Logic ---
function openFletchUnstrungOakBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Unstrung Oak Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${UNSTRUNG_OAK_WOOD_COST} Oak. Yields ${UNSTRUNG_OAK_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingUnstrungOakBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingUnstrungOakBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Unstrung Oak Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalWood < UNSTRUNG_OAK_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${UNSTRUNG_OAK_WOOD_COST} Oak.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungOakBowLoop(now, now));
}

async function fletchingUnstrungOakBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / UNSTRUNG_OAK_TIME_MS) * 100;

  if (progress >= 100) {
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalWood < UNSTRUNG_OAK_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of Oak.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Oak', UNSTRUNG_OAK_WOOD_COST);
    addItem('Unstrung Oak Bow', UNSTRUNG_OAK_YIELD);
    addXP('fletching', UNSTRUNG_OAK_XP);
    
    showItemPopup(`+${UNSTRUNG_OAK_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${UNSTRUNG_OAK_YIELD} Unstrung Oak Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalWoodAfter < UNSTRUNG_OAK_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough Oak to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungOakBowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingUnstrungOakBowLoop(now, startTime));
  }
}

// --- Oak Bow UI & Logic ---
function openFletchOakBow(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Fletching - Oak Bow</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow, ${OAK_BOW_STRING_COST} Bow String. Yields ${OAK_BOW_YIELD}.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="fletchProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startFletchBtn" class="primary">Start Fletching</button>
      <button id="stopFletchBtn" class="primary" style="background:#555; display:none;">Stop Fletching</button>
      <button onclick="openFletchingHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startFletchBtn').onclick = startFletchingOakBow;
  document.getElementById('stopFletchBtn').onclick = () => stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn'); 
  showMainScreen('hubDynamic');
}

async function startFletchingOakBow() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem('Oak Bow')) {
    await showGameAlert("Inventory Full", "You have no room to fletch this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.fletchingActive) return;

  let totalUnstrung = 0;
  let totalStrings = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrung += slot.qty;
      if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
  }

  if (totalUnstrung < OAK_BOW_UNSTRUNG_COST || totalStrings < OAK_BOW_STRING_COST) {
      await showGameAlert("Not Enough Materials", `You need ${OAK_BOW_UNSTRUNG_COST} Unstrung Oak Bow and ${OAK_BOW_STRING_COST} Bow String.`);
      return;
  }
  
  game.fletchingActive = true;
  document.getElementById('startFletchBtn').style.display = 'none';
  document.getElementById('stopFletchBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => fletchingOakBowLoop(now, now));
}

async function fletchingOakBowLoop(timestamp, startTime) {
  if (!game.fletchingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / OAK_BOW_TIME_MS) * 100;

  if (progress >= 100) {
    let totalUnstrung = 0;
    let totalStrings = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrung += slot.qty;
        if (slot && slot.name === 'Bow String') totalStrings += slot.qty;
    }
    if (totalUnstrung < OAK_BOW_UNSTRUNG_COST || totalStrings < OAK_BOW_STRING_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    
    removeItem('Unstrung Oak Bow', OAK_BOW_UNSTRUNG_COST);
    removeItem('Bow String', OAK_BOW_STRING_COST);
    addItem('Oak Bow', OAK_BOW_YIELD);
    addXP('fletching', OAK_BOW_XP);
    
    showItemPopup(`+${OAK_BOW_XP} Fletching XP`, 'fletchProgress', 0);
    showItemPopup(`+${OAK_BOW_YIELD} Oak Bow`, 'fletchProgress', 450);
    
    document.getElementById('fletchProgress').style.width = '0%';
    
    let totalUnstrungAfter = 0;
    let totalStringsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Unstrung Oak Bow') totalUnstrungAfter += slot.qty;
        if (slot && slot.name === 'Bow String') totalStringsAfter += slot.qty;
    }
    if (totalUnstrungAfter < OAK_BOW_UNSTRUNG_COST || totalStringsAfter < OAK_BOW_STRING_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to make more.");
        stopFletching('fletchProgress', 'startFletchBtn', 'stopFletchBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => fletchingOakBowLoop(now, now));
  } else {
    document.getElementById('fletchProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => fletchingOakBowLoop(now, startTime));
  }
}


function renderSmithingItems(metalType) {
  const container = document.getElementById('smithingItemsContainer');
  if (!container) return;
  
  const smithLvl = game.blacksmith.level;
  
  // --- Helper function for locked buttons (moved inside) ---
  const setupSmithButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => { // Added itemName
    const btn = document.getElementById(btnId);
    if (btn) {
      // Create the new tooltip header
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      
      if (locked) {
        btn.onclick = null;
        // Add name to the locked tooltip
        const lockedTT = nameHtml + `Requires Blacksmith Lvl: ${levelReq}`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        // Add name to the unlocked tooltip
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  if (metalType === 'copper') {
    // --- Copper Level Locks ---
    const copperBarLocked = smithLvl < COPPER_BAR_LVL;
    const copperPickaxeLocked = smithLvl < COPPER_PICKAXE_LVL; // +++ NEW +++
    const copperAxeLocked = smithLvl < COPPER_AXE_LVL;       // +++ NEW +++
    const copperSwordLocked = smithLvl < COPPER_SWORD_LVL;
    const copperBootsLocked = smithLvl < COPPER_BOOTS_LVL;
    const copperHelmetLocked = smithLvl < COPPER_HELMET_LVL;
    const copperPlatelegsLocked = smithLvl < COPPER_PLATELEGS_LVL; // +++ NEW +++
    const copperChestLocked = smithLvl < COPPER_CHEST_LVL;
    const copperTipsLocked = smithLvl < BLACKSMITH_COPPER_TIPS_LVL; // +++ NEW +++
    
    container.innerHTML = `
      <button id="copperBarBtn" class="primary ${copperBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperbar.png" alt="Copper Bar" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperPickaxeBtn" class="primary ${copperPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperpickaxe.png" alt="Copper Pickaxe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperAxeBtn" class="primary ${copperAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperaxe.png" alt="Copper Axe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperShortswordBtn" class="primary ${copperSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/coppershortsword.png" alt="Copper Shortsword" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperBootsBtn" class="primary ${copperBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperboots.png" alt="Copper Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperHelmetBtn" class="primary ${copperHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperhelmet.png" alt="Copper Helmet" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperPlatelegsBtn" class="primary ${copperPlatelegsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperplatelegs.png" alt="Copper Platelegs" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperChestplateBtn" class="primary ${copperChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperchestplate.png" alt="Copper Chestplate" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperArrowTipBtn" class="primary ${copperTipsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperarrowtip.png" alt="Copper Arrow Tip" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for copper items ---
    setupSmithButton('copperBarBtn', copperBarLocked, openCopperBarSmith, COPPER_BAR_LVL, 'Requires: 2 Copper Ore', 'Copper Bar');
    setupSmithButton('copperPickaxeBtn', copperPickaxeLocked, openCopperPickaxeSmith, COPPER_PICKAXE_LVL, `Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood`, 'Copper Pickaxe');
    setupSmithButton('copperAxeBtn', copperAxeLocked, openCopperAxeSmith, COPPER_AXE_LVL, `Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood`, 'Copper Axe');
    setupSmithButton('copperShortswordBtn', copperSwordLocked, openCopperShortswordSmith, COPPER_SWORD_LVL, `Requires: ${SHORTSWORD_BAR_COST} Copper Bars`, 'Copper Shortsword');
    setupSmithButton('copperBootsBtn', copperBootsLocked, openCopperBootsSmith, COPPER_BOOTS_LVL, `Requires: ${BOOTS_BAR_COST} Copper Bars`, 'Copper Boots');
    setupSmithButton('copperHelmetBtn', copperHelmetLocked, openCopperHelmetSmith, COPPER_HELMET_LVL, `Requires: ${HELMET_BAR_COST} Copper Bars`, 'Copper Helmet');
    setupSmithButton('copperPlatelegsBtn', copperPlatelegsLocked, openCopperPlatelegsSmith, COPPER_PLATELEGS_LVL, `Requires: ${COPPER_PLATELEGS_BAR_COST} Copper Bars`, 'Copper Platelegs'); // +++ NEW +++
    setupSmithButton('copperChestplateBtn', copperChestLocked, openCopperChestplateSmith, COPPER_CHEST_LVL, `Requires: ${CHESTPLATE_BAR_COST} Copper Bars`, 'Copper Chestplate');
    setupSmithButton('copperArrowTipBtn', copperTipsLocked, openSmithCopperArrowTip, BLACKSMITH_COPPER_TIPS_LVL, `Requires: ${COPPER_ARROW_TIP_BAR_COST} Copper Bars`, `Copper Arrow Tip x${COPPER_ARROW_TIP_YIELD}`); // +++ NEW +++
    
  } else if (metalType === 'iron') {
    // --- Iron Level Locks ---
    const ironBarLocked = smithLvl < IRON_BAR_LVL;
    const ironPickaxeLocked = smithLvl < IRON_PICKAXE_LVL; // +++ NEW +++
    const ironAxeLocked = smithLvl < IRON_AXE_LVL;       // +++ NEW +++
    const ironSwordLocked = smithLvl < IRON_SWORD_LVL;
    const ironBootsLocked = smithLvl < IRON_BOOTS_LVL;
    const ironHelmetLocked = smithLvl < IRON_HELMET_LVL;
    const ironPlatelegsLocked = smithLvl < IRON_PLATELEGS_LVL; // +++ NEW +++
    const ironChestLocked = smithLvl < IRON_CHEST_LVL;
    
    container.innerHTML = `
      <button id="ironBarBtn" class="primary ${ironBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironbar.png" alt="Iron Bar" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironPickaxeBtn" class="primary ${ironPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironpickaxe.png" alt="Iron Pickaxe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironAxeBtn" class="primary ${ironAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironaxe.png" alt="Iron Axe" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironShortswordBtn" class="primary ${ironSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironshortsword.png" alt="Iron Shortsword" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironBootsBtn" class="primary ${ironBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironboots.png" alt="Iron Boots" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironHelmetBtn" class="primary ${ironHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironhelmet.png" alt="Iron Helmet" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironPlatelegsBtn" class="primary ${ironPlatelegsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironplatelegs.png" alt="Iron Platelegs" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironChestplateBtn" class="primary ${ironChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironchestplate.png" alt="Iron Chestplate" style="width: 60px; height: 60px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for iron items ---
    setupSmithButton('ironBarBtn', ironBarLocked, openIronBarSmith, IRON_BAR_LVL, `Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore`, 'Iron Bar');
    setupSmithButton('ironPickaxeBtn', ironPickaxeLocked, openIronPickaxeSmith, IRON_PICKAXE_LVL, `Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak`, 'Iron Pickaxe');
    setupSmithButton('ironAxeBtn', ironAxeLocked, openIronAxeSmith, IRON_AXE_LVL, `Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak`, 'Iron Axe');
    setupSmithButton('ironShortswordBtn', ironSwordLocked, openIronShortswordSmith, IRON_SWORD_LVL, `Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars`, 'Iron Shortsword');
    setupSmithButton('ironBootsBtn', ironBootsLocked, openIronBootsSmith, IRON_BOOTS_LVL, `Requires: ${IRON_BOOTS_BAR_COST} Iron Bars`, 'Iron Boots');
    setupSmithButton('ironHelmetBtn', ironHelmetLocked, openIronHelmetSmith, IRON_HELMET_LVL, `Requires: ${IRON_HELMET_BAR_COST} Iron Bars`, 'Iron Helmet');
    setupSmithButton('ironPlatelegsBtn', ironPlatelegsLocked, openIronPlatelegsSmith, IRON_PLATELEGS_LVL, `Requires: ${IRON_PLATELEGS_BAR_COST} Iron Bars`, 'Iron Platelegs'); // +++ NEW +++
    setupSmithButton('ironChestplateBtn', ironChestLocked, openIronChestplateSmith, IRON_CHEST_LVL, `Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars`, 'Iron Chestplate');
  }
}

// --- NEW: Coal Mine UI ---

function openCopperMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Copper Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}




function openCoalMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Coal Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A dark, crumbly coal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCoalMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Coal Mine Logic ---
async function startCoalMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++
  
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(COAL_MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++

  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => coalMiningLoop(now, now));
}

function coalMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COAL_MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(COAL_MINE_ITEM, 1);
    addXP('mining', COAL_MINE_XP);

    showItemPopup(`+${COAL_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${COAL_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_COAL_MS, 'mineProgressText', coalMiningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => coalMiningLoop(now, startTime));
  }
}

// --- NEW: Iron Mine UI ---
function openIronMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Iron Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A sturdy iron vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startIronMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Mine Logic ---
async function startIronMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(IRON_MINE_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to mine this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironMiningLoop(now, now));
}

function ironMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(IRON_MINE_ITEM, 1);
    addXP('mining', IRON_MINE_XP);

    showItemPopup(`+${IRON_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${IRON_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_IRON_MS, 'mineProgressText', ironMiningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironMiningLoop(now, startTime));
  }
}

function openMineHub() {
  showMainScreen('hubMine');
}

// --- NEW: Woodcutting Hub UI ---
function openForestHub() {
  showMainScreen('hubForest');
}

// --- NEW: Softwood Tree UI ---
function openSoftwoodTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Softwood Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common, pliable tree.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingSoftwood;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Oak Tree UI ---
function openOakTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Oak Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A strong, sturdy oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingOak;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Stop Woodcutting Logic ---
function stopWoodcutting(){
  game.woodcuttingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const textEl = document.getElementById('woodcutProgressText');
  if (textEl) textEl.innerText = '';

  const bar = document.getElementById('woodcutProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startChopBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopChopBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// --- NEW: Woodcutting Cooldown Loop ---
function woodcuttingCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.woodcuttingActive) {
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = timestamp - startTime;
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    game.progressFrame = requestAnimationFrame((now) => nextLoopFunction(now, now));
  } else {
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, startTime, duration, progressTextId, nextLoopFunction)
    );
  }
}

// --- NEW: Softwood Logic ---
async function startChoppingSoftwood() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(SOFTWOOD_CHOP_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to chop this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => softwoodChoppingLoop(now, now));
}

function softwoodChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SOFTWOOD_CHOP_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(SOFTWOOD_CHOP_ITEM, 1);
    addXP('woodcutting', SOFTWOOD_CHOP_XP);

    showItemPopup(`+${SOFTWOOD_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${SOFTWOOD_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, now, CHOP_COOLDOWN_SOFTWOOD_MS, 'woodcutProgressText', softwoodChoppingLoop)
    );
  } else {
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => softwoodChoppingLoop(now, startTime));
  }
}

// --- NEW: Oak Logic ---
async function startChoppingOak() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // +++ NEW INVENTORY CHECK +++
  if (!canReceiveItem(OAK_CHOP_ITEM)) {
    await showGameAlert("Inventory Full", "You have no room to chop this.");
    return;
  }
  // +++ END NEW +++
  
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => oakChoppingLoop(now, now));
}

function oakChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / OAK_CHOP_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(OAK_CHOP_ITEM, 1);
    addXP('woodcutting', OAK_CHOP_XP);

    showItemPopup(`+${OAK_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${OAK_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, now, CHOP_COOLDOWN_OAK_MS, 'woodcutProgressText', oakChoppingLoop)
    );
  } else {
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => oakChoppingLoop(now, startTime));
  }
}

function openCombatHub() {
  showMainScreen('hubCombat');
  // Preload the assets for the *next* screen
  // (We can't use preloadImages anymore, but this asset is already in the master list)
}

function openFarmCombatArea() {
  game.lastCombatAreaHub = 'hubFarm'; // +++ SET LAST HUB +++
  showMainScreen('hubFarm');
}

// +++ NEW CAVE HUB FUNCTION +++
function openCaveCombatArea() {
  game.lastCombatAreaHub = 'hubCave'; // +++ SET LAST HUB +++
  showMainScreen('hubCave');
}

// NEW: Function to build and open the main combat UI
function openCombatInterface(enemyName) {
  // Stop any skilling
  if (game.miningActive) {
    stopMining();
    game.wasMiningBeforeCombat = true;
  }
  if (game.blacksmithingActive) {
    stopBlacksmithing();
    game.wasSmithingBeforeCombat = true;
  }
  if (game.woodcuttingActive) { // +++ NEW +++
    stopWoodcutting();
    game.wasWoodcuttingBeforeCombat = true;
  }
  if (game.fletchingActive) { // +++ NEW +++
    stopFletching();
    game.wasFletchingBeforeCombat = true;
  }
  if (game.craftingActive) { // +++ NEW +++
    stopCraftingBowString();
    game.wasCraftingBeforeCombat = true;
  }
  
  // +++ NEW FISHING CHECK +++
  if (game.fishingActive) {
    stopFishing();
    game.wasFishingBeforeCombat = true;
  }
  
  // Define our enemy
  if (enemyName === 'Chicken') {
    game.currentEnemy = {
      name: 'Chicken',
      level: 1,
      maxHp: 10,
      currentHp: 10,
      attack: 1, // Low attack level
      strength: 1, // Max hit is 1
      defence: 1, // Low defence
      img: 'images/chickenanim.gif'
    };
  } else if (enemyName === 'Spider') { // +++ THIS IS THE NEW BLOCK +++
    game.currentEnemy = {
      name: 'Spider',
      level: 2,
      maxHp: 12,
      currentHp: 12,
      attack: 2, 
      strength: 2, // Max hit is 2
      defence: 2, 
      img: 'images/spideranim.gif'
    };

} else if (enemyName === 'Cow') {
    game.currentEnemy = {
      name: 'Cow',
      level: 2,
      maxHp: 12,
      currentHp: 12,
      attack: 2, 
      strength: 2, // Max hit is 2
      defence: 2, 
      img: 'images/cowanim.webp'
    };

  } else {
    console.error('Unknown enemy:', enemyName);
    return;
  }
  
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  
  // --- This is the new UI layout you described ---
  wrapper.innerHTML = `
    <div id="combat-main-container">
    
      <div id="combat-enemy-area">
        <img id="combat-enemy-img" src="${game.currentEnemy.img}" alt="${game.currentEnemy.name}">
        <div id="combat-enemy-hp-bar">
          <div id="combat-enemy-hp-fill" style="width:100%"></div>
          <div id="combat-enemy-hp-text">10 / 10 HP</div>
        </div>
      </div>
      
      <div id="combat-player-area">
        
        <div id="combat-action-panel">
          <p style="margin: 0 0 10px 0; font-weight: bold;">Combat Style:</p>
          <div id="combat-styles">
            <button id="style-attack" class="primary" onclick="setAttackStyle('attack')">Accurate</button>
            <button id="style-strength" class="primary" onclick="setAttackStyle('strength')">Aggressive</button>
            <button id="style-defence" class="primary" onclick="setAttackStyle('defence')">Defensive</button>
          </div>
          
          
          <div id="combat-main-actions">
            <button id="combat-fight-btn" class="primary" style="background:#900;" onclick="beginCombat()">Fight</button>
            <button id="combat-run-btn" class="primary" style="background:#080; display:none;" onclick="runFromCombat()">Run</button>
            <button id="combat-return-btn" class="primary" style="background:#555;" onclick="returnToCombatArea()">Return</button>
          </div>
          
        </div>
      </div>
    </div>
  `;
  
  // --- THIS IS THE FIX ---
  updateEnemyCombatUI(); // <-- THIS IS THE NEW LINE
  renderEquipment();
  // --- END FIX ---

  // Set the default active style button
  setAttackStyle(game.playerAttackStyle, true); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
function setAttackStyle(style, isInitialization = false) {
  game.playerAttackStyle = style;
  
  // Update button visual state
  const styles = ['attack', 'strength', 'defence'];
  styles.forEach(s => {
    const btn = document.getElementById(`style-${s}`);
    if (btn) {
      if (s === style) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    }
  });
  
  // --- THIS IS THE FIX ---
  // Re-render equipment to update stats (like style bonuses)
  // This will also update the combat UI equipment panel if it's open
  renderEquipment(); 
  // --- END FIX ---

  if (!isInitialization) {
    // Line deleted
  }
}




// NEW: Function to start the combat loops
function beginCombat() {
  if (game.inCombat) return; 
  if (!game.isSessionActive) {
    showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  // --- NEW ARROW CHECK ---
  const weapon = game.equipment.weapon;
  const isRanged = (weapon && weapon.name.endsWith('Bow'));
  
  if (isRanged) {
      const arrows = game.equipment.arrows;
      if (!arrows || arrows.qty < 1) {
          showWarningPopup("You don't have any arrows equipped.");
          return; // Stop the fight from starting
      }
  }
  // --- END NEW CHECK ---
  
  game.inCombat = true;
  document.getElementById('combat-fight-btn').style.display = 'none'; 
  document.getElementById('combat-run-btn').style.display = 'block'; 
  document.getElementById('combat-run-btn').disabled = false;
  
  // --- NEW: Calculate stats and set dynamic attack speed ---
  const stats = getPlayerCombatStats();
  
  // Player attacks at their calculated attack speed
  game.playerCombatInterval = setInterval(playerAttackTurn, stats.attackSpeed);
  
  // Enemy (Chicken) attacks every 3.0 seconds
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
}

// NEW: Function to restart ONLY the player's attack interval
function restartPlayerAttackInterval() {
  if (!game.inCombat || !game.currentEnemy) return; // Should already be in combat
  
  // 1. Clear ONLY the player's interval
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  
  // 2. Get new stats
  const stats = getPlayerCombatStats();
  
  // 3. Restart ONLY the player's interval
  game.playerCombatInterval = setInterval(playerAttackTurn, stats.attackSpeed);
  
  // 4. Re-enable the run button
  const runBtn = document.getElementById('combat-run-btn');
  if (runBtn) runBtn.disabled = false;
}

// NEW: Function to restart combat intervals without resetting the fight
function restartCombatIntervals() {
  if (!game.inCombat || !game.currentEnemy) return; // Should already be in combat
  
  // 1. Clear existing intervals
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  
  // 2. Get new stats
  const stats = getPlayerCombatStats();
  
  // 3. Restart intervals
  game.playerCombatInterval = setInterval(playerAttackTurn, stats.attackSpeed);
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
  
  // 4. Re-enable the run button
  const runBtn = document.getElementById('combat-run-btn');
  if (runBtn) runBtn.disabled = false;
}

// NEW: Function to stop combat
function runFromCombat(playerDied = false) {
  if (!game.inCombat) return; // Can't run if not in a fight
  
  game.inCombat = false;
  
  // Stop the attack loops
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  game.playerCombatInterval = null;
  game.enemyCombatInterval = null;

  const fightBtn = document.getElementById('combat-fight-btn');
  const runBtn = document.getElementById('combat-run-btn');
  const returnBtn = document.getElementById('combat-return-btn');
  
  if (playerDied) {
    // Player is dead, disable all actions
    if (fightBtn) fightBtn.disabled = true;
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'none';
  } else {
    // Player clicked "Run"
    if (fightBtn) fightBtn.style.display = 'block'; // SHOW Fight
    if (fightBtn) fightBtn.disabled = false;
    if (runBtn) runBtn.style.display = 'none'; // HIDE Run
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'block'; // Show return

    // Reset enemy HP
    if (game.currentEnemy) {
        game.currentEnemy.currentHp = game.currentEnemy.maxHp;
        updateEnemyCombatUI();
    }
  }
}

function returnToCombatArea() { // +++ RENAMED FUNCTION +++
  // +++ NEW FIX: Stop combat loops +++
  if (game.inCombat) {
    game.inCombat = false;
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
    game.playerCombatInterval = null;
    game.enemyCombatInterval = null;
  }
  // +++ END FIX +++

  // 1. Go back to the correct combat hub screen
  showMainScreen(game.lastCombatAreaHub); 
  
  // 2. Check if we need to resume skilling
  if (game.wasMiningBeforeCombat) {
    openCopperMine(); // Re-opens the mine UI
    startMining();      // Restarts mining
  } else if (game.wasSmithingBeforeCombat) {
    // This is more complex, might need to know *which* item
    openBlacksmithHub(); // Just return to hub for now
  } else if (game.wasWoodcuttingBeforeCombat) { // +++ NEW +++
    openForestHub(); // Return to Forest hub
  } else if (game.wasFletchingBeforeCombat) { // +++ NEW +++
    openFletchingHub(); // Return to Fletching hub
  } else if (game.wasCraftingBeforeCombat) { // +++ NEW +++
    openCraftingHub(); // Return to Crafting hub
  } else if (game.wasFishingBeforeCombat) { // +++ NEW +++
    openFishingHub(); // Return to Fishing hub
  }
  game.wasMiningBeforeCombat = false;
  game.wasSmithingBeforeCombat = false;
  game.wasWoodcuttingBeforeCombat = false; // +++ NEW +++
  game.wasFletchingBeforeCombat = false; // +++ NEW +++
  game.wasCraftingBeforeCombat = false; // +++ NEW +++
  game.wasFishingBeforeCombat = false; // +++ NEW +++
}

// NEW: Helper function to update the enemy's HP bar
function updateEnemyCombatUI() {
  if (!game.currentEnemy) return;
  
  const enemy = game.currentEnemy;
  const percent = Math.max(0, (enemy.currentHp / enemy.maxHp) * 100);
  
  const fill = document.getElementById('combat-enemy-hp-fill');
  const text = document.getElementById('combat-enemy-hp-text');
  
  if (fill) fill.style.width = percent + '%';
  if (text) text.textContent = `${enemy.currentHp} / ${enemy.maxHp} HP`;
}

function showDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'flex';
}

/**
 * Hides the death overlay.
 */
function hideDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'none';
}

/**
 * Handles all logic when a player's HP reaches 0.
 */
function handlePlayerDeath() {
  // 1. Wipe inventory
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  renderInventoryGrid();
  
  // 2. Wipe gold
  game.gold = 0;
  updateGoldUI();
  
  // 3. Save the empty state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 4. Show the death modal
  showDeathOverlay();
}

/**
 * Handles the "Revive" button click.
 */
function revivePlayer() {
  // 1. Hide the modal
  hideDeathOverlay();
  
  // 2. Restore HP
  game.hp = game.maxHP;
  updateHPUI();
  
  // 3. Go back to the main hub
  backToActions();
  
  // 4. Save the new HP state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}
// --- END: Death & Revive Functions ---


function showDamageSplat(target, amount, type) {
  let anchorElement = null;
  if (target === 'player') {
    // This finds the player's main hp-bar
    anchorElement = document.getElementById('hpFill').parentElement; 
  } else if (target === 'enemy') {
    anchorElement = document.getElementById('combat-enemy-hp-bar');
  }

  if (!anchorElement) return;

  const splat = document.createElement('div');
  splat.className = 'combat-splat';
  
  if (type === 'damage') {
    splat.classList.add('splat-damage');
    splat.textContent = amount;
  } else { // 'block'
    splat.classList.add('splat-block');
    splat.textContent = '0';
  }
  
  // Randomize horizontal position slightly
  splat.style.right = (Math.floor(Math.random() * 20) - 40) + 'px';
  
  anchorElement.appendChild(splat);
  setTimeout(() => splat.remove(), 850); // Remove just before animation ends
}

function playerAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- NEW: Check for arrows BEFORE attacking ---
  const weapon = game.equipment.weapon;
  const isRanged = (weapon && weapon.name.endsWith('Bow'));
  
  if (isRanged) {
      const arrows = game.equipment.arrows;
      if (!arrows || arrows.qty < 1) {
          showWarningPopup("You ran out of arrows!");
          runFromCombat(false); // Stop the fight
          return; // Exit the function
      }
  }
  // --- END NEW CHECK ---

  // --- NEW: Play attack sound ---
  if (isRanged) {
    playGlobalSound('sounds/soundeffects/arrowsoundeffect.mp3');
  } else {
    playGlobalSound('sounds/soundeffects/swordsoundeffect.mp3');
  }
  // --- END NEW ---
  

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- 2. Calculate Hit Chance (ALL NEW LOGIC) ---
  const baseHitChance = 70;
  // Get the correct offensive skill (Ranged or Attack) and style bonus
  const playerAccuracy = playerStats.offensiveSkillLevel + playerStats.accuracyBonus;
  const enemyDefence = game.currentEnemy.defence;
  
  let hitChance = baseHitChance + (playerAccuracy - enemyDefence);
  hitChance = Math.max(10, Math.min(90, hitChance)); // Clamp between 10% and 90%

  if (Math.random() * 100 > hitChance) {
    showDamageSplat('enemy', 0, 'block'); // ENEMY MISS
    return;
  }
  // --- END NEW HIT CHANCE ---

  // --- 3. Calculate Damage (If Hit) ---
  // Get the final max hit (which already includes style bonuses)
  let maxHit = playerStats.physicalDamage;
  
  // Damage is a random number from 0 to your max hit
  let damage = Math.floor(Math.random() * (maxHit + 1));

  // +++ FIX: CAP DAMAGE TO ENEMY'S REMAINING HP +++
  let damageApplied = Math.min(damage, game.currentEnemy.currentHp);

  if (damageApplied > 0) {
    showDamageSplat('enemy', damageApplied, 'damage'); // ENEMY HIT
  } else {
    showDamageSplat('enemy', 0, 'block'); // ENEMY HIT A 0
  }

  // Apply damage to enemy
  game.currentEnemy.currentHp -= damageApplied;
  updateEnemyCombatUI();
  
  // --- NEW: Consume Arrow AFTER shot ---
  if (isRanged) {
      game.equipment.arrows.qty--;
      if (game.equipment.arrows.qty <= 0) {
          game.equipment.arrows = null;
      }
      renderEquipment(); // Update the UI to show 1 less arrow
  }
  // --- END NEW ---

  // --- 4. Grant XP (ALL NEW LOGIC) ---
  if (damageApplied > 0) {
    let mainXPGained = damageApplied * 4;
    let vitalityXPGained = Math.ceil(mainXPGained / 2);
    addXP('vitality', vitalityXPGained, 450); // Always grant Vitality XP

    if (isRanged) {
        // --- RANGED XP ---
        if (game.playerAttackStyle === 'defence') {
            // Split Ranged / Defence
            let defenceXp = Math.floor(mainXPGained / 2);
            let rangedXp = Math.ceil(mainXPGained / 2);
            addXP('defence', defenceXp, 0);
            addXP('ranged', rangedXp, 0);
        } else {
            // Ranged on Accurate or Aggressive
            addXP('ranged', mainXPGained, 0);
        }
    } else {
        // --- MELEE XP ---
        // This is the simple, original logic for melee styles
        // 'accurate' trains attack, 'aggressive' trains strength, 'defence' trains defence
        addXP(game.playerAttackStyle, mainXPGained, 0);
    }
  }
  // --- END NEW XP LOGIC ---

  // --- 5. Check for Enemy Death ---
  if (game.currentEnemy.currentHp <= 0) {
    // --- NEW: Multi-item loot drop ---
    if (game.currentEnemy.name === 'Chicken') { // +++ CHECK ENEMY NAME +++
      addItem('Raw Chicken', 1);
      const featherQty = Math.floor(Math.random() * 5) + 2; // 2 to 6 Feathers
      addItem('Feather', featherQty);
      
      showItemPopup('+1 Raw Chicken', null, 900);
      showItemPopup(`+${featherQty} Feather`, null, 1350); // Show feather popup slightly after
    } else if (game.currentEnemy.name === 'Spider') { // +++ NEW SPIDER DROP +++
      const silkQty = Math.floor(Math.random() * 3) + 1; // 1 to 3 Silk
      addItem('Silk', silkQty);
      
      showItemPopup(`+${silkQty} Silk`, null, 900);
    } else if (game.currentEnemy.name === 'Cow') {
      addItem('Cow Hide', 1);
      showItemPopup(`+1 Cow Hide`, null, 900);
    }


    
    // --- END NEW ---
    
    game.currentEnemy.currentHp = game.currentEnemy.maxHp;
    updateEnemyCombatUI();
  }
}

// NEW: The Enemy's turn to attack
function enemyAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- 2. Calculate Hit Chance ---
  let hitChance = 25 + (game.currentEnemy.attack - game.defence.level);
  hitChance = Math.max(5, Math.min(50, hitChance)); 
  
  if (Math.random() * 100 > hitChance) {
    showDamageSplat('player', 0, 'block'); // PLAYER MISS
    return;
  }

  // --- 3. Calculate Damage (If Hit) ---
  let maxHit = game.currentEnemy.strength; // Chicken max hit is 1
  let damage = Math.floor(Math.random() * (maxHit + 1)); // Will be 0 or 1

  // --- 4. Apply Damage Reduction ---
  // 'playerStats.armor' is the total armor from skills + equipment
  // The chicken's max hit is 1. We'll make it simple:
  // If player's armor > 0, they have a chance to block.
  // (Armor * 10%) chance to block the hit entirely.
  let armorChance = Math.min(80, playerStats.armor * 10); // Max 80% block chance
  
  if (damage > 0 && (Math.random() * 100 < armorChance)) {
    damage = 0; // Blocked!
  }
  
  if (damage > 0) {
    showDamageSplat('player', damage, 'damage'); // PLAYER HIT
  } else {
    showDamageSplat('player', 0, 'block'); // PLAYER HIT A 0 (or was blocked)
  }
  
  // Apply damage to player
  game.hp -= damage;
  updateHPUI(); 

  // --- 5. Check for Player Death ---
  if (game.hp <= 0) {
    game.hp = 0; 
    updateHPUI();
    runFromCombat(true); 
    handlePlayerDeath();
  }
}

function backToActions(){
  showMainScreen('hubActions');
}

function _createModal(title, contentHtml, buttons) {
  // Return a new promise that we can control
  return new Promise((resolve) => {
    // 1. Create elements
    const overlay = document.createElement('div');
    overlay.id = 'gameModalOverlay';

    const modal = document.createElement('div');
    modal.className = 'game-modal';

    const titleEl = document.createElement('div');
    titleEl.className = 'game-modal-title';
    titleEl.textContent = title;

    const contentEl = document.createElement('div');
    contentEl.className = 'game-modal-content';
    contentEl.innerHTML = contentHtml; // Use innerHTML to allow custom content

    const buttonEl = document.createElement('div');
    buttonEl.className = 'game-modal-buttons';

    // 2. Create buttons
    buttons.forEach(btnConfig => {
      const button = document.createElement('button');
      button.textContent = btnConfig.text;
      button.className = btnConfig.class || 'primary';
      if (btnConfig.style) {
        button.style.background = btnConfig.style;
      }

      // --- MODIFIED ONCLICK LOGIC ---
      button.onclick = () => {
        const inputEl = modal.querySelector('.game-modal-input');
        let resolveValue = btnConfig.value; // Default to the button's value (e.g., null for 'Cancel')

        // If an input exists AND the clicked button was NOT a cancel button (value is not null)
        if (inputEl && btnConfig.value !== null) { 
          resolveValue = inputEl.value; // Resolve with the input's value instead
        }
        
        overlay.remove();
        resolve(resolveValue); // Resolve with either the input value or the button value
      };
      // --- END MODIFICATION ---
      
      buttonEl.appendChild(button);
    });

    // 3. Assemble and append
    modal.appendChild(titleEl);
    modal.appendChild(contentEl);
    modal.appendChild(buttonEl);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Focus the first primary button or input
    const firstButton = modal.querySelector('button.primary');
    const firstInput = modal.querySelector('input');
    if (firstInput) {
      firstInput.focus();
      firstInput.select(); // Also select the text
    } else if (firstButton) {
      firstButton.focus();
    }
  });
}

/**
 * Shows a custom, in-game alert box.
 * Replaces the default browser alert().
 * @param {string} title - The title for the alert.
 * @param {string} message - The message to display.
 */
async function showGameAlert(title, message) {
  const buttons = [
    { text: 'OK', value: 'ok', class: 'primary' }
  ];
  // We await the modal helper. The promise will resolve when 'OK' is clicked.
  await _createModal(title, `<p>${message}</p>`, buttons);
}

async function showGamePrompt(title, message, defaultValue = '') {
  // HTML for the modal's content, including the input field
  const contentHtml = `
    <p>${message}</p>
    <input type="number" class="game-modal-input" value="${defaultValue}" onfocus="this.select();">
  `;
  
  // Buttons: Cancel (value: null) and OK (value: 'ok')
  const buttons = [
    { text: 'Cancel', value: null, class: 'primary', style: '#666' },
    { text: 'OK', value: 'ok', class: 'primary' } // 'ok' is a placeholder, _createModal will grab the input value
  ];

  // Our upgraded _createModal will return the input's value if 'OK' is clicked,
  // or null if 'Cancel' is clicked.
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}

/**
 * Shows a custom, in-game confirmation box (Yes/No).
 * Replaces the default browser confirm().
 * @param {string} title - The title for the confirm box.
 * @param {string} message - The question to ask.
 * @returns {Promise<boolean>} - Resolves true if "Yes" was clicked, false if "No"/"Cancel".
 */
async function showGameConfirm(title, message) {
  const contentHtml = `<p>${message}</p>`;
  
  const buttons = [
    { text: 'No', value: false, class: 'primary', style: '#666' },
    { text: 'Yes', value: true, class: 'primary' } // 'Yes' resolves to true
  ];

  // This will return `true` or `false`
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}


let draggedBankItem = null; // Stores data for bank drag-and-drop

/**
 * Renders the Bank grid UI
 */
function renderBankGrid() {
  const grid = document.getElementById('bankGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  for(let i = 0; i < game.bankCapacity; i++) {
    const slotData = game.bank[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    slot.addEventListener('dragover', handleBankDragOver);
    slot.addEventListener('dragleave', (e) => e.target.closest('.inv-slot').classList.remove('drag-over'));
    slot.addEventListener('drop', handleBankDrop);
    
    if(slotData) {
      const item = slotData;
      
      slot.draggable = true; 
      slot.addEventListener('dragstart', (e) => handleBankWithdrawDragStart(e, item, i));
      slot.addEventListener('dragend', () => {
        draggedBankItem = null;
        game.isDragging = false; 
        const draggingEl = document.querySelector('.inv-slot.dragging');
        if (draggingEl) draggingEl.classList.remove('dragging');
      });
      
      slot.onclick = () => withdrawItem(i); 

      const img = document.createElement('img');
              let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
              if (item.name === 'Copper Bar') imgName = 'copperbar';
              else if (item.name === 'Copper Chestplate') imgName = 'copperchestplate';
              else if (item.name === 'Copper Shortsword') imgName = 'coppershortsword';
              else if (item.name === 'Copper Helmet') imgName = 'copperhelmet';
              else if (item.name === 'Copper Boots') imgName = 'copperboots';
              else if (item.name === 'Raw Chicken') imgName = 'rawchicken';
              else if (item.name === 'Cooked Chicken') imgName = 'cookedchicken';
              else if (item.name === 'Burnt Chicken') imgName = 'burntchicken';
              
              // +++ NEW COOKED FISH IMAGES +++
              else if (item.name === 'Cooked Herring') imgName = 'cookedherring';
              else if (item.name === 'Burnt Herring') imgName = 'burntherring';
              else if (item.name === 'Cooked Trout') imgName = 'cookedtrout';
              else if (item.name === 'Burnt Trout') imgName = 'burnttrout';
              else if (item.name === 'Cooked Salmon') imgName = 'cookedsalmon';
              else if (item.name === 'Burnt Salmon') imgName = 'burntsalmon';
              // +++ END NEW +++

              else if (item.name === 'Coal Ore') imgName = 'coalore';
              else if (item.name === 'Iron Ore') imgName = 'ironore';
              else if (item.name === 'Iron Bar') imgName = 'ironbar';
              else if (item.name === 'Iron Helmet') imgName = 'ironhelmet';
              else if (item.name === 'Iron Chestplate') imgName = 'ironchestplate';
              else if (item.name === 'Iron Boots') imgName = 'ironboots';
              else if (item.name === 'Iron Shortsword') imgName = 'ironshortsword';
              else if (item.name === 'Copper Platelegs') imgName = 'copperplatelegs'; // +++ NEW +++
              else if (item.name === 'Iron Platelegs') imgName = 'ironplatelegs'; // +++ NEW +++
              else if (item.name === 'Softwood') imgName = 'softwood';
              else if (item.name === 'Oak') imgName = 'oak';
              else if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe'; // +++ NEW +++
              else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe'; // +++ NEW +++
              else if (item.name === 'Copper Pickaxe') imgName = 'copperpickaxe'; // +++ NEW +++
              else if (item.name === 'Copper Axe') imgName = 'copperaxe'; // +++ NEW +++
              else if (item.name === 'Iron Pickaxe') imgName = 'ironpickaxe'; // +++ NEW +++
              else if (item.name === 'Iron Axe') imgName = 'ironaxe'; // +++ NEW +++
              else if (item.name === 'Feather') imgName = 'feather'; // +++ NEW +++
              else if (item.name === 'Arrow Shaft') imgName = 'arrowshaft'; // +++ NEW +++
              else if (item.name === 'Copper Arrow Tip') imgName = 'copperarrowtip'; // +++ NEW +++
              else if (item.name === 'Unbound Arrow') imgName = 'unboundarrow'; // +++ NEW +++
              else if (item.name === 'Copper Arrow') imgName = 'copperarrow'; // +++ NEW +++
              else if (item.name === 'Silk') imgName = 'silk'; // +++ NEW +++
              // --- THIS IS THE MISSING BLOCK ---
              else if (item.name === 'Bow String') {
                  imgName = 'bowstring';
              } else if (item.name === 'Unstrung Softwood Bow') {
                  imgName = 'unstrungsoftwoodbow';
              } else if (item.name === 'Unstrung Oak Bow') {
                  imgName = 'unstrungoakbow';
              } else if (item.name === 'Softwood Bow') {
                  imgName = 'softwoodbow';
              } else if (item.name === 'Oak Bow') {
                  imgName = 'oakbow';
              }

// +++ NEW LEATHER +++
              else if (item.name === 'Cow Hide') {
                  imgName = 'cowhide';
              } else if (item.name === 'Leather') {
                  imgName = 'leather';
              } else if (item.name === 'Leather Hood') {
                  imgName = 'leatherhood';
              } else if (item.name === 'Leather Body') {
                  imgName = 'leatherarmor';
              } else if (item.name === 'Leather Chaps') {
                  imgName = 'leatherpants';
              } else if (item.name === 'Leather Boots') {
                  imgName = 'leatherboots';
              }

              // +++ NEW FISHING ITEMS +++
              else if (item.name === 'Herring') {
                  imgName = 'herring';
              } else if (item.name === 'Trout') {
                  imgName = 'trout';
              } else if (item.name === 'Salmon') {
                  imgName = 'salmon';
              } else if (item.name === 'Fishing Pole') {
                  imgName = 'fishingpole';
              } else if (item.name === 'Fishing Bait') {
                  imgName = 'fishingbait';
              }

              // --- END OF FIX ---
              img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      const stats = ITEM_STATS[item.name];
      if (stats) {
        if (stats.damage) itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
        <div>Amount: ${item.qty.toLocaleString()}</div>
        ${itemStats}
        <div style="color:#ffaaaa; margin-top: 5px;">Click or Drag to withdraw...</div>
      `;
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
    }
    grid.appendChild(slot);
  }
}



/**
 * Updates the gold values on the bank screen
 */
function updateBankGoldUI() {
  setText('bankPlayerGold', formatAmount(game.gold));
  setText('bankStoredGold', formatAmount(game.bankGold));
}

/**
 * Main function to open the Bank UI
 */
function openBank() {
  showMainScreen('hubBank');
}
// --- Bank Drag-and-Drop Handlers ---

function handleBankDragStart(e, item, fromIndex) {
  // Store item data for the drop
  draggedBankItem = { item, fromIndex };
  e.dataTransfer.effectAllowed = 'move';
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}

function handleBankDragOver(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  if (targetSlot) {
    targetSlot.classList.add('drag-over');
  }
}

async function handleBankDrop(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  
  if (targetSlot) {
    targetSlot.classList.remove('drag-over');
  }
  
  // Clean up *any* dragging slot, from either grid
  const draggingInvEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
  if (draggingInvEl) draggingInvEl.classList.remove('dragging');
  const draggingBankEl = document.querySelector('#bankGrid .inv-slot.dragging');
  if (draggingBankEl) draggingBankEl.classList.remove('dragging');

  if (!targetSlot || !draggedBankItem) {
     draggedBankItem = null;
     return;
  }

  const toIndex = parseInt(targetSlot.dataset.slotIndex);
  const fromIndex = draggedBankItem.fromIndex;

  // --- NEW LOGIC: Check drag source ---
  if (draggedBankItem.source === 'bank') {
    // === BANK -> BANK internal move ===
    
    if (fromIndex !== toIndex) {
      // --- Get the item data *before* the prompt ---
      const dragItemBeforePrompt = game.bank[fromIndex];
      const dropItem = game.bank[toIndex];

      // --- MODIFIED: Handle Shift-Click to move specific amount ---
      if (e.shiftKey && dragItemBeforePrompt) { 
        
        if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
          await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
        } else {
          const input = await showGamePrompt(
            `Move ${dragItemBeforePrompt.name}`, 
            `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
            "" 
          );

          // --- THIS IS THE FIX ---
          // After the prompt (await) is done, we re-check the bank
            
          if (input === null) {
            // User cancelled
            const originalSlotEl = document.querySelector(`#bankGrid .inv-slot[data-slot-index="${fromIndex}"]`);
            if (originalSlotEl) {
              originalSlotEl.classList.remove('dragging');
            }
          } else {
            // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
            const itemAfterPrompt = game.bank[fromIndex]; // Check game.bank
            
            // Check if the item was consumed or changed
            if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
              // The item was consumed! Abort.
              draggedBankItem = null;
              game.isDragging = false;
              return; // Safely exit
            }
            // --- END EXPLOIT FIX ---
            
            const splitAmount = parseInt(input);

            if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid */ }
            
            // Use the most up-to-date quantity
            else if (splitAmount > itemAfterPrompt.qty) { 
              await showGameAlert("Invalid Amount", "You don't have that many.");
            } 
            
            else if (splitAmount === itemAfterPrompt.qty) { 
              // Full stack move
              if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                dropItem.qty += itemAfterPrompt.qty;
                game.bank[fromIndex] = null;
              } else {
                game.bank[fromIndex] = dropItem;
                game.bank[toIndex] = itemAfterPrompt;
              }
              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
            
            else {
              // This is a valid SPLIT
              if (dropItem) { 
                dropItem.qty += splitAmount;
              } else { 
                game.bank[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
              }
              itemAfterPrompt.qty -= splitAmount; // Use the validated item

              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
          }
        }
      } else {
        // --- BANK SWAP/STACK (No Shift) ---
        // We must re-get the dragItem in case it was consumed
        const dragItem = game.bank[fromIndex]; 
        if (dragItem && dropItem && dragItem.name === dropItem.name) {
          dropItem.qty += dragItem.qty;
          game.bank[fromIndex] = null;
        } else {
          game.bank[fromIndex] = dropItem;
          game.bank[toIndex] = dragItem;
        }
        renderBankGrid();
        if (typeof window.savePlayerData === 'function') savePlayerData();
      }
    }

  } else {
    // === INVENTORY -> BANK deposit (Original Logic) ===
    const depositSuccess = await depositItem(draggedBankItem.item, fromIndex, toIndex);
    
    if (!depositSuccess) {
      // User cancelled deposit, remove 'dragging' class from INVENTORY slot
      const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
      if (originalSlotEl) {
        originalSlotEl.classList.remove('dragging');
      }
    }
  }
  
  draggedBankItem = null;
}

// --- Bank Core Logic ---

function handleBankWithdrawDragStart(e, item, fromBankIndex) {
  // Store item data and the *source* as 'bank'
  draggedBankItem = { item, fromIndex: fromBankIndex, source: 'bank' };
  e.dataTransfer.effectAllowed = 'move';
  game.isDragging = true;
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}


async function depositItem(item, fromInventoryIndex, toBankIndex) {
  if (!item) return;

  const bankSlot = game.bank[toBankIndex];
  
  if (bankSlot && bankSlot.name !== item.name) {
    await showGameAlert("Invalid Slot", "You can't stack different items. Drop on an empty slot or a stack of the same item."); // Replaced alert
    return;
  }

  let qtyToDeposit = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Deposit ${item.name}`,
      `How many ${item.name} do you want to deposit? (You have: ${item.qty})`,
      item.qty
    );
    if (input === null) return false;
    qtyToDeposit = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToDeposit) || qtyToDeposit <= 0) return;
  if (qtyToDeposit > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to deposit."); // Replaced alert
    return;
  }

  game.inventory[fromInventoryIndex].qty -= qtyToDeposit;
  if (game.inventory[fromInventoryIndex].qty <= 0) {
    game.inventory[fromInventoryIndex] = null;
  }

  if (bankSlot) {
    bankSlot.qty += qtyToDeposit;
  } else {
    game.bank[toBankIndex] = { name: item.name, qty: qtyToDeposit };
  }

  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
  return true;
}

async function withdrawItem(fromBankIndex) {
  const item = game.bank[fromBankIndex];
  if (!item) return;

  let qtyToWithdraw = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${item.name}`,
      `How many ${item.name} do you want to withdraw? (Bank has: ${item.qty})`,
      item.qty
    );
    if (input === null) return;
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0) return;
  if (qtyToWithdraw > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to withdraw."); // Replaced alert
    return;
  }
  
  const itemToAdd = { name: item.name, qty: qtyToWithdraw };
  addItem(itemToAdd.name, itemToAdd.qty); 
  
  game.bank[fromBankIndex].qty -= qtyToWithdraw;
  if (game.bank[fromBankIndex].qty <= 0) {
    game.bank[fromBankIndex] = null;
  }
  
  renderBankGrid();
  renderInventoryGrid(); 
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function depositGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.gold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold to deposit."); // <-- USE 'await showGameAlert'
    return;
  }

  game.gold -= amount;
  game.bankGold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function withdrawGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.bankGold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold in your bank."); // <-- USE 'await showGameAlert'
    return;
  }

  game.bankGold -= amount;
  game.gold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function dragWithdrawItem(fromBankIndex, toInventoryIndex) {
  const bankItem = game.bank[fromBankIndex];
  const inventorySlotItem = game.inventory[toInventoryIndex];

  if (!bankItem) return;

  let qtyToWithdraw = bankItem.qty;

  if (bankItem.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${bankItem.name}`,
      `How many ${bankItem.name} do you want to withdraw? (Bank has: ${bankItem.qty})`,
      bankItem.qty
    );
    if (input === null) return; 
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0 || qtyToWithdraw > bankItem.qty) {
    await showGameAlert("Invalid Amount", "Invalid or excessive amount entered."); // Replaced alert
    return;
  }

  if (inventorySlotItem && inventorySlotItem.name === bankItem.name) {
    inventorySlotItem.qty += qtyToWithdraw;
    bankItem.qty -= qtyToWithdraw;
    if (bankItem.qty <= 0) {
      game.bank[fromBankIndex] = null; 
    }

  } else if (inventorySlotItem) {
    if (qtyToWithdraw < bankItem.qty) {
      await showGameAlert("Invalid Action", "You must withdraw the full stack to swap items, or drop onto an empty inventory slot."); // Replaced alert
      return;
    }
    
    game.bank[fromBankIndex] = inventorySlotItem;
    game.inventory[toInventoryIndex] = bankItem;

  } else {
    if (qtyToWithdraw === bankItem.qty) {
        game.inventory[toInventoryIndex] = bankItem;
        game.bank[fromBankIndex] = null; 
    } else {
        game.inventory[toInventoryIndex] = { name: bankItem.name, qty: qtyToWithdraw };
        bankItem.qty -= qtyToWithdraw;
    }
  }
  
  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}
  
// =================================================================
// --- END NEW BANK FUNCTIONS ---
// =================================================================

async function buyShopItem(itemName, price) {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This tab is not active. Please take control to perform actions.");
    return;
  }
  // Check if they can afford at least one
  if (game.gold < price) {
    await showGameAlert("Not Enough Gold", `You need ${price} Gold to buy that.`);
    return;
  }

  // --- NEW: Ask for quantity ---
  const input = await showGamePrompt(
    `Buy ${itemName}`, 
    `How many ${itemName} do you want to buy? (Price: ${price}ea)`, 
    1 // Default value
  );

  if (input === null) return; // User cancelled
  const qtyToBuy = parseInt(input);

  if (isNaN(qtyToBuy) || qtyToBuy <= 0) {
    return; // Invalid number
  }
  // --- END NEW ---

  const totalCost = price * qtyToBuy;
  
  // Check if they have enough gold for the total purchase
  if (game.gold < totalCost) {
    await showGameAlert("Not Enough Gold", `You need ${totalCost} Gold to buy ${qtyToBuy} ${itemName}.`);
    return;
  }

  // Check for inventory space (find existing stack OR an empty slot)
  // Your addItem function is smart, so we just need to make sure
  // it *can* add (i.e., not full with no matching stacks).
  const stackIndex = game.inventory.findIndex(slot => slot && slot.name === itemName);
  const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
  
  if (stackIndex === -1 && emptySlotIndex === -1) {
     await showGameAlert("Inventory Full", "You have no space in your inventory to buy this.");
     return;
  }
  
  addGold(-totalCost);
  addItem(itemName, qtyToBuy); // Use the new quantity
  await showGameAlert("Purchase Complete", `You bought ${qtyToBuy} ${itemName} for ${totalCost} Gold.`);
  
  // No need to render, addItem and addGold already do.
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}

function openShop() {
  showMainScreen('hubShop');
}

function resetGameState() {
  stopMining(); 
  stopBlacksmithing();
  stopFletching(); // +++ NEW +++
  stopCraftingBowString(); // +++ NEW (using a specific stop func name) +++
  stopFishing(); // +++ NEW +++
  
  // +++ NEW: Add combat stop +++
  if (game.inCombat) {
    runFromCombat(false); // Stop combat loops
  }
  // +++ END NEW +++

  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  game.gold = 100; 
  // +++ NEW +++
  game.bank = new Array(game.bankCapacity).fill(null);
  game.bankGold = 0;
  game.equipment = { 
    necklace: null, helmet: null, cape: null, 
    weapon: null, chest: null, shield: null, 
    ring1: null, legs: null, ring2: null, 
    arrows: null, boots: null 
  };
  // +++ END NEW +++
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.blacksmith = { level: 1, xp: 0, totalXP: 0 };
  game.cooking = { level: 1, xp: 0, totalXP: 0 };
  game.woodcutting = { level: 1, xp: 0, totalXP: 0 };
  game.fletching = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  game.fishing = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  
  // +++ NEW SKILLS +++
  game.crafting = { level: 1, xp: 0, totalXP: 0 };
  game.ranged = { level: 1, xp: 0, totalXP: 0 };
  
  // +++ ADD THESE 4 MISSING LINES +++
  game.attack = { level: 1, xp: 0, totalXP: 0 };
  game.strength = { level: 1, xp: 0, totalXP: 0 };
  game.defence = { level: 1, xp: 0, totalXP: 0 };
  game.vitality = { level: 1, xp: 0, totalXP: 0 };
  // +++ END OF FIX +++

  game.miningActive = false;
  game.blacksmithingActive = false; // +++ NEW +++
  game.cookingActive = false;
  game.woodcuttingActive = false; // +++ NEW +++
  game.fletchingActive = false; // +++ NEW +++
  game.craftingActive = false; // +++ NEW +++
  game.fishingActive = false; // +++ NEW +++
  game.shopOpen = false;
  game.isAdmin = false;
  
  // +++ NEW: Reset session state +++
  game.isSessionActive = false;
  game.isDragging = false;
  if (typeof window.stopSessionHeartbeat === 'function') {
      window.stopSessionHeartbeat();
  }
  
  if (game.progressFrame) {
    cancelAnimationFrame(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  renderEquipment(); // <-- ADD THIS
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('inventory'); 
  }
}

/**
 * Saves the current game.settings to localStorage
 */
function saveSettings() {
  localStorage.setItem('rusticGameSettings', JSON.stringify(game.settings));
}

/**
 * Loads settings from localStorage into game.settings
 */
function loadSettings() {
  const savedJSON = localStorage.getItem('rusticGameSettings');
  if (savedJSON) {
    const saved = JSON.parse(savedJSON);

    // --- NEW: Migration logic ---
    // Check for old properties
    if (typeof saved.volume === 'number') {
      game.settings.sfxVolume = saved.volume;
    }
    if (typeof saved.isMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isMuted;
    }

    // Load new properties if they exist
    if (typeof saved.sfxVolume === 'number') {
      game.settings.sfxVolume = saved.sfxVolume;
    }
    if (typeof saved.isSfxMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isSfxMuted;
    }
    if (typeof saved.musicVolume === 'number') {
      game.settings.musicVolume = saved.musicVolume;
    }
    if (typeof saved.isMusicMuted === 'boolean') {
      game.settings.isMusicMuted = saved.isMusicMuted;
    }
    // --- END Migration ---
  }

  applySettingsUI();

  // --- NEW: Apply music settings to player ---
  // This ensures music volume is correct on load
  if (typeof updateMusicPlayerState === 'function') {
    updateMusicPlayerState();
  }
}

/**
 * Updates the UI elements in the settings modal
 */
function applySettingsUI() {
  const sfxSlider = document.getElementById('sfxVolumeSlider');
  const sfxMute = document.getElementById('sfxMuteBtn');
  const musicSlider = document.getElementById('musicVolumeSlider');
  const musicMute = document.getElementById('musicMuteBtn');

  // --- SFX Controls ---
  if (sfxSlider) {
    sfxSlider.value = game.settings.sfxVolume;
    sfxSlider.disabled = game.settings.isSfxMuted;
  }
  if (sfxMute) {
    sfxMute.textContent = game.settings.isSfxMuted ? 'Unmute' : 'Mute';
    if (game.settings.isSfxMuted) {
      sfxMute.style.background = 'var(--gold)';
      sfxMute.style.color = '#000';
    } else {
      sfxMute.style.background = 'var(--accent)';
      sfxMute.style.color = '#fff';
    }
  }

  // --- Music Controls ---
  if (musicSlider) {
    musicSlider.value = game.settings.musicVolume;
    musicSlider.disabled = game.settings.isMusicMuted;
  }
  if (musicMute) {
    musicMute.textContent = game.settings.isMusicMuted ? 'Unmute' : 'Mute';
    if (game.settings.isMusicMuted) {
      musicMute.style.background = 'var(--gold)';
      musicMute.style.color = '#000';
    } else {
      musicMute.style.background = 'var(--accent)';
      musicMute.style.color = '#fff';
    }
  }
}

/**
 * Opens the settings modal
 */
function openSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) {
    applySettingsUI(); // Ensure UI is in sync when opening
    modal.style.display = 'flex';
  }
}

/**
 * Closes the settings modal
 */
function closeSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) modal.style.display = 'none';
}

/**
 * The new global sound player that respects settings
 * @param {string} src - The path to the sound file
 */
// +++ NEW: Hub Screen Toggler Function +++
// +++ ADDED hubCrafting, hubFishingAreas, hubOcean, hubRiver +++
const hubScreenIds = ['hubActions', 'hubMine', 'hubBlacksmith', 'hubFletching', 'hubCrafting', 'hubForest', 'hubKitchen', 'hubCombat', 'hubFarm', 'hubCave', 'hubShop', 'hubBank', 'hubDynamic', 'hubFishingAreas', 'hubOcean', 'hubRiver'];
function showMainScreen(screenIdToShow) {
  // Stop all skilling actions
  stopMining();
  stopBlacksmithing();
  stopCookingChicken();
  stopWoodcutting();
  stopFletching(); // +++ NEW +++
  stopCraftingBowString(); // +++ NEW +++
  stopFishing(); // +++ NEW +++
  game.shopOpen = false;
  hideTooltip();

  // Get the wrapper and clear dynamic content
  const wrapper = document.getElementById('mainContentWrapper');
  const dynamicHub = document.getElementById('hubDynamic');
  
  // --- We removed the 'if' block that was clearing the HTML ---

  // Toggle the screens
  hubScreenIds.forEach(id => {
    const screen = document.getElementById(id);
    if (screen) {
      if (id === screenIdToShow) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    }
  });

  // Special case: if we're showing the blacksmith hub, render its items
  if (screenIdToShow === 'hubBlacksmith') {
    // --- FIX: Use the last saved tab ---
    const lastTab = game.lastSmithingTab || 'copper';
    renderSmithingItems(lastTab);
    // Also set the active button class
    if (lastTab === 'iron') {
      document.getElementById('smithIronTab').classList.add('active');
      document.getElementById('smithCopperTab').classList.remove('active');
    } else {
      document.getElementById('smithCopperTab').classList.add('active');
      document.getElementById('smithIronTab').classList.remove('active');
    }
    // --- END FIX ---
  }
  
  // +++ NEW: Special case for crafting hub +++
  if (screenIdToShow === 'hubCrafting') {
    renderCraftingItems();
  }
  
  // Special case: if we're showing the mine hub, apply level locks
  if (screenIdToShow === 'hubMine') {
    const miningLvl = game.mining.level;
    document.getElementById('ironVeinBtn').classList.toggle('locked-item', miningLvl < IRON_MINE_LVL);
    document.getElementById('coalVeinBtn').classList.toggle('locked-item', miningLvl < COAL_MINE_LVL);
  }
  
  // Special case: if we're showing the forest hub, apply level locks
  if (screenIdToShow === 'hubForest') {
    const woodcuttingLvl = game.woodcutting.level;
    document.getElementById('oakTreeBtn').classList.toggle('locked-item', woodcuttingLvl < OAK_TREE_LVL);
  }

  // +++ NEW: Special case for hubRiver level locks +++
  if (screenIdToShow === 'hubRiver') {
    const fishingLvl = game.fishing.level;
    document.getElementById('fishTroutBtn').classList.toggle('locked-item', fishingLvl < TROUT_FISH_LVL);
    document.getElementById('fishSalmonBtn').classList.toggle('locked-item', fishingLvl < SALMON_FISH_LVL);
  }
  
  // Special case: if we're showing the shop
  if (screenIdToShow === 'hubShop') {
    game.shopOpen = true;
  }
  
  // Special case: if we're showing the bank
  if (screenIdToShow === 'hubBank') {
    renderBankGrid();
    updateBankGoldUI();
  }
}

function playGlobalSound(src) {
  if (game.settings.isSfxMuted) return; // Use new sfxMuted setting
  try {
    const sound = new Audio(src);
    sound.volume = game.settings.sfxVolume; // Use new sfxVolume setting
    sound.play();
  } catch (e) {
    console.warn("Could not play sound", src, e);
  }
}

/**
 * Renders the Shop grid UI
 */
function renderShopGrid() {
  const grid = document.getElementById('shopGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  for(let i = 0; i < SHOP_INVENTORY.length; i++) {
    const item = SHOP_INVENTORY[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    
    if(item) {
      // slot.draggable = true; // <-- DISABLED
      // slot.addEventListener('dragstart', (e) => handleShopDragStart(e, item)); // <-- DISABLED
      // slot.addEventListener('dragend', () => { // <-- DISABLED
      //   draggedShopItem = null;
      //   game.isDragging = false; 
      //   const draggingEl = document.querySelector('.inv-slot.dragging');
      //   if (draggingEl) draggingEl.classList.remove('dragging');
      // }); // <-- DISABLED
      
      slot.onclick = () => buyShopItem(item.name, item.price); 

      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe';
      else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe';
      else if (item.name === 'Fishing Pole') imgName = 'fishingpole';
      else if (item.name === 'Fishing Bait') imgName = 'fishingbait';
      // Add more image name fixes here if needed
      
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; };
      slot.appendChild(img);
      
      // Don't show an amount, just the item

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
        <div style="color:#fff;">Price: ${item.price} Gold</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to buy...</div>
      `; // <-- UPDATED TOOLTIP
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
    }
    grid.appendChild(slot);
  }
}

// --- END: Settings Functions ---


// --- MODIFIED: Added isDragging logic ---
document.addEventListener('DOMContentLoaded', ()=>{
  
  // --- NEW: Stats Panel Listeners ---
  const toggleStatsBtn = document.getElementById('toggleStatsBtn');
  const closeStatsBtn = document.getElementById('closeStatsBtn');
  const statsPanel = document.getElementById('statsPanel');
  const statsPanelHeader = document.getElementById('statsPanelHeader');

  if (toggleStatsBtn) {
    toggleStatsBtn.onclick = () => {
      if (statsPanel) {
        // We also run renderEquipment to make sure stats are up-to-date when opening
        if (typeof renderEquipment === 'function') {
            renderEquipment();
        }
        // --- THIS IS THE FIX ---
        statsPanel.style.visibility = (statsPanel.style.visibility === 'visible') ? 'hidden' : 'visible';
      }
    };
  }
  if (closeStatsBtn) {
    closeStatsBtn.onclick = () => {
      if (statsPanel) statsPanel.style.visibility = 'hidden'; // <-- THIS IS THE FIX
    };
  }

  // --- NEW: Draggable Panel Logic ---
  

  if (statsPanelHeader) {
    statsPanelHeader.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // Only drag with left click
      isDraggingPanel = true;

      // --- THIS IS THE FIX ---
      
      // 1. Get the panel's VISUAL position on screen
      const rect = statsPanel.getBoundingClientRect();
      
      // 2. Calculate the mouse's offset from the panel's top-left corner
      panelOffsetX = e.clientX - rect.left;
      panelOffsetY = e.clientY - rect.top;
      
      // 3. ATOMICALLY (all at once):
      //    a) Clear the transform that was centering it
      //    b) Set the top/left to the exact pixel values it was just at
      statsPanel.style.transform = ''; 
      statsPanel.style.top = rect.top + 'px';
      statsPanel.style.left = rect.left + 'px';
      
      e.preventDefault();
    });
  }

  document.addEventListener('mousemove', (e) => {
    if (!isDraggingPanel) return;
    e.preventDefault(); 

    // The 'isFirstMove' logic is gone.
    // We just update the position based on the new mouse coordinates
    // and the offset we saved on mousedown.
    statsPanel.style.left = (e.clientX - panelOffsetX) + 'px';
    statsPanel.style.top = (e.clientY - panelOffsetY) + 'px';
  });

  document.addEventListener('mouseup', (e) => {
    if (isDraggingPanel) {
        isDraggingPanel = false;
        e.preventDefault();
    }
  });
  // --- END: Stats Panel Listeners & Draggable Logic ---
  
  // +++ ADD THIS ENTIRE BLOCK OF LISTENERS +++
  
  // --- Hub Actions (Main Hub) ---
  document.getElementById('minesActionIcon').onclick = openMineHub;
  document.getElementById('fishingActionIcon').onclick = openFishingHub; // +++ NEW +++
  document.getElementById('forestActionIcon').onclick = openForestHub;
  document.getElementById('blacksmithActionIcon').onclick = openBlacksmithHub;
  document.getElementById('kitchenActionIcon').onclick = openKitchenHub;
  document.getElementById('combatActionIcon').onclick = openCombatHub;
  document.getElementById('shopActionIcon').onclick = openShop;
  document.getElementById('bankActionIcon').onclick = openBank;
  document.getElementById('fletchingActionIcon').onclick = openFletchingHub; // +++ NEW +++
  document.getElementById('craftingActionIcon').onclick = openCraftingHub; // +++ NEW +++
  
  // --- Hub Crafting Listeners ---
  document.getElementById('hubCrafting_ReturnBtn').onclick = backToActions; // +++ NEW +++
  
  // --- Hub Mine Listeners ---
  document.getElementById('copperVeinBtn').onclick = openCopperMine;
  document.getElementById('ironVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= IRON_MINE_LVL) {
        openIronMine();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('coalVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= COAL_MINE_LVL) {
        openCoalMine();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('hubMine_ReturnBtn').onclick = backToActions;
  
  // --- Hub Blacksmith Listeners ---
  document.getElementById('smithCopperTab').onclick = () => {
    document.getElementById('smithCopperTab').classList.add('active');
    document.getElementById('smithIronTab').classList.remove('active');
    game.lastSmithingTab = 'copper'; // <-- ADD THIS LINE
    renderSmithingItems('copper');
  };
  document.getElementById('smithIronTab').onclick = () => {
    document.getElementById('smithIronTab').classList.add('active');
    document.getElementById('smithCopperTab').classList.remove('active');
    game.lastSmithingTab = 'iron'; // <-- ADD THIS LINE
    renderSmithingItems('iron');
  };
  document.getElementById('hubBlacksmith_ReturnBtn').onclick = backToActions;

  // --- Hub Fletching Listeners ---
  document.getElementById('hubFletching_ReturnBtn').onclick = backToActions;

  // --- Hub Forest Listeners ---
  document.getElementById('softwoodTreeBtn').onclick = openSoftwoodTree;
  document.getElementById('oakTreeBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.woodcutting.level >= OAK_TREE_LVL) {
        openOakTree();
    } else {
        // Do nothing if locked, the CSS class handles the visuals.
    }
  };
  document.getElementById('hubForest_ReturnBtn').onclick = backToActions;

  // --- Hub Kitchen Listeners ---
  document.getElementById('cookChickenBtn').onclick = openCookChicken;
  document.getElementById('cookHerringBtn').onclick = openCookHerring; // +++ NEW +++
  document.getElementById('cookTroutBtn').onclick = () => { // +++ NEW +++
    if (game.cooking.level >= COOK_TROUT_LVL) {
      openCookTrout();
    } else {
      document.getElementById('cookTroutBtn').classList.add('locked-item');
    }
  };
  document.getElementById('cookSalmonBtn').onclick = () => { // +++ NEW +++
    if (game.cooking.level >= COOK_SALMON_LVL) {
      openCookSalmon();
    } else {
      document.getElementById('cookSalmonBtn').classList.add('locked-item');
    }
  };
  document.getElementById('hubKitchen_ReturnBtn').onclick = backToActions;

  // --- Hub Combat Listeners ---
  document.getElementById('farmAreaBtn').onclick = openFarmCombatArea;
  document.getElementById('caveAreaBtn').onclick = openCaveCombatArea; // +++ NEW +++
  document.getElementById('hubCombat_ReturnBtn').onclick = backToActions;
  
  // --- Hub Fishing Listeners ---
  document.getElementById('oceanAreaBtn').onclick = openOceanFishingArea;
  document.getElementById('riverAreaBtn').onclick = openRiverFishingArea;
  document.getElementById('hubFishingAreas_ReturnBtn').onclick = backToActions;
  
  // --- Hub Ocean/River Return Listeners ---
  document.getElementById('hubOcean_ReturnBtn').onclick = openFishingHub;
  document.getElementById('hubRiver_ReturnBtn').onclick = openFishingHub;
  
  // --- Hub Farm/Cave Return Listeners ---
  document.getElementById('hubFarm_ReturnBtn').onclick = openCombatHub; // +++ NEW +++
  document.getElementById('hubCave_ReturnBtn').onclick = openCombatHub; // +++ NEW +++

  // --- Hub Fishing Level Locks (in Listeners) ---
  document.getElementById('fishTroutBtn').onclick = () => {
    if (game.fishing.level >= TROUT_FISH_LVL) openFishTrout();
  };
  document.getElementById('fishSalmonBtn').onclick = () => {
    if (game.fishing.level >= SALMON_FISH_LVL) openFishSalmon();
  };
  // CSS class is now applied by showMainScreen('hubRiver')

  // --- Hub Shop Listeners ---
  document.getElementById('hubShop_ReturnBtn').onclick = backToActions;
  
  // --- Hub Bank Listeners ---
  document.getElementById('bankDepositGoldBtn').onclick = depositGold;
  document.getElementById('bankWithdrawGoldBtn').onclick = withdrawGold;
  document.getElementById('hubBank_ReturnBtn').onclick = backToActions;

  // --- Tooltips for Hub Icons ---
  document.getElementById('minesActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Mine</div>');
  document.getElementById('minesActionIcon').onmouseleave = hideTooltip;
  document.getElementById('forestActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Forest</div>');
  document.getElementById('forestActionIcon').onmouseleave = hideTooltip;
  document.getElementById('blacksmithActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Blacksmith</div>');
  document.getElementById('blacksmithActionIcon').onmouseleave = hideTooltip;
  document.getElementById('kitchenActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Kitchen</div>');
  document.getElementById('kitchenActionIcon').onmouseleave = hideTooltip;
  document.getElementById('combatActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Combat Areas</div>');
  document.getElementById('combatActionIcon').onmouseleave = hideTooltip;
  document.getElementById('shopActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
  document.getElementById('shopActionIcon').onmouseleave = hideTooltip;
  document.getElementById('bankActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Bank</div>');
  document.getElementById('bankActionIcon').onmouseleave = hideTooltip;
  document.getElementById('fletchingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Fletching Bench</div>'); // +++ NEW +++
  document.getElementById('fletchingActionIcon').onmouseleave = hideTooltip; // +++ NEW +++
  document.getElementById('craftingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Crafting Bench</div>'); // +++ NEW +++
  document.getElementById('craftingActionIcon').onmouseleave = hideTooltip; // +++ NEW +++
  document.getElementById('fishingActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Fishing Areas</div>'); // +++ NEW +++
  document.getElementById('fishingActionIcon').onmouseleave = hideTooltip; // +++ NEW +++
  
  // --- Tooltips for Hub Mine ---
  document.getElementById('copperVeinBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Copper Vein</div>Requires Mining Lvl: 1');
  document.getElementById('copperVeinBtn').onmouseleave = hideTooltip;
  document.getElementById('ironVeinBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Iron Vein</div>Requires Mining Lvl: ${IRON_MINE_LVL}`;
    showTooltip(e, tt);
  };
  document.getElementById('ironVeinBtn').onmouseleave = hideTooltip;
  document.getElementById('coalVeinBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Coal Vein</div>Requires Mining Lvl: ${COAL_MINE_LVL}`;
    showTooltip(e, tt);
  };
  document.getElementById('coalVeinBtn').onmouseleave = hideTooltip;
  
  // --- Tooltips for Hub Forest ---
  document.getElementById('softwoodTreeBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Softwood Tree</div>Requires Woodcutting Lvl: ${SOFTWOOD_TREE_LVL}`);
  document.getElementById('softwoodTreeBtn').onmouseleave = hideTooltip;
  document.getElementById('oakTreeBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Oak Tree</div>Requires Woodcutting Lvl: ${OAK_TREE_LVL}`);
  document.getElementById('oakTreeBtn').onmouseleave = hideTooltip;

  // --- Tooltips for Hub Kitchen ---
  document.getElementById('cookChickenBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cook Chicken</div>Requires: 1 Raw Chicken');
  document.getElementById('cookChickenBtn').onmouseleave = hideTooltip;
  
  document.getElementById('cookHerringBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cook Herring</div>Requires: 1 Herring<br>Cooking Lvl: ${COOK_HERRING_LVL}`);
  document.getElementById('cookHerringBtn').onmouseleave = hideTooltip;
  
  document.getElementById('cookTroutBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cook Trout</div>Requires: 1 Trout<br>Cooking Lvl: ${COOK_TROUT_LVL}`;
    showTooltip(e, tt);
    document.getElementById('cookTroutBtn').classList.toggle('locked-item', game.cooking.level < COOK_TROUT_LVL);
  };
  document.getElementById('cookTroutBtn').onmouseleave = hideTooltip;
  
  document.getElementById('cookSalmonBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Cook Salmon</div>Requires: 1 Salmon<br>Cooking Lvl: ${COOK_SALMON_LVL}`;
    showTooltip(e, tt);
    document.getElementById('cookSalmonBtn').classList.toggle('locked-item', game.cooking.level < COOK_SALMON_LVL);
  };
  document.getElementById('cookSalmonBtn').onmouseleave = hideTooltip;


  // --- Tooltips for Hub Combat ---
  document.getElementById('farmAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Farm</div>');
  document.getElementById('farmAreaBtn').onmouseleave = hideTooltip;
  document.getElementById('caveAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Cave</div>'); // +++ MODIFIED +++
  document.getElementById('caveAreaBtn').onmouseleave = hideTooltip; // +++ NEW +++
  
  // --- Tooltips for Hub Fishing ---
  document.getElementById('oceanAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The Ocean</div>');
  document.getElementById('oceanAreaBtn').onmouseleave = hideTooltip;
  document.getElementById('riverAreaBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">The River</div>');
  document.getElementById('riverAreaBtn').onmouseleave = hideTooltip;
  
  // --- Tooltips for Fishing Spots ---
  document.getElementById('fishHerringBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Herring</div>Requires Fishing Lvl: ${HERRING_FISH_LVL}`);
  document.getElementById('fishHerringBtn').onmouseleave = hideTooltip;
  document.getElementById('fishTroutBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Trout</div>Requires Fishing Lvl: ${TROUT_FISH_LVL}`);
  document.getElementById('fishTroutBtn').onmouseleave = hideTooltip;
  document.getElementById('fishSalmonBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Fish Salmon</div>Requires Fishing Lvl: ${SALMON_FISH_LVL}`);
  document.getElementById('fishSalmonBtn').onmouseleave = hideTooltip;

  // +++ END NEW LISTENER BLOCK +++
  
  
  // preloadAllGameAssets(); // <-- This line should already be here
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
  
  // --- NEW: Prevent Right-Click Menu ---
  // This listens for the 'contextmenu' event (right-click) on the entire page
  // and stops the browser from showing its default menu.
  document.addEventListener('contextmenu', (e) => {
    e.preventDefault(); 
  });
  // --- END NEW ---
  
  const inventoryGrid = document.getElementById('inventoryGrid');
  const inventoryGridWrap = document.getElementById('inventoryGridWrap');
  const bankGridWrap = document.getElementById('bankGridWrap'); // <-- ADD THIS
  let draggedItemIndex = null;
  let currentDragOverSlot = null;
  let draggedShopItem = null; // <-- ADD THIS
  
if (inventoryGridWrap) {
  inventoryGridWrap.addEventListener('dragover', (e) => {
    // Only scroll if we are actively dragging an item
    if (!game.isDragging) return;

    // We must prevent default for dragover to work
    e.preventDefault(); 

    const rect = inventoryGridWrap.getBoundingClientRect();
    const clientY = e.clientY;

    const scrollSpeed = 10; // Pixels to scroll per frame
    const threshold = 50;   // 50px trigger zone from the edge

    const topThreshold = rect.top + threshold;
    const bottomThreshold = rect.bottom - threshold;

    // --- This is the inventory scroll logic ---
    if (clientY < topThreshold) {
      // Mouse is near the top, scroll up
      inventoryGridWrap.scrollTop -= scrollSpeed;
    } else if (clientY > bottomThreshold) {
      // Mouse is near the bottom, scroll down
      inventoryGridWrap.scrollTop += scrollSpeed;
    }
  });
}

// --- This is the new bank scroll logic (placed *after*) ---
if (bankGridWrap) {
  bankGridWrap.addEventListener('dragover', (e) => {
    // Only scroll if we are actively dragging an item
    if (!game.isDragging) return;

    // We must prevent default for dragover to work
    e.preventDefault(); 

    const rect = bankGridWrap.getBoundingClientRect();
    const clientY = e.clientY;

    const scrollSpeed = 10; // Pixels to scroll per frame
    const threshold = 50;   // 50px trigger zone from the edge

    const topThreshold = rect.top + threshold;
    const bottomThreshold = rect.bottom - threshold;

    if (clientY < topThreshold) {
      // Mouse is near the top, scroll up
      bankGridWrap.scrollTop -= scrollSpeed;
    } else if (clientY > bottomThreshold) {
      // Mouse is near the bottom, scroll down
      bankGridWrap.scrollTop += scrollSpeed;
    }
  });
}

  inventoryGrid.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList.contains('inv-slot') && e.target.draggable) {
      draggedItemIndex = parseInt(e.target.dataset.slotIndex);
      e.dataTransfer.effectAllowed = 'move';
      
      // +++ NEW: Link to bank drag system +++
      const item = game.inventory[draggedItemIndex];
      if (item) {
        // Use the script-global draggedBankItem
        draggedBankItem = { item: { ...item }, fromIndex: draggedItemIndex };
      }
      // +++ END NEW +++

      // +++ NEW: Set dragging flag +++
      game.isDragging = true;
      
      setTimeout(() => {
        e.target.classList.add('dragging');
      }, 0);
    }
  });


  inventoryGrid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      if (currentDragOverSlot && currentDragOverSlot !== targetSlot) {
        currentDragOverSlot.classList.remove('drag-over');
      }
      targetSlot.classList.add('drag-over');
      currentDragOverSlot = targetSlot;
    }
  });
  
  inventoryGrid.addEventListener('dragleave', (e) => {
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      targetSlot.classList.remove('drag-over');
      if (currentDragOverSlot === targetSlot) {
        currentDragOverSlot = null;
      }
    }
  });

inventoryGrid.addEventListener('dragend', (e) => {
    // This event fires when the drag operation finishes, 
    // even if it's cancelled or dropped outside a valid target.
    
    // 1. Clean up the '.dragging' class
    const draggingEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    
    // 2. Clean up any lingering 'drag-over' styles
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    
    // 3. Reset all global drag state variables
    draggedItemIndex = null;
    draggedBankItem = null;
    draggedShopItem = null; // <-- ADD THIS
    game.isDragging = false;
  });

  inventoryGrid.addEventListener('drop', async (e) => {
    e.preventDefault();
    const dropSlot = e.target.closest('.inv-slot');
    
    // Cleanup first
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging'); // <-- FIX: Check ALL dragging
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }

    if (!dropSlot) {
      draggedItemIndex = null;
      draggedBankItem = null;
      draggedShopItem = null; // <-- ADD
      game.isDragging = false;
      return;
    }
    
    const dropIndex = parseInt(dropSlot.dataset.slotIndex);

    // +++ NEW: Check for Shop Drag +++
    if (draggedShopItem) {
      // This is a BUY action
      await buyShopItem(draggedShopItem.name, draggedShopItem.price);

    } else if (draggedBankItem && draggedBankItem.source === 'bank') {
    // +++ END NEW +++

      // --- BANK -> INVENTORY (Withdrawal) ---
      await dragWithdrawItem(draggedBankItem.fromIndex, dropIndex);

    } else if (draggedItemIndex !== null) {
      // --- INVENTORY -> INVENTORY (Internal Move) ---
      const fromIndex = draggedItemIndex;
      const toIndex = dropIndex;
      
      if (fromIndex !== toIndex) { 
        
        // --- Get the item data *before* the prompt ---
        const dragItemBeforePrompt = game.inventory[fromIndex];
        const dropItem = game.inventory[toIndex];

        // --- MODIFIED: Handle Shift-Click to move specific amount ---
        if (e.shiftKey && dragItemBeforePrompt) { 
          
          if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
            await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
          } else {
            const input = await showGamePrompt(
              `Move ${dragItemBeforePrompt.name}`, 
              `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
              ""
            );
            
            // --- THIS IS THE FIX ---
            // After the prompt (await) is done, we re-check the inventory
            
            if (input === null) { 
              // User cancelled
              const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
              if (originalSlotEl) originalSlotEl.classList.remove('dragging');
              
            } else {
              // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
              const itemAfterPrompt = game.inventory[fromIndex];
              
              // Check if the item was consumed or changed
              if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
                // The item was consumed! Abort the action.
                draggedItemIndex = null;
                draggedBankItem = null;
                game.isDragging = false;
                return; // Safely exit
              }
              // --- END EXPLOIT FIX ---
            
              const splitAmount = parseInt(input);
              
              if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid number */ }
              
              // Use the most up-to-date quantity
              else if (splitAmount > itemAfterPrompt.qty) { 
                await showGameAlert("Invalid Amount", "You don't have that many.");
              } 
              
              else if (splitAmount === itemAfterPrompt.qty) { 
                // Full stack move
                if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                    dropItem.qty += itemAfterPrompt.qty;
                    game.inventory[fromIndex] = null;
                } else {
                    game.inventory[fromIndex] = dropItem;
                    game.inventory[toIndex] = itemAfterPrompt;
                }
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
              
              else {
                // This is a valid SPLIT
                if (dropItem) { 
                  dropItem.qty += splitAmount;
                } else { 
                  game.inventory[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
                }
                itemAfterPrompt.qty -= splitAmount; // Use the validated item
                
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
            }
          }
        } else {
          // --- This is the ORIGINAL Swap/Stack logic ---
          // We must re-get the dragItem in case it was consumed
          const dragItem = game.inventory[fromIndex]; 
          if (dragItem && dropItem && dragItem.name === dropItem.name) {
              dropItem.qty += dragItem.qty;
              game.inventory[fromIndex] = null;
          } else {
              game.inventory[fromIndex] = dropItem;
              game.inventory[toIndex] = dragItem;
          }
          renderInventoryGrid();
          if (typeof window.savePlayerData === 'function') savePlayerData();
        }
      }
    }
    
    // Final cleanup
    draggedItemIndex = null;
    draggedBankItem = null;
    draggedShopItem = null; // <-- ADD
    game.isDragging = false;
  });
  
  // --- NEW: Settings Modal Listeners ---
  const settingsBtn = document.getElementById('settingsBtn');
  const closeSettingsBtn = document.getElementById('closeSettingsBtn');

  // --- SFX ---
  const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
  const sfxMuteBtn = document.getElementById('sfxMuteBtn');

  // --- Music ---
  const musicVolumeSlider = document.getElementById('musicVolumeSlider');
  const musicMuteBtn = document.getElementById('musicMuteBtn');

  if (settingsBtn) settingsBtn.onclick = openSettings;
  if (closeSettingsBtn) closeSettingsBtn.onclick = closeSettings;

  // --- SFX Slider Listener ---
  if (sfxVolumeSlider) {
    sfxVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.sfxVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isSfxMuted) {
        game.settings.isSfxMuted = false;
        applySettingsUI();
      }
      saveSettings(); // Save on change
    });
  }

  // --- SFX Mute Listener ---
  if (sfxMuteBtn) {
    sfxMuteBtn.onclick = () => {
      game.settings.isSfxMuted = !game.settings.isSfxMuted;
      applySettingsUI(); // Update button text/slider state
      saveSettings(); // Save the new mute state
    };
  }

  // --- Music Slider Listener ---
  if (musicVolumeSlider) {
    musicVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.musicVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isMusicMuted) {
        game.settings.isMusicMuted = false;
        applySettingsUI();
      }
      updateMusicPlayerState(); // Update live music volume
      saveSettings(); // Save on change
    });
  }

  // --- Music Mute Listener ---
  if (musicMuteBtn) {
    musicMuteBtn.onclick = () => {
      game.settings.isMusicMuted = !game.settings.isMusicMuted;
      applySettingsUI(); // Update button text/slider state
      updateMusicPlayerState(); // Update live music volume/mute

      // --- This is a bonus fix for autoplay ---
      // If music isn't playing yet, this click will start it.
      if (!game.settings.isMusicMuted && musicPlayer.paused) {
          musicPlayer.play().then(() => {
            audioAutoplayBlocked = false; 
          }).catch(e => console.warn("Could not start music."));
      }
      // --- End bonus fix ---

      saveSettings(); // Save the new mute state
    };
  }


  
});

window.showSaveIndicator = function() {
    const timerEl = document.getElementById('saveTimerText');
    if (timerEl) {
        timerEl.style.visibility = 'visible';
        // Hide the message after 2 seconds
        setTimeout(() => {
            timerEl.style.visibility = 'hidden';
        }, 2000);
    }
}

</script>

<div id="itemContextMenu"></div>


<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc,
    increment // <-- ADD THIS
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";

  // +++ NEW: Stub function for resetGameState +++
  // The real function is defined in the non-module script
  function stopCraftingBowString() {
    if (typeof window.stopCraftingBowString === 'function') {
      window.stopCraftingBowString();
    } else {
      game.craftingActive = false;
    }
  }
  
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // +++ --- NEW SESSION LOCK CONSTANTS & FUNCTIONS --- +++
  const LOCK_STALE_TIME_MS = 10000; // 10 seconds
  const LOCK_HEARTBEAT_MS = 999999999;  
  /**
   * (Helper) Gets the player doc ref.
   */
  function getPlayerRef() {
    const user = auth.currentUser;
    if (!user) return null;
    return doc(db, "players", user.uid);
  }

  /**
   * Shows the session lock overlay.
   */
  function showSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'flex';
  }
  
  /**
   * Hides the session lock overlay.
   */
  function hideSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'none';
  }

  /**
   * Starts the heartbeat to keep our session lock fresh.
   */
  // --- REPLACED WITH SIMPLIFIED FUNCTION (starting around line 802) ---
  /**
   * Starts the heartbeat to keep our session lock fresh.
   * NOTE: The active lock refresh logic is now solely handled by the 30s autosave
   * (or a separate manual save), so we only start a passive timer.
   */
  window.startSessionHeartbeat = function() {
    if (game.lockHeartbeat) return; // Already running
    
    // Use the extremely large interval, effectively making this timer passive.
    // The 30s autosave is now the only functional timer.
    game.lockHeartbeat = setInterval(() => {
        // This timer still runs, but the interval is so long it will rarely fire,
        // ensuring the 30s autosave is the primary write source.
    }, LOCK_HEARTBEAT_MS); 
  }

  /**
   * Stops the heartbeat.
   */
  window.stopSessionHeartbeat = function() {
    if (game.lockHeartbeat) {
      clearInterval(game.lockHeartbeat);
      game.lockHeartbeat = null;
    }
  }

  /**
   * Releases the session lock from Firebase.
   * @param {boolean} isAsync - If false, we can't wait for the update (e.g., closing tab).
   */
  window.releaseSessionLock = async function(isAsync = true) {
    stopSessionHeartbeat();
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    // We only release the lock if we are the one holding it.
    try {
      const promise = runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) return;
        const lock = snap.data().activeSession;
        if (lock && lock.id === game.sessionLockId) {
          transaction.update(playerRef, { activeSession: null });
        }
      });
      
      if (isAsync) {
        await promise;
      }
    } catch (e) {
      console.error("Failed to release lock:", e);
    }
  }
  
  /**
   * Tries to acquire the session lock using a transaction.
   * This is called when a lock is free or stale, or when user clicks "Take Control".
   */
  window.acquireSessionLock = async function() {
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    try {
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) throw new Error("Player doc does not exist.");
        
        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();
        
        // Check if a fresh lock is held by another session
        if (lock && lock.id !== game.sessionLockId && (now - lock.timestamp) < LOCK_STALE_TIME_MS) {
          throw new Error("Lock is still fresh and held by another session.");
        }
        
        // Lock is free, stale, or ours. Take it.
        const newLock = { id: game.sessionLockId, timestamp: now };
        transaction.update(playerRef, { activeSession: newLock });
      });
      
      // Success! We are now the active session.
      game.isSessionActive = true;
      
      // *** CRITICAL FIX ***: We no longer call startSessionHeartbeat() 
      // here to prevent the original 3s interval logic from running.
      // We rely purely on the 30s autosave for lock refresh.
      
      // startSessionHeartbeat(); <-- DELETE THIS LINE
      
      hideSessionLockOverlay();
      
    } catch (e) {
      console.error("Failed to acquire lock:", e.message);
      // We failed to get the lock, another tab must have beat us.
      // The onSnapshot listener will handle showing the overlay.
    }
  }
  // +++ --- END NEW SESSION LOCK FUNCTIONS --- +++


  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      
      // +++ NEW: Only the active session can save data +++
      if (!game.isSessionActive) return;
      
      const nameToSave = game.name || "";
      const inventoryToSave = [];
      // --- THIS IS THE FIX ---
      // This code was missing. It adds your inventory to the save file.
      game.inventory.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      // +++ NEW: Convert bank to save format +++
      const bankToSave = [];
      game.bank.forEach((item, index) => {
          if (item) {
              bankToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: inventoryToSave, 
        gold: game.gold,
        // +++ NEW +++
        bank: bankToSave,
        bankGold: game.bankGold,
        // +++ END NEW +++
        equipment: game.equipment, // <-- ADD THIS
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        blacksmith: {
          level: game.blacksmith.level,
          xp: game.blacksmith.xp,
          totalXP: game.blacksmith.totalXP
        },
        // +++ NEW ATTACK SAVE LOGIC +++
        attack: {
          level: game.attack.level,
          xp: game.attack.xp,
          totalXP: game.attack.totalXP
        },
        // +++ NEW STRENGTH AND DEFENCE SAVE LOGIC +++
        strength: {
          level: game.strength.level,
          xp: game.strength.xp,
          totalXP: game.strength.totalXP
        },
        defence: {
          level: game.defence.level,
          xp: game.defence.xp,
          totalXP: game.defence.totalXP
        },
        // +++ NEW VITALITY SAVE LOGIC +++
        vitality: {
          level: game.vitality.level,
          xp: game.vitality.xp,
          totalXP: game.vitality.totalXP
        },
        // +++ END NEW VITALITY SAVE LOGIC +++
        // +++ NEW COOKING SAVE LOGIC +++
        cooking: {
          level: game.cooking.level,
          xp: game.cooking.xp,
          totalXP: game.cooking.totalXP
        },
        // +++ NEW WOODCUTTING SAVE LOGIC +++
        woodcutting: {
          level: game.woodcutting.level,
          xp: game.woodcutting.xp,
          totalXP: game.woodcutting.totalXP
        },
        // +++ END NEW WOODCUTTING SAVE LOGIC +++
        // +++ NEW FLETCHING SAVE LOGIC +++
        fletching: {
          level: game.fletching.level,
          xp: game.fletching.xp,
          totalXP: game.fletching.totalXP
        },
        // +++ END NEW FLETCHING SAVE LOGIC +++
        
        // +++ NEW CRAFTING/RANGED SAVE LOGIC +++
        crafting: {
          level: game.crafting.level,
          xp: game.crafting.xp,
          totalXP: game.crafting.totalXP
        },
        ranged: {
          level: game.ranged.level,
          xp: game.ranged.xp,
          totalXP: game.ranged.totalXP
        },
        // +++ NEW FISHING SAVE LOGIC +++
        fishing: {
          level: game.fishing.level,
          xp: game.fishing.xp,
          totalXP: game.fishing.totalXP
        },
        // +++ END NEW SAVE LOGIC +++
        
        playerAttackStyle: game.playerAttackStyle, // <-- ADD THIS
        updatedAt: new Date().toISOString()
        // We don't save activeSession here, that's handled by the lock functions
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
      
      // *** MODIFIED LINE ***
      if (typeof window.showSaveIndicator === 'function') {
        window.showSaveIndicator();
      }

    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- HEAVILY MODIFIED: loadPlayerDataAndStart (now handles session lock) ---
  async function loadPlayerDataAndStart(user) {
    try {
      if (playerDocListener) {
        playerDocListener();
        playerDocListener = null;
      }
      
      if (updatesListenerUnsubscribe) {
        updatesListenerUnsubscribe();
        updatesListenerUnsubscribe = null;
      }
      isUpdatesHistoryLoaded = false;

      const ref = doc(db, "players", user.uid);
      let isFirstLoad = true; 
      
      playerDocListener = onSnapshot(ref, (snap) => {
        
        if (!snap.exists()) {
          console.log("Player document doesn't exist, showing start screen.");
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return; 
        }

        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();

        // --- 1. SESSION LOCK LOGIC ---
        if (!lock || (now - lock.timestamp > LOCK_STALE_TIME_MS)) {
          // Lock is free or stale. Try to acquire it.
          // We only do this if we're not *already* the active session.
          if (!game.isSessionActive) {
            acquireSessionLock();
          }
        } else if (lock.id !== game.sessionLockId) {
          // Another tab has a fresh lock. We are INACTIVE.
          game.isSessionActive = false;
          stopSessionHeartbeat();
          showSessionLockOverlay();
          // Stop any local actions immediately
          stopMining();
          stopBlacksmithing();
          if (game.inTrade) closeTradeWindow();
        } else {
          // We have the lock. We are ACTIVE.
          game.isSessionActive = true;
          hideSessionLockOverlay();
        }

        // --- 2. DATA SYNC LOGIC ---
        
        // Ignore our own "echo" saves
        if (snap.metadata.hasPendingWrites) {
          return;
        }
        
        // If we are the active tab, AND we are busy (mining, dragging, etc.),
        // do not sync data. This prevents rollbacks.
        if (game.isSessionActive && (game.miningActive || game.blacksmithingActive || game.cookingActive || game.woodcuttingActive || game.fletchingActive || game.isDragging)) {
          return;
        }
        
        // If we are INACTIVE, OR we are ACTIVE and IDLE, sync the data.
        game.playerAttackStyle = data.playerAttackStyle || 'strength';
        
        // +++ NEW: Load Equipment +++
        game.equipment = data.equipment || { helmet: null, chest: null, weapon: null, boots: null };
        renderEquipment(); // <-- Render the equipment on load
        // +++ END NEW +++

        if (!data.name) {
          // This handles the case right after registration
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return;
        }

        game.name = data.name || game.name || "Adventurer";
        game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
        game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
        
        let loadedInventoryData = data.inventory || [];
        game.inventory = new Array(game.inventoryCapacity).fill(null);
        if (Array.isArray(loadedInventoryData)) {
            if (loadedInventoryData.length > 0 && typeof loadedInventoryData[0].slot === 'number') {
                loadedInventoryData.forEach(item => {
                    if (item && typeof item.slot === 'number' && item.slot < game.inventoryCapacity) {
                        game.inventory[item.slot] = { name: item.name, qty: item.qty };
                    }
                });
            } else if (loadedInventoryData.length > 0) {
                console.log("Migrating (buggy) array inventory...");
                for (let i = 0; i < loadedInventoryData.length && i < game.inventoryCapacity; i++) {
                    if(loadedInventoryData[i]) {
                      game.inventory[i] = { name: loadedInventoryData[i].name, qty: loadedInventoryData[i].qty };
                    }
                }
            }
        } else {
            console.log("Migrating legacy (object) inventory...");
            const entries = Object.entries(loadedInventoryData);
            for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
                game.inventory[i] = { name: entries[i][0], qty: entries[i][1] };
            }
        }
        
        game.gold = (typeof data.gold === 'number') ? data.gold : 0; 
        
        // +++ NEW: Load Bank Data +++
        game.bankGold = (typeof data.bankGold === 'number') ? data.bankGold : 0;
        let loadedBankData = data.bank || [];
        game.bank = new Array(game.bankCapacity).fill(null);
        if (Array.isArray(loadedBankData)) {
            loadedBankData.forEach(item => {
                if (item && typeof item.slot === 'number' && item.slot < game.bankCapacity) {
                    game.bank[item.slot] = { name: item.name, qty: item.qty };
                }
            });
        }
        // +++ END NEW +++
        
        if (data.mining) {
          game.mining.level = data.mining.level || 1;
          game.mining.xp = data.mining.xp || 0;
          game.mining.totalXP = data.mining.totalXP || getTotalXPForLevel(data.mining.level - 1) + data.mining.xp || 0; 
        } else {
          game.mining = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        if (data.blacksmith) {
          game.blacksmith.level = data.blacksmith.level || 1;
          game.blacksmith.xp = data.blacksmith.xp || 0;
          game.blacksmith.totalXP = data.blacksmith.totalXP || getTotalXPForLevel(data.blacksmith.level - 1) + data.blacksmith.xp || 0; 
        } else {
          game.blacksmith = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW ATTACK LOADING LOGIC +++
        if (data.attack) {
          game.attack.level = data.attack.level || 1;
          game.attack.xp = data.attack.xp || 0;
          game.attack.totalXP = data.attack.totalXP || getTotalXPForLevel(data.attack.level - 1) + data.attack.xp || 0; 
        } else {
          game.attack = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW ATTACK LOADING LOGIC +++
        
        // +++ NEW STRENGTH LOADING LOGIC +++
        if (data.strength) {
          game.strength.level = data.strength.level || 1;
          game.strength.xp = data.strength.xp || 0;
          game.strength.totalXP = data.strength.totalXP || getTotalXPForLevel(data.strength.level - 1) + data.strength.xp || 0; 
        } else {
          game.strength = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW STRENGTH LOADING LOGIC +++
        
        // +++ NEW DEFENCE LOADING LOGIC +++
        if (data.defence) {
          game.defence.level = data.defence.level || 1;
          game.defence.xp = data.defence.xp || 0;
          game.defence.totalXP = data.defence.totalXP || getTotalXPForLevel(data.defence.level - 1) + data.defence.xp || 0; 
        } else {
          game.defence = { level: 1, xp: 0, totalXP: 0 }; 
        }
        //
        //

        // +++ NEW VITALITY LOADING LOGIC +++
        if (data.vitality) {
          game.vitality.level = data.vitality.level || 1;
          game.vitality.xp = data.vitality.xp || 0;
          game.vitality.totalXP = data.vitality.totalXP || getTotalXPForLevel(data.vitality.level - 1) + data.vitality.xp || 0; 
        } else {
          game.vitality = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW COOKING LOADING LOGIC +++
        if (data.cooking) {
          game.cooking.level = data.cooking.level || 1;
          game.cooking.xp = data.cooking.xp || 0;
          game.cooking.totalXP = data.cooking.totalXP || getTotalXPForLevel(data.cooking.level - 1) + data.cooking.xp || 0; 
        } else {
          game.cooking = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW WOODCUTTING LOADING LOGIC +++
        if (data.woodcutting) {
          game.woodcutting.level = data.woodcutting.level || 1;
          game.woodcutting.xp = data.woodcutting.xp || 0;
          game.woodcutting.totalXP = data.woodcutting.totalXP || getTotalXPForLevel(data.woodcutting.level - 1) + data.woodcutting.xp || 0; 
        } else {
          game.woodcutting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW WOODCUTTING LOADING LOGIC +++
        
        // +++ NEW FLETCHING LOADING LOGIC +++
        if (data.fletching) {
          game.fletching.level = data.fletching.level || 1;
          game.fletching.xp = data.fletching.xp || 0;
          game.fletching.totalXP = data.fletching.totalXP || getTotalXPForLevel(data.fletching.level - 1) + data.fletching.xp || 0; 
        } else {
          game.fletching = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW FLETCHING LOADING LOGIC +++
        
        // +++ NEW CRAFTING LOADING LOGIC +++
        if (data.crafting) {
          game.crafting.level = data.crafting.level || 1;
          game.crafting.xp = data.crafting.xp || 0;
          game.crafting.totalXP = data.crafting.totalXP || getTotalXPForLevel(data.crafting.level - 1) + data.crafting.xp || 0; 
        } else {
          game.crafting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW CRAFTING LOADING LOGIC +++
        
        // +++ NEW RANGED LOADING LOGIC +++
        if (data.ranged) {
          game.ranged.level = data.ranged.level || 1;
          game.ranged.xp = data.ranged.xp || 0;
          game.ranged.totalXP = data.ranged.totalXP || getTotalXPForLevel(data.ranged.level - 1) + data.ranged.xp || 0; 
        } else {
          game.ranged = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW RANGED LOADING LOGIC +++
        
        // +++ NEW FISHING LOADING LOGIC +++
        if (data.fishing) {
          game.fishing.level = data.fishing.level || 1;
          game.fishing.xp = data.fishing.xp || 0;
          game.fishing.totalXP = data.fishing.totalXP || getTotalXPForLevel(data.fishing.level - 1) + data.fishing.xp || 0; 
        } else {
          game.fishing = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW FISHING LOADING LOGIC +++

        setText('charName', game.name);
        updateHPUI(); // This now calculates maxHP using game.vitality.level
        renderInventoryGrid();
        updateSkillUI();
        updateGoldUI(); 
        
        // +++ NEW: Pre-render the bank UI on load +++
        renderBankGrid();
        updateBankGoldUI();
        // +++ END NEW +++

        // +++ NEW: Pre-render the Shop UI on load +++
        renderShopGrid();
        // +++ END NEW +++
        
        if (isFirstLoad) {
          window.renderLeaderboards(); 
          isFirstLoad = false;         
          backToActions(); 
        }
        
        startScreen.style.display = 'none';
        authScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        loadSettings();
        startMusicPlaylist();

      }, async (error) => { // <-- Add 'async' here
        console.error("Player listener error:", error);
        await showGameAlert("Load Error", "Error loading player data. Please refresh the page.");
      });
      
      const initialSnap = await getDoc(ref);
      if (!initialSnap.exists() || !initialSnap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false; 
      }

      return true; 
      
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }

  // --- MODIFIED: Added activeSession to new doc ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: [],
        gold: 100, 
        // +++ NEW +++
        bank: [],
        bankGold: 0,
        // +++ END NEW +++
        equipment: { helmet: null, chest: null, weapon: null, boots: null },
        mining: { level: 1, xp: 0, totalXP: 0 },
        blacksmith: { level: 1, xp: 0, totalXP: 0 }, 
        attack: { level: 1, xp: 0, totalXP: 0 }, 
        strength: { level: 1, xp: 0, totalXP: 0 }, 
        defence: { level: 1, xp: 0, totalXP: 0 }, 
        vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY FOR NEW ACCOUNTS +++
        cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING FOR NEW ACCOUNTS +++
        woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING FOR NEW ACCOUNTS +++
        fletching: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW FLETCHING FOR NEW ACCOUNTS +++
        
        // +++ NEW SKILLS FOR NEW ACCOUNTS +++
        crafting: { level: 1, xp: 0, totalXP: 0 },
        ranged: { level: 1, xp: 0, totalXP: 0 },
        fishing: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW FISHING FOR NEW ACCOUNTS +++
        
        playerAttackStyle: 'strength',
        activeSession: null, // +++ ADD THIS
        createdAt: new Date().toISOString()
      });
      await showGameAlert("Account Created", "Your account has been created. You must now create your character.");
    } catch (err) {
      await showGameAlert("Registration Failed", err.message || "An unknown error occurred during registration.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      await showGameAlert("Login Failed", err.message || "An unknown error occurred during login.");
      console.error(err);
    }
  };

  // --- MODIFIED: Handles session cleanup ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();

      const started = await loadPlayerDataAndStart(user);
      
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
        game.playerAttackStyle = 'strength';
      }
      
      if (started) {
        initChatListener();
        initTradeListeners();
        initUpdatesListener();
        initBroadcastListener(); // +++ ADD THIS LINE +++
        // The loadPlayerDataAndStart listener will automatically handle
        // acquiring the lock on first load.
      } else {
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // User is logged out
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      
      // Stop listeners and release lock
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();
      if (updatesListenerUnsubscribe) updatesListenerUnsubscribe();
      if (broadcastListenerUnsubscribe) broadcastListenerUnsubscribe(); // +++ ADD THIS LINE +++
      isUpdatesHistoryLoaded = false;
      stopSessionHeartbeat();
      // We don't release the lock, just let it go stale.
      
      if (window.resetGameState) {
        window.resetGameState();
      }
      isTradeRequestsLoaded = false; 
    }
  });

  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) { await showGameAlert("Error", "Please enter a name for your character."); return; }
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            { await showGameAlert("Name Taken", "That name is already taken. Please choose another."); return; }
          }
        } catch (e) {
          console.error("Name check failed:", e);
          { await showGameAlert("Error", "An error occurred while checking the name. Please try again."); return; }
        }
        
        originalCreate(); // Sets game.name locally
        
        const user = auth.currentUser;
        if (user) {
          // --- THIS IS THE FIX ---
          // We MUST acquire the session lock *before* trying to save,
          // otherwise savePlayerData() will exit early because
          // game.isSessionActive is false.
          if (typeof window.acquireSessionLock === 'function') {
            await window.acquireSessionLock();
          }

          game.isSessionActive = true;
         

          await window.savePlayerData(); // This will now succeed
          window.renderLeaderboards();
          initChatListener(); 
          initTradeListeners(); 
          initUpdatesListener(); 
          // The onSnapshot listener will fire and update the UI
        }
      };
    }
  })();
  
  // --- CHAT FUNCTIONS (Unchanged) ---
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false; 
  let playerDocListener = null; 
  let updatesListenerUnsubscribe = null;
  let isUpdatesHistoryLoaded = false; 
// +++ NEW BROADCAST LISTENER +++
  let broadcastListenerUnsubscribe = null;
  let lastBroadcastTimestamp = null;


  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;
    if (messageText.length === 0) return; 
    
    // +++ NEW: Prevent sending chat from inactive tab +++
    if (!game.isSessionActive) {
      await showGameAlert("Session Not Active", "This tab is not active. Take control to send messages.");
      return;
    }
    
    chatInput.value = '';
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; 
    }
    if (messageText.length > 256) {
      await showGameAlert("Error", "Your message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      await showGameAlert("Error", "You must be logged in and have a character to chat.");
      return;
    }
    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      await showGameAlert("Error", "Failed to send message. Please try again.");
    }
  }
  function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';
    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; 
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    chatMessagesContainer.prepend(msgElement); 
  }
  function formatUpdateTimestamp(timestamp) {
    if (!timestamp) return "Just now";
    const date = timestamp.toDate();
    // Formats to: 11/11/25
    return date.toLocaleString('en-US', {
      month: 'numeric',
      day: 'numeric',
      year: '2-digit'
    });
  }

  function addUpdateMessageToDOM(doc) {
    const contentContainer = document.getElementById('updatesContent');
    if (!contentContainer) return;

    const data = doc.data();
    const docId = doc.id;

    // --- FIX: Check if this update is already in the DOM ---
    if (document.getElementById(`update-${docId}`)) {
      return; // Already exists, do nothing
    }
    // --- END FIX ---

    const msgElement = document.createElement('div');
    msgElement.className = 'update-message';
    msgElement.id = `update-${docId}`; // --- NEW: Add unique ID ---
    
    const formattedDate = formatUpdateTimestamp(data.timestamp);
    
    // Create text nodes to prevent HTML injection from the update message
    const textNode = document.createTextNode(" " + data.text);
    const strongNode = document.createElement('strong');
    strongNode.textContent = `${formattedDate}:`;
    
    msgElement.appendChild(strongNode);
    msgElement.appendChild(textNode);
    
    // Add to the top of the list
    contentContainer.prepend(msgElement);
  }

  function initUpdatesListener() {
    if (updatesListenerUnsubscribe) {
      updatesListenerUnsubscribe();
      updatesListenerUnsubscribe = null;
    }
    const contentContainer = document.getElementById('updatesContent');
    if (!contentContainer) return;

    const q = query(
      collection(db, "updates"), 
      orderBy("timestamp", "asc"), // Get oldest first
      limitToLast(20) // But only the last 20
    );

    updatesListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      if (!isUpdatesHistoryLoaded) {
        // First load: clear "loading" and add all docs
        isUpdatesHistoryLoaded = true;
        contentContainer.innerHTML = '';
        // Prepend all docs so they end up in newest-first order
        querySnapshot.docs.forEach(doc => {
          addUpdateMessageToDOM(doc); // --- FIX: Pass whole doc ---
        });
      } else {
        // Subsequent loads: only add new ones
        querySnapshot.docChanges().forEach((change) => {
          // --- FIX: Show all new messages, including your own ---
          if (change.type === "added") {
            addUpdateMessageToDOM(change.doc); // --- FIX: Pass whole doc ---
          }
        });
      }

      // Prune old messages if we have more than 20
      while (contentContainer.childElementCount > 20) {
        contentContainer.lastChild.remove(); // Remove from the bottom
      }
      
    }, (error) => {
      console.error("Updates listener error: ", error);
      contentContainer.innerHTML = '<div style="color: red; text-align: center;">Error loading updates.</div>';
    });
  }

  // +++ NEW: BROADCAST LISTENER +++
  function initBroadcastListener() {
    if (broadcastListenerUnsubscribe) {
      broadcastListenerUnsubscribe();
      broadcastListenerUnsubscribe = null;
    }

    const broadcastRef = doc(db, "system", "broadcast");

    broadcastListenerUnsubscribe = onSnapshot(broadcastRef, (doc) => {
      if (!doc.exists()) return; // No broadcast message set

      const data = doc.data();
      const message = data.message;
      const timestamp = data.timestamp;

      // If timestamp is null (still pending) or matches the one we've already shown, ignore it
      if (!timestamp || (lastBroadcastTimestamp && timestamp.toMillis() === lastBroadcastTimestamp.toMillis())) {
        return;
      }

      // This is a new message!
      lastBroadcastTimestamp = timestamp;

      const overlay = document.getElementById('broadcastOverlay');
      const messageEl = document.getElementById('broadcastMessage');

      if (overlay && messageEl) {
        messageEl.textContent = message;
        overlay.style.display = 'flex';
      }

    }, (error) => {
      console.error("Broadcast listener error: ", error);
    });
  }

  function initChatListener() {
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      let hasAdds = false; 
      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isChatHistoryLoaded) {
            hasAdds = true; 
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            
            // +++ NEW: Admin Color Check +++
            if (msg.senderUid === ADMIN_UID) {
              sender.style.color = '#ff4d4d'; // Admin Red
            } else {
              sender.style.color = 'var(--gold)'; // Default Gold
            }
            // +++ END NEW +++
            
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });
      if (!isChatHistoryLoaded) {
        isChatHistoryLoaded = true;
        let hadHistoryMessages = false;
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            
            // +++ NEW: Admin Color Check +++
            if (msg.senderUid === ADMIN_UID) {
              sender.style.color = '#ff4d4d'; // Admin Red
            } else {
              sender.style.color = 'var(--gold)'; // Default Gold
            }
            // +++ END NEW +++
            
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
        });
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; 
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      else if (hasAdds) {
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        chatMessagesContainer.scrollTop = 0;
      }
    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  
  // --- TRADE FUNCTIONS (Mostly Unchanged) ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; 
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    if (!isChatHistoryLoaded) {
      localMessageQueue.push({ text, type });
    } else {
      _addLocalMessageToDOM(text, type);
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      chatMessagesContainer.scrollTop = 0;
    }
  }
  function convertSavedInvToLocal(savedInvData) {
      const localInv = new Array(game.inventoryCapacity).fill(null);
      if (!Array.isArray(savedInvData)) {
          const entries = Object.entries(savedInvData);
          for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
              localInv[i] = { name: entries[i][0], qty: entries[i][1] };
          }
      } else {
          if (savedInvData.length > 0 && typeof savedInvData[0].slot === 'number') {
              savedInvData.forEach(item => {
                  if (item && item.slot < game.inventoryCapacity) {
                      localInv[item.slot] = { name: item.name, qty: item.qty };
                  }
              });
          } else if (savedInvData.length > 0) {
              for (let i = 0; i < savedInvData.length && i < game.inventoryCapacity; i++) {
                  if (savedInvData[i]) {
                      localInv[i] = { name: savedInvData[i].name, qty: savedInvData[i].qty };
                  }
              }
          }
      }
      return localInv;
  }
  function convertLocalInvToSaved(localInv) {
      const inventoryToSave = [];
      localInv.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      return inventoryToSave;
  }

  // =================================================================
  // --- 3. REPLACED 'checkItem' FUNCTION (module script) ---
  // This function now correctly SUMS all stacks.
  // =================================================================
  function checkItem(localInvArray, itemName, qty) {
      let totalQty = 0;
      for (const slot of localInvArray) {
          if (slot && slot.name === itemName) {
              totalQty += slot.qty;
          }
      }
      return totalQty >= qty;
  }

  // =================================================================
  // --- 4. REPLACED 'modifyInventory' FUNCTION (module script) ---
  // This function now correctly adds/removes from multiple stacks.
  // =================================================================
  function modifyInventory(localInvArray, itemName, qtyChange) {
      // Deep copy the array to avoid modifying the original
      const newInv = JSON.parse(JSON.stringify(localInvArray)); 
      
      if (qtyChange > 0) { // Adding items
          let amountToAdd = qtyChange;
          
          // 1. Try to stack first
          for (const slot of newInv) {
              if (slot && slot.name === itemName) {
                  slot.qty += amountToAdd;
                  amountToAdd = 0;
                  break; 
              }
          }
          
          // 2. If still items left, find an empty slot
          if (amountToAdd > 0) {
              let emptySlotIndex = newInv.findIndex(slot => slot === null);
              if (emptySlotIndex > -1) {
                  newInv[emptySlotIndex] = { name: itemName, qty: amountToAdd };
              } else {
                  // This should be caught by the transaction, but good to have
                  throw new Error(`Inventory full, cannot add ${itemName}.`);
              }
          }
      } else if (qtyChange < 0) { // Removing items
          let amountToRemove = Math.abs(qtyChange);
          
          // 1. Iterate backwards to empty smaller/later stacks first
          for (let i = newInv.length - 1; i >= 0; i--) {
              const slot = newInv[i];
              if (slot && slot.name === itemName) {
                  if (slot.qty > amountToRemove) {
                      // This stack has more than we need
                      slot.qty -= amountToRemove;
                      amountToRemove = 0;
                  } else {
                      // This stack will be emptied
                      amountToRemove -= slot.qty;
                      newInv[i] = null; // Empty the slot
                  }
              }
              if (amountToRemove === 0) break; // We're done
          }
          if (amountToRemove > 0) {
              // This should be impossible if checkItem was called first
              throw new Error(`Tried to remove more ${itemName} than available.`);
          }
      }
      return newInv;
  }
  // =================================================================
  // --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
  // =================================================================

  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);
            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addGold(amount); 
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self gold: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data(); // We still need this for the name
                await updateDoc(doc(db, "players", playerDoc.id), {
                    gold: increment(amount) // Use the atomic increment operation
                });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); 
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; 
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addItem(formattedName, qty); // Uses new addItem
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self item: ${e.message}`, 'error');
                }
                return true;
            }
            // This command now uses the NEW modifyInventory, so it will work
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                let currentLocalInv = convertSavedInvToLocal(playerData.inventory || []);
                const newLocalInv = modifyInventory(currentLocalInv, formattedName, qty); // Uses new modifyInventory
                const newSavedInv = convertLocalInvToSaved(newLocalInv);
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newSavedInv });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            // +++ NEW: Added 'crafting', 'ranged', 'fishing' to admin command +++
            const validSkills = ['mining', 'blacksmith', 'attack', 'strength', 'defence', 'vitality', 'cooking', 'woodcutting', 'fletching', 'crafting', 'ranged', 'fishing'];
if (!validSkills.includes(skill)) {
     addLocalChatMessage("Unknown skill. Use: mining, blacksmith, attack, strength, defence, vitality, cooking, woodcutting, fletching, crafting, ranged, or fishing.", 'error');
     return true;
}
            const newTotalXP = getTotalXPForLevel(level); 
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };
            if (targetName === game.name.toLowerCase()) {
                try {
                    game[skill] = newSkillData; 
                    updateSkillUI();
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Set own ${skill} level to ${level}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error setting self level: ${e.message}`, 'error');
                }
                return true;
            }
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { [skill]: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s ${skill} level to ${level}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
        
        // +++ NEW: Admin /update command +++
        if (command === 'update') {
            const messageText = args.join(' ');
            if (messageText.length === 0) {
                addLocalChatMessage("Usage: /update [message]", 'error');
                return true;
            }
            if (messageText.length > 512) {
              addLocalChatMessage("Error: Update message is too long (max 512 chars).", 'error');
              return true;
            }

            try {
              // Add to the new 'updates' collection
              await addDoc(collection(db, "updates"), {
                text: messageText,
                timestamp: serverTimestamp()
              });
              addLocalChatMessage("Update posted.", 'system');
            } catch (e) {
              console.error("Error posting update: ", e);
              addLocalChatMessage("Error posting update.", 'error');
            
            }
            return true;
        }
        
        // +++ NEW: Admin /messageall command +++
        if (command === 'messageall') {
            const messageText = args.join(' ');
            if (messageText.length === 0) {
                addLocalChatMessage("Usage: /messageall [message]", 'error');
                return true;
            }
            if (messageText.length > 512) {
              addLocalChatMessage("Error: Message is too long (max 512 chars).", 'error');
              return true;
            }

            try {
              // Set the broadcast message
              await setDoc(doc(db, "system", "broadcast"), {
                message: messageText,
                timestamp: serverTimestamp()
              });
              addLocalChatMessage("Broadcast message sent.", 'system');
            } catch (e) {
              console.error("Error sending broadcast: ", e);
              addLocalChatMessage("Error sending broadcast.", 'error');
            }
            return true;
        }
        // +++ END NEW +++
    }
    
    // +++ NEW: Check for active session before allowing trade +++
    
    if (!game.isSessionActive) {
      addLocalChatMessage("This tab is not active. Take control to trade.", 'error');
      return true; // It's a command, but it's blocked.
    }

    if (messageText.startsWith('/trade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    if (messageText.startsWith('/accepttrade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    return false;
  }
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }
      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');
    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);
      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      const requestSnapshot = await getDocs(requestQuery);
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          return data.fromUid === requesterUid; 
      });
      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }
      const requestDoc = validRequests[0]; 
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      await batch.commit();
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); 
    tradeSessionUnsubscribes = []; 
    isTradeRequestsLoaded = false; 
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    // Trade requests are disabled due to maintenance.
    tradeRequestUnsubscribe = onSnapshot(requestQuery, () => {
      isTradeRequestsLoaded = true;
    }, (error) => console.error("Trade request listener error:", error));
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; 
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }
    if (game.blacksmithingActive) {
        stopBlacksmithing();
        game.wasMiningBeforeTrade = true; 
    }
    
    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    
    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    // --- THIS IS THE FIX ---
    // Use the session data to initialize the trade state
    game.myTradeOffer = sessionData[myRole];
    game.theirTradeOffer = sessionData[theirRole];
    // --- END FIX ---
    
    game.myTradeRole = myRole; 

    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    
    // Set the gold input to the *correct* initial value
    document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
    document.getElementById('tradeMyGoldOffer').max = game.gold;
    
    renderTradeInventory(); 
    // Render the grids with the data we just loaded
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); 
    renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems); 
    modal.style.display = 'flex'; 
    if (game.activeTradeListener) game.activeTradeListener(); 
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      const data = doc.data();
      if (data.status === 'cancelled') {
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      if (data.status === 'completed') {
        addLocalChatMessage("Trade complete!", 'trade');
        closeTradeWindow();
        return;
      }
      // --- THIS IS THE FIX ---
      // ONLY update THEIR offer from the snapshot
      game.theirTradeOffer = data[theirRole];
      
      // Manually sync our own "accepted" status
      // This is the ONLY part of our offer we want from the server
      game.myTradeOffer.accepted = data[myRole].accepted;

      // Render THEIR grid (our grid is updated locally)
      // We also update our inventory to show correct available amounts
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      renderTradeInventory();
      
      // We no longer need to check if we're typing, because we are
      // no longer syncing our own gold value from the server.
      
      // ONLY set THEIR gold display
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // Update statuses for both
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);
      // --- END FIX ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';

    // --- Create a map of available items from all stacks ---
    const availableItems = new Map();
    for (const slot of game.inventory) {
        if (slot) {
            const currentQty = availableItems.get(slot.name) || 0;
            availableItems.set(slot.name, currentQty + slot.qty);
        }
    }
    
    // --- Subtract offered items ---
    for (const [name, qty] of Object.entries(game.myTradeOffer.offerItems)) {
        if (availableItems.has(name)) {
            availableItems.set(name, availableItems.get(name) - qty);
        }
    }

    // --- Render the grid based on the calculated map ---
    availableItems.forEach((qtyAvailable, name) => {
      if (qtyAvailable <= 0) return; 

      const slotEl = document.createElement('div');
      slotEl.className = 'inv-slot';
      slotEl.onclick = () => addItemToOffer(name, qtyAvailable); 
      let imgName = name.toLowerCase().replace(/\s+/g,'_');
      if (name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      const img = document.createElement('img');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slotEl.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slotEl.appendChild(amt);
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slotEl.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slotEl.onmouseleave = hideTooltip;
      grid.appendChild(slotEl);
    });
  }
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    const itemEntries = Object.entries(items);
    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        const img = document.createElement('img');
        let imgName = name.toLowerCase().replace(/\s+/g,'_');
        if (name === 'Copper Bar') {
            imgName = 'copperbar';
        }
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }
  async function addItemToOffer(itemName, maxQty) {
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      // --- MODIFICATION HERE ---
      const input = await window.showGamePrompt( // Use window.showGamePrompt
        `Offer ${itemName}`,
        `How many ${itemName} do you want to offer? (Max: ${maxQty})`, 
        maxQty
      );
      if (input === null) return; 
      qtyToOffer = parseInt(input);
      // --- END MODIFICATION ---
    }
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      await window.showGameAlert("Invalid Amount", `You can only offer up to ${maxQty} of this item.`); // Use window.showGameAlert
      qtyToOffer = maxQty;
    }
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      await window.showGameAlert("Trade Full", "Your trade offer grid is full (16 unique items)."); // Use window.showGameAlert
      return;
    }
    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    game.myTradeOffer = newOfferObject;
    
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 

    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; 
    delete newOfferItems[itemName]; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 2. Update local UI IMMEDIATELY
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 
    // --- END FIX ---

    try {
      // 3. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    // --- END FIX ---

    try {
      // 2. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true 
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }
  async function cancelTrade() {
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;
    const sessionId = game.activeTradeSessionId;
    closeTradeWindow(); 
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
      }
    }
  }
  function closeTradeWindow() {
    if (!game.inTrade) return; 
    if (game.activeTradeListener) {
      game.activeTradeListener(); 
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; 
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    renderInventoryGrid();
    updateGoldUI();
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      const startBtn = document.getElementById('startMineBtn');
      const startSmithBtn = document.getElementById('startSmithBtn');
      if (startBtn) {
        startMining();
      } else if (startSmithBtn) { 
        startBlacksmithing();
      }
    }
  }
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);
        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }
        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;
        const p1LocalInv = convertSavedInvToLocal(p1Data.inventory || []);
        const p2LocalInv = convertSavedInvToLocal(p2Data.inventory || []);
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!checkItem(p1LocalInv, item, qty)) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!checkItem(p2LocalInv, item, qty)) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }

        let newP1LocalInv = [...p1LocalInv];
        let newP2LocalInv = [...p2LocalInv];

        // --- These loops now use the NEW 'modifyInventory' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
            newP1LocalInv = modifyInventory(newP1LocalInv, item, -qty);
            newP2LocalInv = modifyInventory(newP2LocalInv, item, +qty);
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
            newP2LocalInv = modifyInventory(newP2LocalInv, item, -qty);
            newP1LocalInv = modifyInventory(newP1LocalInv, item, +qty);
        }
        // --- End of new function usage ---

        const newP1SavedInv = convertLocalInvToSaved(newP1LocalInv);
        const newP2SavedInv = convertLocalInvToSaved(newP2LocalInv);
        transaction.update(sessionRef, { status: 'completed' });
        transaction.update(player1Ref, {
            gold: p1Data.gold - p1Offer.offerGold + p2Offer.offerGold,
            inventory: newP1SavedInv
        });
        transaction.update(player2Ref, {
            gold: p2Data.gold - p2Offer.offerGold + p1Offer.offerGold,
            inventory: newP2SavedInv
        });
      });
    } catch (e) {
      console.error("TRADE FAILED:", e);
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    
    // --- FIX: Remove the line that clears innerHTML to prevent flash ---
    // contentContainer.innerHTML = `...`; // <-- THIS LINE IS DELETED
    
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        
        // --- THIS IS THE FIX ---
        // We now get the totalXP from *all* skills and add them together.
        const miningXp = data.mining?.totalXP || 0; 
        const blacksmithXp = data.blacksmith?.totalXP || 0;
        const attackXp = data.attack?.totalXP || 0;
        const strengthXp = data.strength?.totalXP || 0;
        const defenceXp = data.defence?.totalXP || 0;
        const vitalityXp = data.vitality?.totalXP || 0;
        const cookingXp = data.cooking?.totalXP || 0;
        const woodcuttingXp = data.woodcutting?.totalXP || 0; // +++ NEW +++
        const fletchingXp = data.fletching?.totalXP || 0; // +++ NEW +++
        const craftingXp = data.crafting?.totalXP || 0; // +++ NEW +++
        const rangedXp = data.ranged?.totalXP || 0; // +++ NEW +++
        const fishingXp = data.fishing?.totalXP || 0; // +++ NEW +++

        const totalXp = miningXp + blacksmithXp + attackXp + strengthXp + defenceXp + vitalityXp + cookingXp + woodcuttingXp + fletchingXp + craftingXp + rangedXp + fishingXp;
        // --- END OF FIX ---

        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // --- MODIFIED: Added Session Lock Button ---
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = async () => {
          // --- NEW: Disable button and show loading text ---
          refreshLeaderboardBtn.disabled = true;
          refreshLeaderboardBtn.textContent = '...'; // Use '...' as it's small

          if (typeof window.savePlayerData === 'function') {
            await window.savePlayerData();
          }
          
          // --- NEW: Await the render so we can re-enable the button ---
          await window.renderLeaderboards(); 
          
          // --- NEW: Re-enable button ---
          refreshLeaderboardBtn.disabled = false;
          refreshLeaderboardBtn.textContent = 'Refresh';
        };
    }
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); 
          sendChatMessage();
        }
      });
    }
    
    // +++ NEW: Session Lock Button +++
    const takeControlBtn = document.getElementById('takeControlButton');
    if (takeControlBtn) {
      takeControlBtn.onclick = () => {
        if (typeof window.acquireSessionLock === 'function') {
          window.acquireSessionLock();
        }
      };
    }
  });

  // --- Autosave runs every 30s, but only performs writes if the tab is visible ---
  setInterval(async () => {
    const user = auth.currentUser;

    // Check if user is logged in, is the active session, not in trade, AND THE TAB IS VISIBLE.
    if (user && game.isSessionActive && !game.inTrade && !document.hidden) {
        
      // 1. Refresh Lock Heartbeat (WRITE)
      // This update maintains the lock and prevents other tabs from stealing control.
      const playerRef = getPlayerRef();
      if (playerRef) {
          try {
              await updateDoc(playerRef, { "activeSession.timestamp": Date.now() }); 
          } catch (e) {
              console.error("Autosave Heartbeat failed:", e);
          }
      }
      
      // 2. Perform Full Save (WRITE)
      window.savePlayerData();
    }
    // If document.hidden is true, the timer function exits immediately with no writes.
  }, 9000);

  // --- MODIFIED: Releases session lock on tab close ---
  window.addEventListener('beforeunload', (e) => {
    try {
      // If we are the active session, release the lock
      if (game.isSessionActive) {
        if (typeof window.releaseSessionLock === 'function') {
          // Fire-and-forget, we can't wait for the update
          window.releaseSessionLock(false); 
        }
      }
      
      // Try one last save
      const user = auth.currentUser;
      if (user && game.isSessionActive && !game.inTrade) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // --- MODIFIED: Releases session lock on logout ---
  window.firebaseLogout = async function() {
  try {
    // 1. If in trade, cancel it first (Existing logic)
    if (game.inTrade && game.activeTradeSessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.warn("Could not cancel active trade on logout:", e);
      }
      closeTradeWindow();
    }

    // +++ NEW: STOP ALL ACTIONS +++
    // This is the fix. Stop all intervals and set active flags to false.
    if (game.inCombat) {
      runFromCombat(false);
    }
    if (game.miningActive) {
      stopMining();
    }
    if (game.blacksmithingActive) {
      stopBlacksmithing();
    }
    if (game.cookingActive) {
      stopCookingChicken();
    }
    if (game.woodcuttingActive) {
      stopWoodcutting();
    }
    if (game.fletchingActive) {
      stopFletching();
    }
    if (game.craftingActive) {
      stopCraftingBowString();
    }
    if (game.fishingActive) {
      stopFishing();
    }
    // +++ END NEW +++
    
    // 2. +++ NEW CRITICAL FIX +++: Release the session lock explicitly
    if (game.isSessionActive) {
      if (typeof window.releaseSessionLock === 'function') {
        // Await the lock release before doing anything else
        await window.releaseSessionLock(true);
      }
    }
    stopSessionHeartbeat();
    
    // 3. Save, then sign out
    await window.savePlayerData();
    await signOut(auth);
    
    await showGameAlert("Logged Out", "You have been successfully logged out.");
  } catch (e) {
    console.error("Logout failed:", e);
    await showGameAlert("Logout Failed", "Logout failed. Please try again or close your browser.");
  }
};

  (function() {
    // --- This is the new master preloader ---

    // Define all critical images your game needs to start
    const MASTER_ASSET_LIST = [
      'images/brick_background.png',
      'images/gearicon.png',

      // --- ADD THESE 6 LINES FOR YOUR NEW PLACEHOLDERS ---
      'images/necklace.png',
      'images/cape.png',
      'images/shield.png',
      'images/legs.png',
      'images/ring.png',
      'images/arrows.png',
      // --- END OF NEW LINES ---

      'images/helmet.png',
      'images/weapon.png',
      'images/chestplate.png',
      'images/boots.png',
      'images/goldpouch.png',
      'images/mines.png',
      'images/foresticon.png',
      'images/blacksmithicon.png',
      'images/kitchenbutton.png',
      'images/combatareas.png',
      'images/shopbutton.png',
      'images/bankbutton.png',
      'images/miningskillicon.png',
      'images/blacksmithskillicon.png',
      'images/attackskillicon.jpeg',
      'images/strengthskillicon.png',
      'images/defenseskillicon.png',
      'images/vitalityskillicon.png',
      'images/cookingskillicon.png',
      'images/woodcuttingskillicon.jpeg',
      'images/copperore.png',
      'images/copperbar.png',
      'images/coppershortsword.png',
      'images/copperhelmet.png',
      'images/copperchestplate.png',
      'images/copperboots.png',
      'images/rawchicken.png',
      'images/cookedchicken.png',
      'images/burntchicken.png',
      'images/chickenmonster.png',
      'images/chickenanim.gif',
      'images/coppervein.png',
      'images/coalvein.png',
      'images/ironvein.png',
      'images/farm.png',
      'images/softwood.png',
      'images/oak.png',
      'images/bronzepickaxe.png',
      'images/bronzeaxe.png',
      'images/copperpickaxe.png',
      'images/copperaxe.png',
      'images/ironpickaxe.png',
      'images/ironaxe.png',
      'images/ironore.png',
      'images/ironbar.png',
      'images/ironshortsword.png',
      'images/ironhelmet.png',
      'images/ironchestplate.png',
      'images/ironboots.png',
      'images/fletchingskillicon.jpeg', // +++ CHANGED TO .jpeg +++
      'images/fletchingworkbench.png',
      'images/feather.png',
      'images/arrowshaft.png',
      'images/copperarrowtip.png',
      'images/unboundarrow.png',
      'images/copperarrow.png',
      'images/copperplatelegs.png', // +++ NEW +++
      'images/ironplatelegs.png', // +++ NEW +++
      
      // +++ NEW CAVE/SPIDER ASSETS +++
      'images/cave.png',
      'images/spidermonster.png',
      'images/spideranim.gif',
      'images/silk.png',
      
      // +++ NEW ASSETS FOR CRAFTING/RANGED +++
      'images/craftingskillicon.png',
      'images/rangedskillicon.jpeg',
      'images/craftingbenchbutton.png',
      'images/bowstring.png',
      'images/unstrungsoftwoodbow.png',
      'images/unstrungoakbow.png',
      'images/softwoodbow.png',
      'images/oakbow.png',
      // +++ NEW LEATHER ASSETS +++
      'images/cowhide.png',
      'images/leatherhood.png',
      'images/leather.png',
      'images/leatherarmor.png',
      'images/leatherpants.png',
      'images/leatherboots.png',
      'images/cowmonster.png',
      'images/cowanim.webp',
      
      // +++ NEW FISHING ASSETS +++
      'images/fishingskillicon.jpeg',
      'images/fishingareasbutton.jpeg',
      'images/oceanbutton.png',
      'images/riverbutton.jpeg',
      'images/herring.png',
      'images/trout.png',
      'images/salmon.png',
      
      // +++ NEW FISHING REQUIREMENTS +++
      'images/fishingpole.png',
      'images/fishingbait.png'
    ];

    /**
     * Preloads all assets and shows a loading screen
     * @param {string[]} assetList - Array of image paths
     * @returns {Promise}
     */
    function preloadAllAssets(assetList) {
      const authScreen = document.getElementById('authScreen');
      if (authScreen) authScreen.style.display = 'none';

      // Find the existing loading screen
      const loadingScreen = document.getElementById('loadingScreen');
      loadingScreen.style.display = 'flex'; // Make sure it's visible
      
      // --- NEW: Get Progress Bar elements ---
      const progressBarFill = document.getElementById('loading-bar-fill');
      const progressPercentText = document.getElementById('loading-progress-percent');
      // --- END NEW ---

      // --- REMOVED old progressText creation ---

      let loadedCount = 0;
      const totalAssets = assetList.length; // --- NEW: Get total count ---

      const promises = assetList.map(src => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            loadedCount++;
            
            // --- NEW: Update Progress Bar ---
            const percent = Math.round((loadedCount / totalAssets) * 100);
            if (progressBarFill) {
              progressBarFill.style.width = percent + '%';
            }
            if (progressPercentText) {
              progressPercentText.innerText = percent + '%';
            }
            // --- END NEW ---

            // --- REMOVED old text update ---
            resolve();
          };
          img.onerror = () => {
            console.warn(`[Preloader] Failed to load: ${src}`);
            resolve(); // Resolve anyway so the game doesn't hang
          };
          img.src = src;
        });
      });

      return Promise.all(promises);
    }

    // Run the preloader
    preloadAllAssets(MASTER_ASSET_LIST).then(() => {
      console.log('[Preloader] All assets loaded.');

      // +++ NEW: Force-decode combat GIFs +++
      // This invisibly adds the GIFs to the page, forcing the browser
      // to decode them before they are needed.
   const primeImg = document.createElement('img');
   primeImg.src = 'images/chickenanim.gif';
   primeImg.style.cssText = 'position:absolute; left:-9999px; top:-9999px; width:1px; height:1px;';
   document.body.appendChild(primeImg);

      // +++ ADD THIS BLOCK FOR THE SPIDER +++
   // +++ ADD THIS BLOCK FOR THE COW +++
   const primeImg3 = document.createElement('img');
   primeImg3.src = 'images/cowanim.gif';
   primeImg3.style.cssText = 'position:absolute; left:-9999px; top:-9999px; width:1px; height:1px;';
   document.body.appendChild(primeImg3);
   // +++ END NEW +++
      
      const loadingScreen = document.getElementById('loadingScreen');
      
      if (loadingScreen) {
        loadingScreen.style.display = 'none'; // Hide loading
      }

      // --- We removed the code that shows the authScreen ---
      // The onAuthStateChanged listener will now handle showing
      // the correct screen (login OR game) without a flash.

    });

  })();
</script>
</body>
</html>