<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}
body {
  margin: 0;
  font-family: "Garamond", serif;
  background: #3f2b21;
  background-image: url('images/brick_background.png');
  background-size: cover;
  background-attachment: fixed;
  background-position: center center;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- Panel Row Wrappers --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch;
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- Spacer for Chat Panel --- */
.sidebar-spacer {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0;
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  background: var(--panel-bg);
  padding: 16px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.char-header { display: flex; justify-content: center; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px;
}

.hp-bar { background: #772222; border-radius: 6px; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

#equipmentTab {
  display: flex;
  flex-direction: column;
  /* justify-content: center;  <- REMOVED */
  flex-grow: 1;
  /* padding-top: 70px; <- REMOVED */
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { display: flex; flex-direction: column; align-items: center; }
.equipment-row { display: flex; justify-content: center; margin: 6px 0; gap: 10px; }
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  padding: var(--slot-gap); 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 2000;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- Custom Scrollbar --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px;
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Main area --- */
.main {
  flex: 1;
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  min-height: 500px; 
  position: relative;
  
  /* --- NEW: Added flex properties --- */
  display: flex;
  flex-direction: column;
}

.bank-content-wrapper {
  /* This overrides the standard padding from the parent containers (like .main or #mainContentWrapper) */
  padding: 0 10px 10px 10px; /* Adjust top/bottom padding as needed, but reduce left/right */
  width: 100%;
  box-sizing: border-box; /* Crucial for preventing width overflow */
}

#mainContentWrapper {
  flex-grow: 1;     /* Allows this wrapper to fill the panel's height */
  overflow-y: auto;   /* ADDS A SCROLLBAR if content is too tall */
  min-height: 0;      /* A flexbox fix to allow shrinking/scrolling */
  
  /* --- NEW: Add custom scrollbar --- */
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}

#mainContentWrapper::-webkit-scrollbar {
  width: 8px;
}
#mainContentWrapper::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
#mainContentWrapper::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Chat Panel --- */
.chat-panel {
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  display: flex; 
  flex-direction: column;
  min-height: 200px;
  flex-shrink: 0;
  flex: 1;
}
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}
#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}

/* --- Action Progress --- */
.progress-container {
  background: #7c644c;
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}

.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }
.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}

.progress-text {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  pointer-events: none; /* Lets clicks pass through */
}

button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

@media(max-width:900px) {
  .container { flex-direction: column; align-items: center; }
  #top-row-panels, #bottom-row-chat {
      flex-direction: column;
      width: 95%;
  }
  .sidebar, .main, .chat-panel { 
      width: 100%;
      box-sizing: border-box;
  }
  .sidebar-spacer {
      display: none;
  }
}

/* --- Trade Modal --- */
#tradeModal { display: none; }
.trade-content {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}
.trade-main-area { display: flex; gap: 20px; flex: 1; }
.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}
.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img { width: 30px; height: 30px; }
#tradeInventoryGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}
.trade-offer-layout { display: flex; gap: 20px; }
.trade-offer-box { flex: 1; display: flex; flex-direction: column; }
.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}
#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}
.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}

/* --- Drag & Drop --- */
.inv-slot.dragging {
  opacity: 0.4;
  cursor: grabbing;
}
.inv-slot.drag-over {
  border-color: var(--gold);
  border-style: dashed;
  background: rgba(181, 166, 66, 0.1);
}

/* +++ NEW: SESSION LOCK OVERLAY +++ */
#sessionLockOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#sessionLockOverlay div {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  padding: 30px 40px;
  border-radius: 10px;
  max-width: 400px;
}
#sessionLockOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}

#deathOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5001; /* Higher than session lock */
  justify-content: center;
  align-items: center;
  text-align: center;
}
#deathOverlay div {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  padding: 30px 40px;
  border-radius: 10px;
  max-width: 400px;
}
#deathOverlay h2 {
  margin-top: 0;
  color: #ff4d4d; /* Red for death */
}
/* +++ END NEW STYLES +++ */

#combat-main-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

#combat-enemy-area {
  flex-basis: 200px; /* Reduced from 220px */
  flex-shrink: 0;
  text-align: center;
  position: relative;
  margin-bottom: 15px;
}

#combat-enemy-img {
  max-height: 150px; /* Reduced from 180px */
  max-width: 100%;
  object-fit: contain;
}

#combat-enemy-hp-bar {
  background: #772222;
  border-radius: 6px;
  /* overflow: hidden; */ /* <-- This is the fix */
  position: relative;
  height: 28px;
  width: 80%;
  max-width: 300px;
  margin: 10px auto 0 auto;
  border: 2px solid #333;
}

#combat-enemy-hp-fill {
  height: 100%;
  background: #d22;
  width: 100%;
  transition: width 0.25s;
}

#combat-enemy-hp-text {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  font-size: 13px;
}

#combat-player-area {
  flex-grow: 1;
  display: flex;
  gap: 20px;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
}


#combat-action-panel {
  /* flex-grow: 1; has been removed */
  display: flex;
  flex-direction: column;
}

#combat-styles {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

#combat-styles button {
  flex: 1;
  padding: 12px;
  border: 2px solid var(--accent);
  background: var(--accent);
  opacity: 0.7;
}

#combat-styles button.active {
  background: var(--accent-hover);
  border-color: var(--gold);
  opacity: 1.0;
}


#combat-main-actions {
  display: flex;
  gap: 10px;
  flex-direction: column; /* Stack buttons */
}

#combat-main-actions button {
  /* flex: 1; removed */
  font-size: 16px;
}
/* --- END: Combat UI Styles --- */

.combat-splat {
  position: absolute;
  right: -40px; /* Moved over to center the new box */
  top: -5px;    /* Moved up slightly */
  font-size: 1.2rem;
  font-weight: bold;
  pointer-events: none;
  z-index: 1600;
  animation: rise 900ms ease-out forwards;
  
  /* --- NEW "BOX" STYLES --- */
  background: rgba(10, 10, 10, 0.75);
  border: 1px solid #000;
  border-radius: 6px;
  padding: 3px 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}

.splat-damage {
  color: #ff4d4d; /* Bright red */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

.splat-block {
  color: #6dafff; /* Bright blue */
  text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* Simpler shadow */
}

/* --- NEW: Item Context Menu --- */
#itemContextMenu {
  display: none;
  position: fixed;
  z-index: 3000;
  background: var(--panel-bg);
  border: 2px solid #453625;
  border-radius: 6px;
  box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  padding: 5px;
  min-width: 100px;
}
.context-menu-btn {
  display: block;
  width: 100%;
  padding: 8px 12px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 4px;
  text-align: left;
  cursor: pointer;
  font-weight: 700;
}
.context-menu-btn:hover {
  background: var(--accent-hover);
}
/* --- END: Item Context Menu --- */

#bankGrid {
  /* Set the number of columns */
  grid-template-columns: repeat(5, var(--slot-size)); 
  
  /* --- CRITICAL FIX: Re-add centering and set min-width on its WRAPPER --- */
  /* This ensures the grid is centered again */
  justify-content: center; 
}
/* --- END NEW RULE --- */

/* --- NEW: Bank UI Styles --- */

#bankContainer {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
#bankGoldPanel {
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  /* This will put the input/button group on one side and "Banked Gold" on the other */
  justify-content: space-between; 
  align-items: center;
  flex-wrap: wrap;
  gap: 20px; /* Increased gap a bit for balance */
  margin-top: -10px;
}
#bankGoldPanel > div {
  text-align: center;
}
#bankGoldPanel .gold-display {
  font-size: 18px;
  font-weight: bold;
  color: var(--gold);
}
#bankGoldPanel input {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  width: 120px;
}
#bankGridPanels {
  display: flex;
  gap: 20px;
}
#bankPanel, #bankInventoryPanel {
  flex: 1;
  background: rgba(0,0,0,0.15);
  padding: 15px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  /* --- CRITICAL FIX: Add min-width to prevent panel from shrinking --- */
  min-width: 400px; 
}
#bankPanel h3, #bankInventoryPanel h3 {
  margin: 0 0 10px 0;
  text-align: center;
}
#bankGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
  /* Taller 8-row height */
  height: calc((var(--slot-size) + var(--slot-gap)) * 8 + var(--slot-gap));
}

#gameModalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4000;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  box-sizing: border-box;
}
.game-modal {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 100%;
  max-width: 450px;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.game-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.game-modal-content {
  font-size: 16px;
  line-height: 1.5;
  margin-bottom: 20px;
}
.game-modal-input {
  width: 100%;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 16px;
  box-sizing: border-box; /* Important */
}
.game-modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

#equipmentStats {
  margin-top: 20px; /* Space below the character model */
  padding: 10px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
}
.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 4px;
  font-size: 15px;
}
.stat-row:not(:last-child) {
  border-bottom: 1px solid var(--accent);
}
.stat-label {
  color: #efe3cf;
  font-weight: bold;
}
.stat-value {
  color: var(--gold);
  font-weight: bold;
}
/* --- END: Equipment Stats Display --- */

/* --- NEW: Locked Item/Vein Style --- */
.locked-item {
  opacity: 0.4;
  filter: grayscale(80%);
  cursor: not-allowed !important;
}
.locked-item:hover {
  background: var(--accent) !important; /* Prevents hover effect */
}
/* --- END: Locked Item/Vein Style --- */

.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

/* --- NEW: Smithing Tab Active State --- */
.tabs button.active {
  background: var(--accent-hover); /* Make it look "pressed" */
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid var(--gold); /* Highlight it */
}
#smithingItemsContainer {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
/* --- END: Smithing Tabs --- */

#settingsBtn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  right: 2px; /* <-- FIX: Changed from 18px */
  width: 22px;
  height: 22px;
  background: transparent; 
  border: 0;
  outline: none;
  border-radius: 6px;
  cursor: pointer;
  padding: 0; 
  box-sizing: border-box;
  z-index: 10;
}
#settingsBtn:hover {
  background: transparent; /* <-- FIX: Keep background transparent on hover */
  opacity: 0.8; /* <-- Add a subtle hover effect instead */
}
#settingsBtn img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none; /* Let clicks pass to the button */
}

.setting-row label {
  font-weight: bold;
  font-size: 16px;
  flex-basis: 110px; /* Give labels a fixed width to align sliders */
  flex-shrink: 0;
}
.setting-mute-btn {
  min-width: 80px; /* Make mute buttons smaller */
  padding: 8px 10px;
  margin-left: 15px; /* Space from slider */
}

/* --- NEW: Settings Modal --- */
#settingsModalOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.7);
  z-index: 4500; /* Below session lock, above trade */
  justify-content: center;
  align-items: center;
}
.settings-modal {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 90%;
  max-width: 400px;
  display: flex;
  flex-direction: column;
}
.settings-modal-title {
  font-size: 20px;
  font-weight: bold;
  color: var(--gold);
  margin: 0 0 15px 0;
  border-bottom: 2px solid var(--accent);
  padding-bottom: 10px;
}
.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
  gap: 15px;
}
.setting-row label {
  font-weight: bold;
  font-size: 16px;
}
.volume-slider {
  flex-grow: 1;
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 12px;
  background: #3f2b21;
  border: 1px solid #453625;
  border-radius: 6px;
  outline: none;
}
.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}
.volume-slider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  background: var(--accent-hover);
  border: 2px solid #453625;
  border-radius: 50%;
  cursor: pointer;
}

/* --- NEW: Hub Screen Toggler --- */
.hub-screen {
  display: none; /* Hide all hubs by default */
  width: 100%;
  height: 100%;
  flex-direction: column;
}
.hub-screen.active {
  display: flex; /* Show the active one */
}
/* --- END NEW --- */

</style>
</head>
<body>

<div id="loadingScreen" style="display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background: #3f2b21; z-index: 10000;">
  <div style="text-align: center; color: var(--gold); font-size: 20px; font-weight: bold;">
    Loading assets...
  </div>
</div>

<div id="authScreen" style="display:none; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header" style="position: relative;">
          <h2 id="charName">Player</h2>
          <button id="settingsBtn" onmouseenter="showTooltip(event, 'Settings')" onmouseleave="hideTooltip()">
            <img src="images/gearicon.png" alt="Settings">
          </button>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-row">
                  <div class="equipment-slot" id="helmet">
                    <img src="images/helmet.png" alt="Helmet">
                  </div>
                </div>
                <div class="equipment-row" style="align-items:center;">
                  <div class="equipment-slot" id="weapon">
                    <img src="images/weapon.png" alt="Weapon">
                  </div>
                  <div class="equipment-slot" id="chest">
                    <img src="images/chestplate.png" alt="Chest">
                  </div>
                </div>
                <div class="equipment-row">
                  <div class="equipment-slot" id="boots">
                    <img src="images/boots.png" alt="Boots">
                  </div>
                </div>
              </div>
            </div>

            <div id="equipmentStats">
              <div class="stat-row">
                <span class="stat-label">Physical Damage</span>
                <span class="stat-value" id="stat-phys-dmg">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Armor</span>
                <span class="stat-value" id="stat-armor">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-label">Attack Speed</span>
                <span class="stat-value" id="stat-speed">4.0s</span>
              </div>
            </div>
            </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
              <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
                <img src="images/goldpouch.png" alt="Gold" style="width: 60px; height: 60px; object-fit: contain;">
                <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 8px;">0</span>
              </div>
              
            </div>
            
          </div>
          
          <div id="skillsTab" style="display:none;">
            </div>
          
        </div>
      </div>

      <div class="main" id="mainArea">

        <div id="mainContentWrapper">
        
          <div id="hubActions" class="hub-screen">
            <div id="actionScreen" style="display: flex; gap: 10px; flex-wrap: wrap;">
              <img id="minesActionIcon" src="images/mines.png" alt="Mines" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="forestActionIcon" src="images/foresticon.png" alt="Forest" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="blacksmithActionIcon" src="images/blacksmithicon.png" alt="Blacksmith" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="kitchenActionIcon" src="images/kitchenbutton.png" alt="Kitchen" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="combatActionIcon" src="images/combatareas.png" alt="Combat Areas" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="shopActionIcon" src="images/shopbutton.png" alt="Shop" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
              <img id="bankActionIcon" src="images/bankbutton.png" alt="Bank" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
            </div>
          </div>

          <div id="hubMine" class="hub-screen">
            <h2>Mine</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a vein to mine.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="copperVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coppervein.png" alt="Copper Vein" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="coalVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/coalvein.png" alt="Coal Vein" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="ironVeinBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/ironvein.png" alt="Iron Vein" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubMine_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubBlacksmith" class="hub-screen">
            <div class="tabs" style="margin-top: 0; margin-bottom: 14px; width: 100%;">
              <button id="smithCopperTab" class="active">Copper</button>
              <button id="smithIronTab">Iron</button>
            </div>
            <div id="smithingItemsContainer" class="action-buttons" style="margin-top: 0; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              </div>
            <div class="action-buttons" style="margin-top: 14px; width: 100%;">
              <button id="hubBlacksmith_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubForest" class="hub-screen">
            <h2>Forest</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose a tree to chop.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:row; flex-wrap: wrap; align-items:flex-start; gap: 10px;">
              <button id="softwoodTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/softwood.png" alt="Softwood Tree" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
              </button>
              <button id="oakTreeBtn" class="primary" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
                <img src="images/oak.png" alt="Oak Tree" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
              </button>
            </div>
            <div class="action-buttons" style="margin-top: 14px;">
              <button id="hubForest_ReturnBtn" class="primary" style="background:#666; margin-top: 20px;">Return</button>
            </div>
          </div>
          
          <div id="hubKitchen" class="hub-screen">
            <h2>Kitchen</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose something to cook.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start; gap: 10px;">
              <button id="cookChickenBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
                <img src="images/cookedchicken.png" alt="Cooked Chicken" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
                <span>Cooked Chicken</span>
              </button>
              <button id="hubKitchen_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubCombat" class="hub-screen">
            <h2>Combat Areas</h2>
            <div style="margin-top:8px; color:#efe3cf;">Choose an area to start fighting.</div>
            <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
              <button id="farmAreaBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
                <img src="images/farm.png" alt="Farm Area" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
                <span>The Farm</span>
              </button>
              <button id="hubCombat_ReturnBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
            </div>
          </div>
          
          <div id="hubShop" class="hub-screen">
            <h2>General Store</h2>
            <div style="display: flex; gap: 20px; margin-top: 16px; width: 100%;">
              <div style="flex: 1; background:rgba(0,0,0,0.1); border-radius:6px; padding: 10px 15px;">
                <h3 style="margin:0 0 10px 0; color: var(--gold);">Sell Items</h3>
                <p style="margin:0 0 10px 0;">Click an item in your inventory to sell it.</p>
                <ul style="margin: 5px 0 0 20px; padding: 0;">
                  <li style="margin-top:5px;">Copper Ore - 1 Gold each</li>
                </ul>
              </div>
              <div style="flex: 1; background:rgba(0,0,0,0.1); border-radius:6px; padding: 10px 15px;">
                <h3 style="margin:0 0 10px 0; color: var(--gold);">Buy Items</h3>
                <div class="action-buttons" style="margin: 0; flex-direction: column; align-items: flex-start; gap: 8px;">
                  <button id="buyPickaxeBtn" class="primary" style="width: 100%; text-align: left;">Bronze Pickaxe - 10 Gold</button>
                  <button id="buyAxeBtn" class="primary" style="width: 100%; text-align: left;">Bronze Axe - 10 Gold</button>
                </div>
              </div>
            </div>
            <div class="action-buttons" style="margin-top:20px;">
              <button id="hubShop_ReturnBtn" class="primary" style="background:#666;">Return</button>
            </div>
          </div>
          
          <div id="hubBank" class="hub-screen">
            <div id="bankContainer" style="width: 100%;">
              <div class="bank-content-wrapper"> 
                <div id="bankGoldPanel">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="number" id="bankGoldInput" min="0" placeholder="Amount...">
                    <button id="bankDepositGoldBtn" class="primary">Deposit</button>
                    <button id="bankWithdrawGoldBtn" class="primary">Withdraw</button>
                  </div>
                  <div>
                    <div>Banked Gold</div>
                    <div id="bankStoredGold" class="gold-display">0</div>
                  </div>
                </div>
                <div id="bankPanel">
                  <h3>Bank Storage</h3>
                  <div class="inventory-grid-wrap" id="bankGridWrap">
                    <div class="inventory-grid" id="bankGrid"></div>
                  </div>
                </div>
              </div>
              <div class="action-buttons" style="margin-top:0px; align-self: flex-start;">
                <button id="hubBank_ReturnBtn" class="primary" style="background:#666;">Return</button>
              </div>
            </div>
          </div>

          <div id="hubDynamic" class="hub-screen">
            </div>

        </div> <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>
        <div id="saveTimerText" style="display: none; margin-top: 10px; text-align: right; font-size: 11px; color: #aaffaa; font-weight: bold;">
            Progress Saved!
        </div>
      </div>

    </div> 
    
    <div id="bottom-row-chat">

      <div class="sidebar-spacer"></div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div class="sidebar-spacer"></div>

    </div> 
    
  </div> 
</div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<div id="sessionLockOverlay" style="display: none;">
  <div>
    <h2>Session Active Elsewhere</h2>
    <p>This account is already being played in another tab or browser. To prevent data corruption, this tab has been disabled.</p>
    <button id="takeControlButton" class="primary">Take Control Here</button>
  </div>
</div>

<div id="deathOverlay" style="display: none;">
  <div>
    <h2>You died!</h2>
    <p>You lost all your inventory and gold.</p>
    <button id="reviveBtn" class="primary" onclick="revivePlayer()">Revive</button>
  </div>
</div>

<!-- NEW: Settings Modal -->
<div id="settingsModalOverlay">
  <div class="settings-modal">
    <div class="settings-modal-title">Settings</div>
    
    <div class="setting-row">
      <label for="sfxVolumeSlider">Sound Effects</label>
      <input type="range" id="sfxVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="sfxMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="setting-row">
      <label for="musicVolumeSlider">Music</label>
      <input type="range" id="musicVolumeSlider" class="volume-slider" min="0" max="1" step="0.05">
      <button id="musicMuteBtn" class="primary setting-mute-btn">Mute</button>
    </div>

    <div class="action-buttons" style="margin-top: 10px; justify-content: flex-end;">
      <button id="closeSettingsBtn" class="primary" style="background:#666;">Close</button>
    </div>
  </div>
</div>
<!-- END: Settings Modal -->

<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  settings: { 
    sfxVolume: 0.5, 
    isSfxMuted: false, 
    musicVolume: 0.15,  // <--- Changed this from 0.3
    isMusicMuted: false 
  },
  inventory: [], 
  inventoryCapacity: 39,
  gold: 0,
  // --- NEW BANK PROPERTIES ---
  bank: [],
  bankCapacity: 20, // Example: 40 slots
  bankGold: 0,
  // --- END NEW ---
  equipment: {
    helmet: null,
    chest: null,
    weapon: null,
    boots: null
  },
  mining: { level: 1, xp: 0, totalXP: 0 },
  blacksmith: { level: 1, xp: 0, totalXP: 0 },
  attack: { level: 1, xp: 0, totalXP: 0 }, 
  strength: { level: 1, xp: 0, totalXP: 0 }, 
  defence: { level: 1, xp: 0, totalXP: 0 }, 
  vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY SKILL +++
  cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING SKILL +++
  woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING SKILL +++
  miningActive: false,
  blacksmithingActive: false,
  cookingActive: false,
  woodcuttingActive: false, // +++ NEW WOODCUTTING STATE +++
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, 
  isAdmin: false,
  inCombat: false,
  playerAttackStyle: 'strength', // Default to strength
  currentEnemy: null,
  playerCombatInterval: null,
  enemyCombatInterval: null,
  wasMiningBeforeCombat: false, // Renamed from 'wasMiningBeforeTrade'
  wasSmithingBeforeCombat: false,
  wasWoodcuttingBeforeCombat: false,
  
  // +++ NEW SESSION LOCK +++
  // This is a unique ID for this specific tab
  sessionLockId: (function() {
  let id = sessionStorage.getItem('gameSessionId');
  if (!id) {
    // No ID exists, so this is a new tab. Create one.
    id = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    sessionStorage.setItem('gameSessionId', id);
  }
  // Return the persistent ID for this tab
  return id;
})(),
// +++ END MODIFICATION +++

lockHeartbeat: null,    // This will hold the setInterval ID for the heartbeat
isSessionActive: false, // Is this tab the "master" tab?
isDragging: false,      // Are we currently dragging an item?

inTrade: false,
activeTradeSessionId: null,
activeTradeListener: null, 
myTradeRole: null, 
myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};
// +++ END MODIFICATION +++

game.inventory = new Array(game.inventoryCapacity).fill(null);
game.bank = new Array(game.bankCapacity).fill(null);

// --- NEW: Music Player State ---
const musicPlaylist = [
  'sounds/music/music1.mp3',
  'sounds/music/music2.mp3',
  'sounds/music/music3.mp3',
  'sounds/music/music4.mp3'
];
let currentTrackIndex = 0;
const musicPlayer = new Audio(); 
musicPlayer.loop = false;
let audioAutoplayBlocked = false; // We handle the loop to change tracks
// --- END NEW ---

/**
 * Finds the highest tier tool of a specific type in the player's inventory.
 * @param {('pickaxe'|'axe')} toolType - The type of tool to look for.
 * @returns {number} The tier level (0 for none, 1 for Bronze, 2 for Copper, etc.)
 */
function getBestTool(toolType) {
  const tiers = (toolType === 'pickaxe') ? PICKAXE_TIERS : AXE_TIERS;
  let bestTier = 0;

  for (const slot of game.inventory) {
    if (slot && tiers[slot.name]) {
      if (tiers[slot.name] > bestTier) {
        bestTier = tiers[slot.name];
      }
    }
  }
  return bestTier;
}

/**
 * Updates the music player's volume/mute state from game.settings
 */
function updateMusicPlayerState() {
  if (game.settings.isMusicMuted) {
    musicPlayer.volume = 0;
  } else {
    musicPlayer.volume = game.settings.musicVolume;
  }
}

/**
 * Plays the next track in the playlist.
 */
function playNextTrack() {
  if (musicPlaylist.length === 0) return; 

  currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
  musicPlayer.src = musicPlaylist[currentTrackIndex];

  updateMusicPlayerState(); // Apply current volume settings

  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- NEW "CLICK ANYWHERE" FIX ---
      if (!audioAutoplayBlocked) { // Only add this listener ONCE
        audioAutoplayBlocked = true;

        // Listen for the *first* click or tap anywhere
        const interactionListener = () => {
          resumeMusicAfterInteraction();
          // Clean up this listener so it doesn't run again
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- END NEW ---

    });
  }
}

/**
 * Starts the music playlist for the first time.
 */
function startMusicPlaylist() {
  // Set up the listener for *all future songs*
  musicPlayer.addEventListener('ended', playNextTrack);

  // Set the volume before playing
  updateMusicPlayerState(); 

  // --- NEW: Pick a random song to start ---
  currentTrackIndex = Math.floor(Math.random() * musicPlaylist.length);
  musicPlayer.src = musicPlaylist[currentTrackIndex];
  // --- END NEW ---

  // Manually start the first song (we copy this logic from playNextTrack)
  const playPromise = musicPlayer.play();

  if (playPromise !== undefined) {
    playPromise.catch(error => {
      console.warn("Music autoplay blocked. User must interact to enable sound.");

      // --- This is the "click anywhere" fix ---
      if (!audioAutoplayBlocked) { 
        audioAutoplayBlocked = true;

        const interactionListener = () => {
          resumeMusicAfterInteraction();
          document.removeEventListener('click', interactionListener);
          document.removeEventListener('touchstart', interactionListener);
        };

        document.addEventListener('click', interactionListener);
        document.addEventListener('touchstart', interactionListener);
      }
      // --- End fix ---

    });
  }
}

/**
 * Tries to resume music playback after a user interaction.
 */
function resumeMusicAfterInteraction() {
  // Check if music is supposed to be on but is paused
  if (!game.settings.isMusicMuted && musicPlayer.paused) {
    const resumePromise = musicPlayer.play();

    if (resumePromise !== undefined) {
      resumePromise.then(() => {
        // SUCCESS! Autoplay is now unblocked.
        audioAutoplayBlocked = false; 
      }).catch(e => {
        // Still failed? Oh well.
        console.warn("Could not resume music.", e);
      });
    }
  }
}

const VALID_ITEMS = [
  'Bronze Pickaxe', // +++ NEW +++
  'Bronze Axe',     // +++ NEW +++
  'Copper Pickaxe', // +++ NEW +++
  'Copper Axe',     // +++ NEW +++
  'Iron Pickaxe',   // +++ NEW +++
  'Iron Axe',       // +++ NEW +++
  'Softwood',
  'Oak',
  'Copper Ore',
  'Copper Bar',
  'Copper Chestplate',
  'Copper Shortsword',
  'Copper Helmet', 
  'Copper Boots', 
  'Raw Chicken',
  'Cooked Chicken',
  'Burnt Chicken',
  'Coal Ore',
  'Iron Ore',
  'Iron Bar',
  'Iron Helmet',
  'Iron Chestplate',
  'Iron Boots',
  'Iron Shortsword'
];

const XP_TABLE = [
  0,        // Level 1
  83,       // Level 2
  174,      // Level 3
  276,      // Level 4
  388,      // Level 5
  512,      // Level 6
  650,      // Level 7
  801,      // Level 8
  969,      // Level 9
  1154,     // Level 10
  1358,     // Level 11
  1584,     // Level 12
  1833,     // Level 13
  2107,     // Level 14
  2411,     // Level 15
  2746,     // Level 16
  3115,     // Level 17
  3523,     // Level 18
  3973,     // Level 19
  4470,     // Level 20
  5018,     // Level 21
  5624,     // Level 22
  6291,     // Level 23
  7028,     // Level 24
  7842,     // Level 25
  8740,     // Level 26
  9730,     // Level 27
  10824,    // Level 28
  12031,    // Level 29
  13363,    // Level 30
  14833,    // Level 31
  16456,    // Level 32
  18247,    // Level 33
  20224,    // Level 34
  22436,    // Level 35
  24898,    // Level 36
  27673,    // Level 37
  30779,    // Level 38
  33648,    // Level 39
  37224,    // Level 40
  41171,    // Level 41
  45542,    // Level 42
  50339,    // Level 43
  55649,    // Level 44
  61512,    // Level 45
  67983,    // Level 46
  75127,    // Level 47
  83014,    // Level 48
  91721,    // Level 49
  101333,   // Level 50
  111945,   // Level 51
  123660,   // Level 52
  136615,   // Level 53
  150872,   // Level 54
  166636,   // Level 55
  184040,   // Level 56
  203254,   // Level 57
  224446,   // Level 58
  247866,   // Level 59
  273742,   // Level 60
  302288,   // Level 61
  333804,   // Level 62
  368599,   // Level 63
  407015,   // Level 64
  449426,   // Level 65
  496254,   // Level 66
  547953,   // Level 67
  605032,   // Level 68
  668051,   // Level 69
  737637,   // Level 70
  814445,   // Level 71
  899252,   // Level 72
  992895,   // Level 73
  1096245,  // Level 74
  1210210,  // Level 75
  1336486,  // Level 76
  1475581,  // Level 77 (Using 1,475,581)
  1629200,  // Level 78 (Using 1,629,200)
  1798808,  // Level 79
  1986068,  // Level 80
  2192818,  // Level 81
  2421027,  // Level 82
  2673114,  // Level 83
  2951373,  // Level 84 (Using 2,951,373)
  3258594,  // Level 85
  3597292,  // Level 86
  3972294,  // Level 87 (Using 3,972,294)
  4385776,  // Level 88
  4842295,  // Level 89
  5346332,  // Level 90 (Using 5,346,332)
  5902831,  // Level 91
  6517253,  // Level 92
  7195629,  // Level 93
  7944614,  // Level 94
  8771588,  // Level 95
  9684577,  // Level 96
  10692629, // Level 97
  11805606, // Level 98
  13034031, // Level 99
  15000000  // Level 100: Custom value
];

const CHESTPLATE_BAR_COST = 10;
const CHESTPLATE_XP = 50; // Defining a standard XP gain for the item

// +++ NEW SHORTSWORD CONSTANTS +++
const SHORTSWORD_BAR_COST = 5;
const SHORTSWORD_XP = 32;
const SHORTSWORD_TIME_MS = 5000;
// +++ END NEW CONSTANTS +++
const HELMET_BAR_COST = 5;
const HELMET_XP = 32; // Same as shortsword
const HELMET_TIME_MS = 5000; // Same as shortsword
// +++ END NEW CONSTANTS +++

// +++ NEW BOOTS CONSTANTS +++
// +++ NEW BOOTS CONSTANTS +++
const BOOTS_BAR_COST = 4;
const BOOTS_XP = 26; // 4 bars (~6.5xp/bar)
const BOOTS_TIME_MS = 4000; // 4 bars (1s/bar)

// --- NEW: Mining Level Requirements ---
const COAL_MINE_LVL = 5;
const IRON_MINE_LVL = 10;

// --- NEW: Coal/Iron Mining Constants ---
const COAL_MINE_TIME_MS = 2000;
const COAL_MINE_XP = 20;
const COAL_MINE_ITEM = 'Coal Ore';

const IRON_MINE_TIME_MS = 3000;
const IRON_MINE_XP = 35;
const IRON_MINE_ITEM = 'Iron Ore';

const MINE_COOLDOWN_COPPER_MS = 1000; // 1.0s
const MINE_COOLDOWN_COAL_MS = 1500;   // 1.5s
const MINE_COOLDOWN_IRON_MS = 1500;   // 1.5s

// --- NEW: Blacksmith Level Requirements ---
const COPPER_BAR_LVL = 1;
const COPPER_PICKAXE_LVL = 2;
const COPPER_AXE_LVL = 2;
const COPPER_SWORD_LVL = 3;
const COPPER_BOOTS_LVL = 5;
const COPPER_HELMET_LVL = 6;
const COPPER_CHEST_LVL = 8;

const IRON_BAR_LVL = 11;
const IRON_PICKAXE_LVL = 12;
const IRON_AXE_LVL = 12;
const IRON_SWORD_LVL = 13;
const IRON_BOOTS_LVL = 15;
const IRON_HELMET_LVL = 16;
const IRON_CHEST_LVL = 18;

// --- NEW: Iron Smithing Constants ---
const IRON_BAR_ORE_COST = 1; // 1 Iron Ore
const IRON_BAR_COAL_COST = 2; // 1 Coal Ore
const IRON_BAR_XP = 30;
const IRON_BAR_TIME_MS = 6000;

const IRON_HELMET_BAR_COST = 5;
const IRON_HELMET_XP = 150; 
const IRON_HELMET_TIME_MS = 7000; 

const IRON_CHESTPLATE_BAR_COST = 10;
const IRON_CHESTPLATE_XP = 300; 
const IRON_CHESTPLATE_TIME_MS = 12000; 

const IRON_BOOTS_BAR_COST = 4;
const IRON_BOOTS_XP = 120; 
const IRON_BOOTS_TIME_MS = 6000; 

const IRON_SHORTSWORD_BAR_COST = 5;
const IRON_SHORTSWORD_XP = 150;
const IRON_SHORTSWORD_TIME_MS = 7000;

// --- NEW: Woodcutting Level Requirements ---
const SOFTWOOD_TREE_LVL = 1;
const OAK_TREE_LVL = 10;

// --- NEW: Woodcutting Chop Constants ---
const SOFTWOOD_CHOP_TIME_MS = 1500;
const SOFTWOOD_CHOP_XP = 15;
const SOFTWOOD_CHOP_ITEM = 'Softwood';

const OAK_CHOP_TIME_MS = 3000;
const OAK_CHOP_XP = 35;
const OAK_CHOP_ITEM = 'Oak';

const CHOP_COOLDOWN_SOFTWOOD_MS = 1000;
const CHOP_COOLDOWN_OAK_MS = 1500;

// --- NEW: Tool Crafting Requirements ---
const COPPER_AXE_BAR_COST = 3;
const COPPER_AXE_WOOD_COST = 2;
const COPPER_AXE_XP = 25;
const COPPER_AXE_TIME_MS = 4000;

const COPPER_PICKAXE_BAR_COST = 4;
const COPPER_PICKAXE_WOOD_COST = 2;
const COPPER_PICKAXE_XP = 30;
const COPPER_PICKAXE_TIME_MS = 4500;

const IRON_AXE_BAR_COST = 3;
const IRON_AXE_WOOD_COST = 2;
const IRON_AXE_XP = 120;
const IRON_AXE_TIME_MS = 6000;

const IRON_PICKAXE_BAR_COST = 4;
const IRON_PICKAXE_WOOD_COST = 2;
const IRON_PICKAXE_XP = 140;
const IRON_PICKAXE_TIME_MS = 6500;

// --- NEW: Tool Tier Definitions ---
const PICKAXE_TIERS = { "Bronze Pickaxe": 1, "Copper Pickaxe": 2, "Iron Pickaxe": 3 };
const AXE_TIERS = { "Bronze Axe": 1, "Copper Axe": 2, "Iron Axe": 3 };

// --- NEW: Central Item Stat Definitions ---
const ITEM_STATS = {
  'Copper Helmet': {
    armor: 1
  },
  'Copper Chestplate': {
    armor: 2
  },
  'Copper Boots': {
    armor: 1
  },
  'Copper Shortsword': {
    damage: 1,
    styleBonus: 1, // Bonus for 'attack' style
    speed: 2
  },
  // --- NEW: Iron Item Stats ---
  'Iron Helmet': {
    armor: 2
  },
  'Iron Chestplate': {
    armor: 3
  },
  'Iron Boots': {
    armor: 2
  },
  'Iron Shortsword': {
    damage: 2,
    styleBonus: 1, // Bonus for 'attack' style
    speed: 2
  }
};
// --- END: Item Stat Definitions ---

function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) return n.toString();
  if (n < 1000000) return parseFloat((n / 1000).toFixed(2)) + 'k';
  return parseFloat((n / 1000000).toFixed(2)) + 'M';
}

function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  renderEquipment(); // <-- ADD THIS
  backToActions(); 
}

function updateHPUI(){
  // Calculate new maxHP based on Vitality level (1 HP per level starting at Lvl 1)
  game.maxHP = 10 + (game.vitality ? (game.vitality.level - 1) : 0);
  
  // Ensure current HP doesn't exceed max HP after a level up
  game.hp = Math.min(game.hp, game.maxHP); 
  
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}


/**
 * Calculates all player combat stats based on levels and equipment.
 */
function getPlayerCombatStats() {
  // 1. Base Stats from *Equipment Only*
  let stats = {
    equipmentDamage: 0, 
    equipmentArmor: 0, 
    equipmentSpeed: 0,
  };

  // 2. Add Equipment Bonuses
  for (const [slotType, item] of Object.entries(game.equipment)) {
    if (item && ITEM_STATS[item.name]) {
      const itemStats = ITEM_STATS[item.name];
      stats.equipmentDamage += itemStats.damage || 0;
      stats.equipmentArmor += itemStats.armor || 0;
      stats.equipmentSpeed += itemStats.speed || 0;

      // Special bonus for Copper Shortsword on 'attack' style
      if (item.name === 'Copper Shortsword' && game.playerAttackStyle === 'attack') {
        stats.equipmentDamage += itemStats.styleBonus || 0;
      }
      // +++ FIX: Check for Iron Shortsword +++
      if (item.name === 'Iron Shortsword' && game.playerAttackStyle === 'attack') {
        stats.equipmentDamage += itemStats.styleBonus || 0;
      }
      // +++ END FIX +++
    }
  }
  
  // 3. Calculate Final Stats (Base + Skills + Equipment)
  const finalStats = {};
  
  // --- NEW: Physical Damage ---
  // Skill-based damage is now uncapped: 1 + (Strength Lvl / 4)
  const skillMaxHit = 1 + Math.floor(game.strength.level / 4);
  
  // Final Max Hit = Skill Hit + Equipment Hit
  finalStats.physicalDamage = skillMaxHit + stats.equipmentDamage;

  // --- Armor ---
  // Base armor from Defence level (e.g., 1 per 5 levels)
  const skillArmor = Math.floor(game.defence.level / 5);
  finalStats.armor = skillArmor + stats.equipmentArmor;
  
  // --- Attack Speed ---
  const speedReduction = stats.equipmentSpeed * 300; // 0.3s per speed point
  finalStats.attackSpeed = Math.max(1200, 4000 - speedReduction); // 4.0s base
  
  // Also pass through the equipment-only bonuses for the UI display
  finalStats.equipmentDamage = stats.equipmentDamage;
  finalStats.equipmentArmor = stats.equipmentArmor;
  finalStats.equipmentSpeed = stats.equipmentSpeed; // <-- THIS LINE IS ADDED
  
  return finalStats;
}


/**
 * Renders the equipment in both the main sidebar and combat UI.
 */
function renderEquipment() {
  // --- 1. Calculate current stats ---
  const stats = getPlayerCombatStats();
  
  // --- 2. Update the Stats Display ---
  // Show *only* the bonus from equipment, as requested
  setText('stat-phys-dmg', `+${stats.equipmentDamage}`);
  setText('stat-armor', `+${stats.equipmentArmor}`);
  setText('stat-speed', `+${stats.equipmentSpeed}`); // <-- THIS LINE IS CHANGED

  // --- 3. Update Equipment Slots & Tooltips ---
  const slots = ['helmet', 'chest', 'weapon', 'boots'];
  const itemImageMap = {
    'Copper Helmet': 'copperhelmet',
    'Copper Chestplate': 'copperchestplate',
    'Copper Shortsword': 'coppershortsword',
    'Copper Boots': 'copperboots',
    'Iron Helmet': 'ironhelmet',
    'Iron Chestplate': 'ironchestplate',
    'Iron Shortsword': 'ironshortsword',
    'Iron Boots': 'ironboots'
  };

  slots.forEach(slotType => {
    const item = game.equipment[slotType];
    
    // Get the Main Sidebar Slot
    const mainSlotEl = document.getElementById(slotType);
    
    // Get the (optional) Combat UI Slot
    const combatSlotEl = document.getElementById(`combat-${slotType}`);
    
    let imgName = '';
    if (item) {
      imgName = itemImageMap[item.name];
    } else {
      // Use placeholder images
      if (slotType === 'helmet') imgName = 'helmet';
      if (slotType === 'chest') imgName = 'chestplate';
      if (slotType === 'weapon') imgName = 'weapon';
      if (slotType === 'boots') imgName = 'boots';
    }
    
    const imgHtml = `<img src="images/${imgName}.png" alt="${slotType}">`;
    const itemStats = item ? ITEM_STATS[item.name] : null;

    // --- Generate Stat Tooltip HTML ---
    let statsHtml = '';
    if (itemStats) {
      if (itemStats.damage) statsHtml += `<div style="color:#aaffaa;">+${itemStats.damage} Physical Damage</div>`;
      if (itemStats.styleBonus) statsHtml += `<div style="color:#aaffaa;">+${itemStats.styleBonus} Physical Damage (if accurate)</div>`;
      if (itemStats.armor) statsHtml += `<div style="color:#aaffaa;">+${itemStats.armor} Armor</div>`;
      if (itemStats.speed) statsHtml += `<div style="color:#aaffaa;">+${itemStats.speed} Speed</div>`;
    }

    // Update Main Sidebar Slot
    if (mainSlotEl) {
      mainSlotEl.innerHTML = imgHtml;
      mainSlotEl.onclick = () => unequipItem(slotType);
      
      if (item) {
        mainSlotEl.onmouseenter = (evt) => {
          const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
            ${statsHtml}
            <div style="color:#ffaaaa; margin-top: 5px;">Click to unequip...</div>
          `;
          showTooltip(evt, tooltipContent);
        };
        mainSlotEl.onmouseleave = hideTooltip;
      } else {
        mainSlotEl.onmouseenter = null;
        mainSlotEl.onmouseleave = null;
      }
    }
    
    // Update Combat UI Slot (if it exists)
    if (combatSlotEl) {
      combatSlotEl.innerHTML = imgHtml;
      combatSlotEl.onclick = null; 
      
      if (item) {
        combatSlotEl.onmouseenter = (evt) => {
           const tooltipContent = `
            <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
            ${statsHtml}
          `;
          showTooltip(evt, tooltipContent);
        };
        combatSlotEl.onmouseleave = hideTooltip;
      } else {
        combatSlotEl.onmouseenter = null;
        combatSlotEl.onmouseleave = null;
      }
    }
  });
}

function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount);
  updateGoldUI();
}

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;

  for(let i = 0; i < capacity; i++){
    const slotData = game.inventory[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    if(slotData){
      slot.draggable = true;
      const item = slotData;
      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      
      if (item.name === 'Copper Bar') {
          imgName = 'copperbar';
      } else if (item.name === 'Copper Chestplate') {
          imgName = 'copperchestplate';
      } else if (item.name === 'Copper Shortsword') {
          imgName = 'coppershortsword';
      } else if (item.name === 'Raw Chicken') {
          imgName = 'rawchicken'; 
      } else if (item.name === 'Copper Helmet') {
          imgName = 'copperhelmet';
      } else if (item.name === 'Copper Boots') {
          imgName = 'copperboots';
      } else if (item.name === 'Cooked Chicken') {
          imgName = 'cookedchicken';
      } else if (item.name === 'Burnt Chicken') {
          imgName = 'burntchicken';
      } else if (item.name === 'Coal Ore') {
          imgName = 'coalore';
      } else if (item.name === 'Iron Ore') {
          imgName = 'ironore';
      } else if (item.name === 'Iron Bar') {
          imgName = 'ironbar';
      } else if (item.name === 'Iron Helmet') {
          imgName = 'ironhelmet';
      } else if (item.name === 'Iron Chestplate') {
          imgName = 'ironchestplate';
      } else if (item.name === 'Iron Boots') {
          imgName = 'ironboots';
      } else if (item.name === 'Iron Shortsword') {
          imgName = 'ironshortsword';
      } else if (item.name === 'Softwood') {
          imgName = 'softwood';
      } else if (item.name === 'Oak') {
          imgName = 'oak';
      } else if (item.name === 'Bronze Pickaxe') { // +++ NEW +++
          imgName = 'bronzepickaxe';
      } else if (item.name === 'Bronze Axe') { // +++ NEW +++
          imgName = 'bronzeaxe';
      } else if (item.name === 'Copper Pickaxe') { // +++ NEW +++
          imgName = 'copperpickaxe';
      } else if (item.name === 'Copper Axe') { // +++ NEW +++
          imgName = 'copperaxe';
      } else if (item.name === 'Iron Pickaxe') { // +++ NEW +++
          imgName = 'ironpickaxe';
      } else if (item.name === 'Iron Axe') { // +++ NEW +++
          imgName = 'ironaxe';
      }
      
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      let clickAction = '';
      const stats = ITEM_STATS[itemName];

      if (stats) {
        // This is equipable
        if (stats.damage) itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to equip...</div>';
      
      } else if (itemName === 'Cooked Chicken') {
        // This is consumable
        itemStats = '<div style="color:#aaffaa; margin-top:4px;">+3 HP</div>';
        clickAction = '<div style="color:#aaffaa; margin-top: 5px;">Click to eat...</div>';
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
        ${itemStats}
        ${clickAction}
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      
      const itemQty = item.qty; 
      const slotIndex = i; 
      slot.onclick = (event) => {
        handleItemClick(event, itemName, itemQty, slotIndex);
      };
    } else {
      slot.draggable = false;
    }
    grid.appendChild(slot);
  }
}

// =================================================================
// --- 1. REPLACED 'addItem' FUNCTION (non-module script) ---
// This function now correctly handles multiple stacks.
// =================================================================
function addItem(name, qty = 1) {
  let amountToAdd = qty;

  // 1. Try to stack in existing slots first
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      slot.qty += amountToAdd;
      amountToAdd = 0;
      break; // Found a stack, stop looking
    }
  }

  // 2. If items are left (no existing stack found), find an empty slot
  if (amountToAdd > 0) {
    let emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex > -1) {
      game.inventory[emptySlotIndex] = { name: name, qty: amountToAdd };
      amountToAdd = 0;
    } else {
      console.warn(`Inventory full! Could not add ${amountToAdd} ${name}`);
      // Note: We don't return, so the inventory still renders
    }
  }

  if (!game.isDragging) {
    renderInventoryGrid();
  }
}

// =================================================================
// --- 2. REPLACED 'removeItem' FUNCTION (non-module script) ---
// This function now correctly removes from multiple stacks.
// =================================================================
function removeItem(name, qty = 1) {
  let amountToRemove = qty;
  let totalAvailable = 0;

  // 1. First, check if we even have enough across ALL stacks
  for (const slot of game.inventory) {
    if (slot && slot.name === name) {
      totalAvailable += slot.qty;
    }
  }

  if (totalAvailable < amountToRemove) {
    console.warn(`Tried to remove ${qty} ${name}, but only have ${totalAvailable}`);
    return false; // Not enough items
  }

  // 2. If we have enough, remove them. Iterate backwards is safer.
  for (let i = game.inventory.length - 1; i >= 0; i--) {
    const slot = game.inventory[i];
    if (slot && slot.name === name) {
      if (slot.qty > amountToRemove) {
        // This stack has more than we need
        slot.qty -= amountToRemove;
        amountToRemove = 0;
      } else {
        // This stack will be emptied
        amountToRemove -= slot.qty;
        game.inventory[i] = null; // Empty the slot
      }
    }
    if (amountToRemove === 0) break; // We're done
  }
  return true; // Successfully removed
}
// =================================================================
// --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
// =================================================================

async function handleSellItemClick(itemName, currentQty) {
  if (!game.shopOpen) return;
  let sellPrice = 0;
  if (itemName === 'Copper Ore') {
    sellPrice = 1;
  } else {
    await showGameAlert("Cannot Sell", "This shop doesn't buy that item."); // Replaced alert
    return;
  }
  
  let totalQty = 0;
  for (const slot of game.inventory) {
      if(slot && slot.name === itemName) {
          totalQty += slot.qty;
      }
  }

  let qtyToSell = 0;
  if (totalQty === 1) {
    qtyToSell = 1;
  } else {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Sell ${itemName}`, 
      `How many ${itemName} do you want to sell? (You have: ${totalQty})`, 
      totalQty
    );
    if (input === null) return;
    qtyToSell = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToSell) || qtyToSell <= 0) return;
  if (qtyToSell > totalQty) {
    await showGameAlert("Invalid Amount", "You don't have that many to sell."); // Replaced alert
    return;
  }
  
  const totalGold = qtyToSell * sellPrice;
  
  const confirmed = await showGameConfirm( // <-- USE 'await showGameConfirm'
    "Confirm Sale", 
    `Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`
  );
  
  if (confirmed) {
    if (removeItem(itemName, qtyToSell)) {
        addGold(totalGold);
        hideTooltip(); 
        renderInventoryGrid();
        if (game.inTrade) {
          renderTradeInventory();
        }
        await showGameAlert("Sale Complete", `You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`); // Replaced alert
    } else {
        await showGameAlert("Error", "Something went wrong, the sale did not complete."); // Replaced alert
    }
  }
}

function handleItemClick(event, itemName, itemQty, slotIndex) {
  // Always close any open menu first
  hideItemContextMenu();

  // --- NEW: Define equipable items and their slots ---
  const equipableItems = {
    'Copper Helmet': 'helmet',
    'Copper Chestplate': 'chest',
    'Copper Shortsword': 'weapon',
    'Copper Boots': 'boots',
    'Iron Helmet': 'helmet',
    'Iron Chestplate': 'chest',
    'Iron Shortsword': 'weapon',
    'Iron Boots': 'boots'
  };
  const itemSlotType = equipableItems[itemName];
  // --- END NEW ---

  if (game.shopOpen) {
    // If shop is open, we're selling
    handleSellItemClick(itemName, itemQty);
  } else if (itemSlotType) {
    // --- NEW: This is an equipable item! ---
    // We pass the slot *type* (e.g., 'helmet') and the inventory *index*
    equipItem(itemSlotType, slotIndex);
  } else if (itemName === 'Cooked Chicken') {
    // Not in shop, not equipable, and it's a chicken. Show eat menu.
    showItemContextMenu(event, itemName);
  }
  // Other items (like ores) do nothing when clicked.
}

// NEW: Shows the right-click-style menu
function showItemContextMenu(event, itemName) {
  const menu = document.getElementById('itemContextMenu');
  let menuContent = '';

  if (itemName === 'Cooked Chicken') {
    menuContent += `<button class="context-menu-btn" onclick="eatCookedChicken()">Eat</button>`;
  }
  
  // We can add other options here later (e.g., "Drop")
  
  if (menuContent) {
    menu.innerHTML = menuContent;
    menu.style.display = 'block';
    
    // Position menu near the cursor
    const rect = document.body.getBoundingClientRect();
    menu.style.left = (event.clientX - rect.left + 5) + 'px';
    menu.style.top = (event.clientY - rect.top + 5) + 'px';

    // Add a one-time listener to close the menu
    // Use setTimeout to skip this current click event
    setTimeout(() => {
      document.addEventListener('click', hideItemContextMenu, { once: true });
    }, 0);
  }
}

// NEW: Hides the item context menu
function hideItemContextMenu() {
  const menu = document.getElementById('itemContextMenu');
  if (menu) menu.style.display = 'none';
  // Remove the listener just in case (though {once: true} should handle it)
  document.removeEventListener('click', hideItemContextMenu);
}

// NEW: The logic for eating the chicken
async function eatCookedChicken() { // <-- ADD 'async'
  hideItemContextMenu(); // Close the menu

  // Check if HP is full
  if (game.hp >= game.maxHP) {
    await showGameAlert("HP Full", "Your HP is already full."); // <-- USE 'await showGameAlert'
    return;
  }

  // Try to remove the item. If successful, heal the player.
  if (removeItem('Cooked Chicken', 1)) {
    game.hp = Math.min(game.maxHP, game.hp + 3);
    updateHPUI();
    
    // --- NEW FIX: Re-render inventory and save ---
    renderInventoryGrid();
    if (typeof window.savePlayerData === 'function') {
        window.savePlayerData();
    }
    // --- END FIX ---

  } else {
    console.warn('Tried to eat Cooked Chicken, but removeItem failed.');
  }
}

/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
/**
 * Equips an item from the inventory.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 * @param {number} fromInvIndex - The inventory index the item is coming from
 */
async function equipItem(slotType, fromInvIndex) {
  const itemStack = game.inventory[fromInvIndex];
  if (!itemStack) return; // Item doesn't exist

  const itemBeingWorn = game.equipment[slotType]; // This is {qty: 1} or null

  // --- NEW: Check for inventory space BEFORE equipping ---
  if (itemBeingWorn) {
    // We need to unequip an item. Check if there's space for it.
    // Can it stack with the item we're equipping?
    const canStackOnSelf = (itemStack.name === itemBeingWorn.name);
    
    // Is there another stack of this item OR an empty slot?
    const hasStackingSlot = game.inventory.find(slot => slot && slot.name === itemBeingWorn.name && slot !== itemStack);
    const hasEmptySlot = game.inventory.some(slot => slot === null);

    // If the stack we're clicking is > 1 and it's not the same item,
    // we can't put the unequipped item back in this slot.
    if (itemStack.qty > 1 && !canStackOnSelf && !hasStackingSlot && !hasEmptySlot) {
      await showGameAlert("Inventory Full", "You have no room to unequip your currently worn item.");
      return;
    }
  }
  // --- END: Space Check ---

  // --- Stop combat to prevent errors ---
  const wasInCombat = game.inCombat;
  if (wasInCombat) {
    runFromCombat(false); // Stop loops
    const fightBtn = document.getElementById('combat-fight-btn');
    if (fightBtn) fightBtn.disabled = true;
  }
  // --- END NEW ---

  // 1. Create the new single item to wear
  const newItemToEquip = { name: itemStack.name, qty: 1 };
  
  // 2. Put the new item on the character
  game.equipment[slotType] = newItemToEquip;
  
  // 3. Decrement the inventory stack
  itemStack.qty -= 1;

  // 4. Handle the leftovers
  if (itemStack.qty <= 0) {
    // The stack is empty. Put the old item (or null) in its place.
    game.inventory[fromInvIndex] = itemBeingWorn;
  } else if (itemBeingWorn) {
    // The stack is NOT empty. We must add the old item back.
    // Use the "smart" unequip logic: try to stack first, then find empty slot.
    let stacked = false;
    for (const slot of game.inventory) {
      if (slot && slot.name === itemBeingWorn.name) {
        slot.qty += 1;
        stacked = true;
        break;
      }
    }
    if (!stacked) {
      // We already checked for an empty slot, so this is safe.
      const emptySlot = game.inventory.findIndex(s => s === null);
      if (emptySlot !== -1) {
         game.inventory[emptySlot] = itemBeingWorn;
      }
    }
  }
  
  // 5. Re-render everything
  renderEquipment(); // This will update stats
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 6. Restart combat if we were in it
  if (wasInCombat) {
    setTimeout(() => {
      beginCombat(); // Restart with new stats
    }, 50);
  }
}

/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
/**
 * Unequips an item from the equipment slot.
 * @param {string} slotType - The type of slot ('helmet', 'chest', 'weapon', 'boots')
 */
async function unequipItem(slotType) {
  const itemToUnequip = game.equipment[slotType];
  if (!itemToUnequip) return; // Slot is already empty

  // --- NEW: Smart unequip logic ---
  // 1. Try to find an existing stack to add to
  let stacked = false;
  for (const slot of game.inventory) {
    if (slot && slot.name === itemToUnequip.name) {
      slot.qty += 1;
      stacked = true;
      break;
    }
  }

  // 2. If not stacked, find an empty slot
  if (!stacked) {
    const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex === -1) {
      // Inventory is full
      await showGameAlert("Inventory Full", "You can't unequip this, your inventory is full.");
      return;
    }
    // Put item in the empty slot
    game.inventory[emptySlotIndex] = itemToUnequip;
  }
  // --- END: Smart unequip logic ---


  // --- Stop combat to prevent errors ---
  const wasInCombat = game.inCombat;
  if (wasInCombat) {
    runFromCombat(false); // Stop loops
    const fightBtn = document.getElementById('combat-fight-btn');
    if (fightBtn) fightBtn.disabled = true;
  }
  // --- END NEW ---
  
  // 3. Clear the equipment slot (since item is safely in inventory)
  game.equipment[slotType] = null; 
  
  // 4. Re-render everything
  renderEquipment(); // This will update stats
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 5. Restart combat if we were in it
  if (wasInCombat) {
    setTimeout(() => {
      beginCombat(); // Restart with new stats
    }, 50);
  }
}

const tooltip = document.getElementById('tooltip');
function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}
function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}
function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){
    // level is the CURRENT level (1-100)
    
    // Safety check for levels beyond the table
    if (level >= XP_TABLE.length) {
        return 0; 
    }

    // XP_TABLE[level] holds the total XP for level + 1
    const xpNeededForNextLevel = XP_TABLE[level]; 
    
    // XP_TABLE[level - 1] holds the total XP for the current level
    const xpAlreadyGained = XP_TABLE[level - 1] || 0; 

    return xpNeededForNextLevel - xpAlreadyGained;
}

function getTotalXPForLevel(level) {
    // level is the level we want the *cumulative* XP for (1-100)

    // The XP_TABLE is 0-indexed: Lvl 1 total XP is at index 0.
    const index = Math.min(level - 1, XP_TABLE.length - 1);

    return XP_TABLE[index] || 0;
}

function updateSkillUI(){
  const skillsTab = document.getElementById('skillsTab');
  if (!skillsTab) return;
  
  // Clear the tab and set up the header/container
  skillsTab.innerHTML = `
    <div style="font-size:14px; margin-bottom:12px;">Skills</div>
    <div id="skillIconsContainer" style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: flex-start;">
      </div>
  `;

  const container = document.getElementById('skillIconsContainer');

  /**
   * Helper function to create a skill icon with a tooltip
   * @param {string} skillName - The display name (e.g., "Mining")
   * @param {string} skillDataKey - The key in the game object (e.g., "mining")
   * @param {string} iconFileName - The name of the icon file in /images/
   */
  const createSkillIcon = (skillName, skillDataKey, iconFileName) => {
    const data = game[skillDataKey];
    const iconWrapper = document.createElement('button');
    iconWrapper.className = 'primary'; // Use 'primary' class for base styling
    iconWrapper.style.cssText = `
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 5px; 
      padding: 8px 10px; 
      height: 80px; /* Fixed height for consistency */
      width: 80px;  /* Fixed width for consistency */
      justify-content: center;
      font-size: 13px;
      background: var(--accent);
      border: 2px solid #50311f; /* Added a border to define the button */
      transition: all 0.15s ease;
    `;
    
    // --- Create the tooltip content ---
    const nextXP = getNextXP(data.level);
    // Calculate progress percentage, ensuring it doesn't exceed 100%
    const progressPercent = Math.min(100, (data.xp / nextXP) * 100);
    
    const tooltipContent = `
      <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${skillName}</div>
      <div style="font-size: 14px; margin-bottom: 6px;">Level: <span style="font-weight: bold;">${data.level}</span></div>
      <div>XP: ${data.xp.toLocaleString()} / ${nextXP.toLocaleString()}</div>
      <div>(Total XP: ${data.totalXP.toLocaleString()})</div>
      
      <div style="width: 100%; height: 8px; background: #555; border-radius: 4px; margin-top: 8px; border: 1px solid #333;">
        <div style="height: 100%; width: ${progressPercent}%; background: #4caf50; border-radius: 4px; transition: width 0.2s;"></div>
      </div>
    `;

    // Set up hover/tooltip events
    iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
    iconWrapper.onmouseleave = hideTooltip;

    // Create and append icon image
    const img = document.createElement('img');
    img.src = `images/${iconFileName}`;
    img.alt = skillName;
    img.style.cssText = 'width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; pointer-events: none;';
    img.onerror = function(){ this.style.opacity='0.1'; this.style.filter='grayscale(100%)'; }; // Fallback
    iconWrapper.appendChild(img);

    // Append level text
    const levelText = document.createElement('span');
    levelText.innerText = `Lvl ${data.level}`;
    levelText.style.fontWeight = 'bold';
    levelText.style.pointerEvents = 'none';
    iconWrapper.appendChild(levelText);

    container.appendChild(iconWrapper);
  };

  // --- Call the function for each of your skills ---
  createSkillIcon('Mining', 'mining', 'miningskillicon.png');
  createSkillIcon('Blacksmith', 'blacksmith', 'blacksmithskillicon.png');
  createSkillIcon('Attack', 'attack', 'attackskillicon.png'); 
  createSkillIcon('Strength', 'strength', 'strengthskillicon.png'); 
  createSkillIcon('Defence', 'defence', 'defenseskillicon.png'); 
  createSkillIcon('Vitality', 'vitality', 'vitalityskillicon.png'); // +++ NEW VITALITY SKILL CALL +++
  createSkillIcon('Cooking', 'cooking', 'cookingskillicon.png'); // +++ NEW COOKING SKILL CALL +++
  createSkillIcon('Woodcutting', 'woodcutting', 'woodcuttingskillicon.png'); // +++ NEW WOODCUTTING SKILL CALL +++
}

function showItemPopup(text, progressElementId, delay = 0) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.innerHTML = text; // Allow HTML
popup.style.lineHeight = '1.4';
    const bar = document.getElementById(progressElementId);
    if (bar) {
        const barRect = bar.getBoundingClientRect();
        const mainRect = main.getBoundingClientRect();
        const relativeX = barRect.left - mainRect.left;
        const relativeY = barRect.top - mainRect.top;
        popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
        popup.style.top = (relativeY - 30) + 'px';
    } else {
        popup.style.left = '50%';
        popup.style.top = '120px';
        popup.style.transform = 'translateX(-50%)';
    }
    if (delay > 0) {
    setTimeout(() => {
      main.appendChild(popup);
      setTimeout(() => popup.remove(), 850); // 850 to match splat
    }, delay);
  } else {
    main.appendChild(popup);
    setTimeout(() => popup.remove(), 850); // 850 to match splat
  }
}

function addXP(skill, amount, delay = 0){
  if (!game[skill]) {
      console.warn(`Skill "${skill}" does not exist.`);
      return;
  }
  game[skill].totalXP += amount; 
  game[skill].xp += amount;
  
  let leveledUp = false; // --- NEW: Add a flag ---
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
    leveledUp = true; // --- NEW: Set the flag ---
  }
  
  // --- NEW: Check if vitality leveled up and update HP ---
  if (leveledUp && skill === 'vitality') {
    updateHPUI();
  }
  // --- END NEW ---

  updateSkillUI();
  let barId = '';
  if (skill === 'mining') barId = 'mineProgress';
  if (skill === 'blacksmith') barId = 'smithProgress';
  if (skill === 'woodcutting') barId = 'woodcutProgress'; // +++ NEW +++
  if (skill !== 'blacksmith' && skill !== 'mining' && skill !== 'cooking' && skill !== 'woodcutting') { // Don't show popup for skilling actions
    if (delay > 0) {
      setTimeout(() => {
        showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
      }, delay);
    } else {
      showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
    }
 }

 }

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

/**
* NEW: A reusable loop to show a cooldown timer in the mining UI.
 * @param {number} timestamp - The current frame's timestamp.
 * @param {number} startTime - The timestamp when the cooldown began.
 * @param {number} duration - The total duration of the cooldown (in ms).
 * @param {string} progressTextId - The ID of the text element (e.g., 'mineProgressText').
 * @param {function} nextLoopFunction - The mining loop to call when finished (e.g., miningLoop).
 */

function miningCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.miningActive) { // Check if stop was pressed
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = timestamp - startTime;
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    // Cooldown finished, clear text and start the next mining loop
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    game.progressFrame = requestAnimationFrame((now) => nextLoopFunction(now, now));
  } else {
    // Cooldown active, update timer
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    // Continue the cooldown loop
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, startTime, duration, progressTextId, nextLoopFunction)
    );
  }
}

// --- MODIFIED: Added Session Lock Check ---
async function startMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(MINE_ITEM, 1); // Uses new addItem
    addXP('mining', MINE_XP); // This now adds XP without a popup

    // NEW: Create two separate, delayed popups
    showItemPopup(`+${MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 Copper Ore`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_COPPER_MS, 'mineProgressText', miningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, startTime));
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const textEl = document.getElementById('mineProgressText'); // <-- ADD THIS
  if (textEl) textEl.innerText = '';                        // <-- ADD THIS

  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// +++ NEW CRAFTING FUNCTION BLOCK TO INSERT +++
const CHESTPLATE_TIME_MS = 10000; 

// +++ END NEW CRAFTING FUNCTION +++


// +++ END NEW SHORTSWORD CRAFTING FUNCTION +++

function openCopperHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${HELMET_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn'); 
  showMainScreen('hubDynamic');
}
// +++ END NEW HELMET CRAFTING FUNCTION +++

// +++ NEW COPPER BOOTS UI +++
function openCopperBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${BOOTS_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn'); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') {
          totalBars += slot.qty;
      }
  }

  if (totalBars < BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${BOOTS_BAR_COST} Copper Bars to craft boots.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, now));
}

async function bootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / BOOTS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBars += slot.qty;
        }
    }
    if (totalBars < BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Bar', BOOTS_BAR_COST);
    addItem('Copper Boots', 1);
    addXP('blacksmith', BOOTS_XP);
    
    showItemPopup(`+${BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Copper Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') {
            totalBarsAfter += slot.qty;
        }
    }
    if (totalBarsAfter < BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => bootsCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Bar Crafting Logic ---
async function startIronBarCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalIronOre = 0;
  let totalCoalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
      if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
  }

  if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BAR_ORE_COST} Iron Ore and ${IRON_BAR_COAL_COST} Coal Ore.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, now));
}


async function ironBarCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_BAR_TIME_MS) * 100;

  if (progress >= 100) {
    let totalIronOre = 0;
    let totalCoalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronOre += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalOre += slot.qty;
    }
    if (totalIronOre < IRON_BAR_ORE_COST || totalCoalOre < IRON_BAR_COAL_COST) {
        await showGameAlert("Out of Materials", "You've run out of ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Ore', IRON_BAR_ORE_COST);
    removeItem('Coal Ore', IRON_BAR_COAL_COST);
    addItem('Iron Bar', 1);
    addXP('blacksmith', IRON_BAR_XP);
    
    showItemPopup(`+${IRON_BAR_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Iron Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    let totalIronAfter = 0;
    let totalCoalAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Ore') totalIronAfter += slot.qty;
        if (slot && slot.name === 'Coal Ore') totalCoalAfter += slot.qty;
    }
    if (totalIronAfter < IRON_BAR_ORE_COST || totalCoalAfter < IRON_BAR_COAL_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironBarCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Helmet Crafting Logic ---
async function startIronHelmetCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_HELMET_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_HELMET_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startHelmetBtn');
  const stopBtn = document.getElementById('stopHelmetBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, now));
}


async function ironHelmetCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_HELMET_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_HELMET_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_HELMET_BAR_COST);
    addItem('Iron Helmet', 1);
    addXP('blacksmith', IRON_HELMET_XP);
    
    showItemPopup(`+${IRON_HELMET_XP} Blacksmith XP`, 'helmetProgress', 0);
    showItemPopup(`+1 Iron Helmet`, 'helmetProgress', 450);
    
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_HELMET_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another helmet.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('helmetProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironHelmetCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Chestplate Crafting Logic ---
async function startIronChestplateCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_CHESTPLATE_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_CHESTPLATE_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startChestplateBtn');
  const stopBtn = document.getElementById('stopChestplateBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, now));
}

async function ironChestplateCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_CHESTPLATE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_CHESTPLATE_BAR_COST);
    addItem('Iron Chestplate', 1);
    addXP('blacksmith', IRON_CHESTPLATE_XP);
    
    showItemPopup(`+${IRON_CHESTPLATE_XP} Blacksmith XP`, 'chestplateProgress', 0);
    showItemPopup(`+1 Iron Chestplate`, 'chestplateProgress', 450);
    
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_CHESTPLATE_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another chestplate.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('chestplateProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironChestplateCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Boots Crafting Logic ---
async function startIronBootsCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_BOOTS_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_BOOTS_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startBootsBtn');
  const stopBtn = document.getElementById('stopBootsBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, now));
}


async function ironBootsCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_BOOTS_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_BOOTS_BAR_COST);
    addItem('Iron Boots', 1);
    addXP('blacksmith', IRON_BOOTS_XP);
    
    showItemPopup(`+${IRON_BOOTS_XP} Blacksmith XP`, 'bootsProgress', 0);
    showItemPopup(`+1 Iron Boots`, 'bootsProgress', 450);
    
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = '0%';
    
    let totalBarsAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_BOOTS_BAR_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough bars to craft more boots.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, now));
  } else {
    const bar = document.getElementById('bootsProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironBootsCraftingLoop(now, startTime));
  }
}

// --- NEW: Iron Shortsword Crafting Logic ---
async function startIronShortswordCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
  }

  if (totalBars < IRON_SHORTSWORD_BAR_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${IRON_SHORTSWORD_BAR_COST} Iron Bars.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startShortswordBtn');
  const stopBtn = document.getElementById('stopShortswordBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, now));
}


async function ironShortswordCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_SHORTSWORD_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
    }
    if (totalBars < IRON_SHORTSWORD_BAR_COST) {
        await showGameAlert("Out of Materials", "You've run out of Iron Bars.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Iron Bar', IRON_SHORTSWORD_BAR_COST);
    addItem('Iron Shortsword', 1);
    addXP('blacksmith', IRON_SHORTSWORD_XP);
    
    showItemPopup(`+${IRON_SHORTSWORD_XP} Blacksmith XP`, 'shortswordProgress', 0);
    showItemPopup(`+1 Iron Shortsword`, 'shortswordProgress', 450);
    
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = '0%';
    
   // Check for materials for the *next* loop
let totalBarsAfter = 0;
for (const slot of game.inventory) {
    if (slot && slot.name === 'Iron Bar') {
        totalBarsAfter += slot.qty;
    }
}
if (totalBarsAfter < IRON_SHORTSWORD_BAR_COST) {
    await showGameAlert("Not Enough Materials", "You don't have enough bars to craft another shortsword.");
    stopBlacksmithing();
    return;
}
// Continue looping
game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, now));

  } else {
    const bar = document.getElementById('shortswordProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironShortswordCraftingLoop(now, startTime));
  }
}

const SMITH_TIME_MS = 5000;
const SMITH_XP = 25;
const SMITH_ORE_COST = 2;
const SMITH_BAR_ITEM = 'Copper Bar';

// --- MODIFIED: Added Session Lock Check ---
async function startBlacksmithing() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalOre = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Ore') {
          totalOre += slot.qty;
      }
  }

  if (totalOre < SMITH_ORE_COST) {
      await showGameAlert("Not Enough Materials", `You need at least ${SMITH_ORE_COST} Copper Ore to smith a bar.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
}

async function blacksmithingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SMITH_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check total ore again ---
    let totalOre = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOre += slot.qty;
        }
    }
    if (totalOre < SMITH_ORE_COST) {
        await showGameAlert("Out of Materials", "You've run out of Copper Ore.");
        stopBlacksmithing();
        return;
    }
    
    removeItem('Copper Ore', SMITH_ORE_COST); // Uses new removeItem
    addItem(SMITH_BAR_ITEM, 1); // Uses new addItem
    addXP('blacksmith', SMITH_XP); // This now adds XP without a popup
    
    // NEW: Create two separate, delayed popups
    showItemPopup(`+${SMITH_XP} Blacksmith XP`, 'smithProgress', 0);
    showItemPopup(`+1 Copper Bar`, 'smithProgress', 450);
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalOreAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Ore') {
            totalOreAfter += slot.qty;
        }
    }
    if (totalOreAfter < SMITH_ORE_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, startTime));
  }
}

function stopBlacksmithing(progressId = 'smithProgress', startBtnId = 'startSmithBtn', stopBtnId = 'stopSmithBtn'){
  game.blacksmithingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById(progressId);
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById(startBtnId);
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById(stopBtnId);
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

const COOK_CHICKEN_TIME_MS = 3000;
const COOK_CHICKEN_XP = 30;

// --- NEW COOKING FUNCTIONS ---
async function startCookingChicken() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.cookingActive) return;

  // --- Check for Raw Chicken ---
  let totalRaw = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Raw Chicken') {
          totalRaw += slot.qty;
      }
  }

  if (totalRaw < 1) {
      await showGameAlert("Not Enough Materials", `You need at least 1 Raw Chicken to cook.`);
      return;
  }
  
  game.cookingActive = true;
  const startBtn = document.getElementById('startCookBtn');
  const stopBtn = document.getElementById('stopCookBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
}

async function cookingChickenLoop(timestamp, startTime) {
  if (!game.cookingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COOK_CHICKEN_TIME_MS) * 100;

  if (progress >= 100) {
    // --- Check materials again ---
    let totalRaw = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRaw += slot.qty;
        }
    }
    if (totalRaw < 1) {
        await showGameAlert("Out of Materials", "You've run out of Raw Chicken.");
        stopCookingChicken();
        return;
    }
    
    removeItem('Raw Chicken', 1); // Consume 1 raw chicken
    addXP('cooking', COOK_CHICKEN_XP); // Always award XP (no popup thanks to Step 1)
    
    // Calculate success rate (50% at Lvl 1, 100% at Lvl 10)
    const successRate = Math.min(100, 50 + ((game.cooking.level - 1) * (50/9)));
    
    // NEW: Create two separate, delayed popups
    if (Math.random() * 100 < successRate) {
      // Success
      addItem('Cooked Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Cooked Chicken`, 'cookProgress', 450);
    } else {
      // Burnt
      addItem('Burnt Chicken', 1);
      showItemPopup(`+${COOK_CHICKEN_XP} Cooking XP`, 'cookProgress', 0);
      showItemPopup(`+1 Burnt Chicken`, 'cookProgress', 450);
    }
    
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = '0%';
    
    // --- Check *again* for next loop ---
    let totalRawAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Raw Chicken') {
            totalRawAfter += slot.qty;
        }
    }
    if (totalRawAfter < 1) {
        await showGameAlert("Not Enough Materials", "You don't have any more Raw Chicken to cook.");
        stopCookingChicken();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, now));
  } else {
    const bar = document.getElementById('cookProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => cookingChickenLoop(now, startTime));
  }
}

function stopCookingChicken(){
  game.cookingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('cookProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startCookBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopCookBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function openCookChicken(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing(); // Also stop smithing
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Cooking - Chicken</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 1 Raw Chicken.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="cookProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startCookBtn" class="primary">Start Cooking</button>
      <button id="stopCookBtn" class="primary" style="background:#555; display:none;">Stop Cooking</button>
      <button onclick="openKitchenHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startCookBtn').onclick = startCookingChicken;
  document.getElementById('stopCookBtn').onclick = stopCookingChicken;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

function openKitchenHub() {
  showMainScreen('hubKitchen');
}

function openCopperBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 2 Copper Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startBlacksmithing;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// +++ NEW COPPER CHESTPLATE UI +++
function openCopperChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${CHESTPLATE_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER CHESTPLATE UI +++

// +++ NEW COPPER SHORTSWORD UI +++
function openCopperShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${SHORTSWORD_BAR_COST} Copper Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
// +++ END NEW COPPER SHORTSWORD UI +++

// --- NEW: Iron Bar UI ---
function openIronBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startIronBarCrafting;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Helmet UI ---
function openIronHelmetSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Helmet</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_HELMET_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="helmetProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startHelmetBtn" class="primary">Start Crafting</button>
      <button id="stopHelmetBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startHelmetBtn').onclick = startIronHelmetCrafting;
  document.getElementById('stopHelmetBtn').onclick = () => stopBlacksmithing('helmetProgress', 'startHelmetBtn', 'stopHelmetBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Chestplate UI ---
function openIronChestplateSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Chestplate</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="chestplateProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChestplateBtn" class="primary">Start Crafting</button>
      <button id="stopChestplateBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChestplateBtn').onclick = startIronChestplateCrafting;
  document.getElementById('stopChestplateBtn').onclick = () => stopBlacksmithing('chestplateProgress', 'startChestplateBtn', 'stopChestplateBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Boots UI ---
function openIronBootsSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Boots</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_BOOTS_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="bootsProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startBootsBtn" class="primary">Start Crafting</button>
      <button id="stopBootsBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startBootsBtn').onclick = startIronBootsCrafting;
  document.getElementById('stopBootsBtn').onclick = () => stopBlacksmithing('bootsProgress', 'startBootsBtn', 'stopBootsBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Shortsword UI ---
function openIronShortswordSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Shortsword</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="shortswordProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startShortswordBtn" class="primary">Start Crafting</button>
      <button id="stopShortswordBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startShortswordBtn').onclick = startIronShortswordCrafting;
  document.getElementById('stopShortswordBtn').onclick = () => stopBlacksmithing('shortswordProgress', 'startShortswordBtn', 'stopShortswordBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
  }

// +++ NEW: COPPER AXE UI +++
function openCopperAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startCopperAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// This is the logic function, now separate
async function startCopperAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_AXE_BAR_COST} Copper Bars and ${COPPER_AXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, now));
}

async function copperAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_AXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_AXE_BAR_COST || totalWood < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_AXE_BAR_COST);
    removeItem('Softwood', COPPER_AXE_WOOD_COST);
    addItem('Copper Axe', 1);
    addXP('blacksmith', COPPER_AXE_XP);
    
    showItemPopup(`+${COPPER_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Copper Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_AXE_BAR_COST || totalWoodAfter < COPPER_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, now));
  } else {
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => copperAxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: COPPER PICKAXE UI +++
function openCopperPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Copper Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startCopperPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startCopperPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Softwood') totalWood += slot.qty;
  }

  if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${COPPER_PICKAXE_BAR_COST} Copper Bars and ${COPPER_PICKAXE_WOOD_COST} Softwood.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, now));
}

async function copperPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COPPER_PICKAXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Softwood') totalWood += slot.qty;
    }
    if (totalBars < COPPER_PICKAXE_BAR_COST || totalWood < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Copper Bar', COPPER_PICKAXE_BAR_COST);
    removeItem('Softwood', COPPER_PICKAXE_WOOD_COST);
    addItem('Copper Pickaxe', 1);
    addXP('blacksmith', COPPER_PICKAXE_XP);
    
    showItemPopup(`+${COPPER_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Copper Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Copper Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Softwood') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < COPPER_PICKAXE_BAR_COST || totalWoodAfter < COPPER_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, now));
  } else {
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => copperPickaxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: IRON AXE UI +++
function openIronAxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Axe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="axeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startAxeBtn" class="primary">Start Crafting</button>
      <button id="stopAxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startAxeBtn').onclick = startIronAxeCrafting;
  document.getElementById('stopAxeBtn').onclick = () => stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronAxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_AXE_BAR_COST} Iron Bars and ${IRON_AXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startAxeBtn').style.display = 'none';
  document.getElementById('stopAxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, now));
}

async function ironAxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_AXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_AXE_BAR_COST || totalWood < IRON_AXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_AXE_BAR_COST);
    removeItem('Oak', IRON_AXE_WOOD_COST);
    addItem('Iron Axe', 1);
    addXP('blacksmith', IRON_AXE_XP);
    
    showItemPopup(`+${IRON_AXE_XP} Blacksmith XP`, 'axeProgress', 0);
    showItemPopup(`+1 Iron Axe`, 'axeProgress', 450);
    
    document.getElementById('axeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_AXE_BAR_COST || totalWoodAfter < IRON_AXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('axeProgress', 'startAxeBtn', 'stopAxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, now));
  } else {
    document.getElementById('axeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironAxeCraftingLoop(now, startTime));
  }
}

// +++ NEW: IRON PICKAXE UI +++
function openIronPickaxeSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Smithing - Iron Pickaxe</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="pickaxeProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startPickaxeBtn" class="primary">Start Crafting</button>
      <button id="stopPickaxeBtn" class="primary" style="background:#555; display:none;">Stop Crafting</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startPickaxeBtn').onclick = startIronPickaxeCrafting;
  document.getElementById('stopPickaxeBtn').onclick = () => stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

async function startIronPickaxeCrafting() {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  let totalBars = 0;
  let totalWood = 0;
  for (const slot of game.inventory) {
      if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
      if (slot && slot.name === 'Oak') totalWood += slot.qty;
  }

  if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
      await showGameAlert("Not Enough Materials", `You need ${IRON_PICKAXE_BAR_COST} Iron Bars and ${IRON_PICKAXE_WOOD_COST} Oak.`);
      return;
  }
  
  game.blacksmithingActive = true;
  document.getElementById('startPickaxeBtn').style.display = 'none';
  document.getElementById('stopPickaxeBtn').style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, now));
}

async function ironPickaxeCraftingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_PICKAXE_TIME_MS) * 100;

  if (progress >= 100) {
    let totalBars = 0;
    let totalWood = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBars += slot.qty;
        if (slot && slot.name === 'Oak') totalWood += slot.qty;
    }
    if (totalBars < IRON_PICKAXE_BAR_COST || totalWood < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Out of Materials", "You've run out of materials.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    
    removeItem('Iron Bar', IRON_PICKAXE_BAR_COST);
    removeItem('Oak', IRON_PICKAXE_WOOD_COST);
    addItem('Iron Pickaxe', 1);
    addXP('blacksmith', IRON_PICKAXE_XP);
    
    showItemPopup(`+${IRON_PICKAXE_XP} Blacksmith XP`, 'pickaxeProgress', 0);
    showItemPopup(`+1 Iron Pickaxe`, 'pickaxeProgress', 450);
    
    document.getElementById('pickaxeProgress').style.width = '0%';
    
    let totalBarsAfter = 0;
    let totalWoodAfter = 0;
    for (const slot of game.inventory) {
        if (slot && slot.name === 'Iron Bar') totalBarsAfter += slot.qty;
        if (slot && slot.name === 'Oak') totalWoodAfter += slot.qty;
    }
    if (totalBarsAfter < IRON_PICKAXE_BAR_COST || totalWoodAfter < IRON_PICKAXE_WOOD_COST) {
        await showGameAlert("Not Enough Materials", "You don't have enough materials to craft another.");
        stopBlacksmithing('pickaxeProgress', 'startPickaxeBtn', 'stopPickaxeBtn');
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, now));
  } else {
    document.getElementById('pickaxeProgress').style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironPickaxeCraftingLoop(now, startTime));
  }
}

// +++ END NEW COPPER SHORTSWORD UI +++

function openBlacksmithHub() {
  showMainScreen('hubBlacksmith');
}

function renderSmithingItems(metalType) {
  const container = document.getElementById('smithingItemsContainer');
  if (!container) return;
  
  const smithLvl = game.blacksmith.level;
  
  // --- Helper function for locked buttons (moved inside) ---
  const setupSmithButton = (btnId, locked, onclick, levelReq, tooltipText, itemName) => { // Added itemName
    const btn = document.getElementById(btnId);
    if (btn) {
      // Create the new tooltip header
      const nameHtml = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">${itemName}</div>`;
      
      if (locked) {
        btn.onclick = null;
        // Add name to the locked tooltip
        const lockedTT = nameHtml + `Requires Blacksmith Lvl: ${levelReq}`;
        btn.onmouseenter = (event) => showTooltip(event, lockedTT);
      } else {
        btn.onclick = onclick;
        // Add name to the unlocked tooltip
        const unlockedTT = nameHtml + tooltipText;
        btn.onmouseenter = (event) => showTooltip(event, unlockedTT);
      }
      btn.onmouseleave = hideTooltip;
    }
  };
  
  if (metalType === 'copper') {
    // --- Copper Level Locks ---
    const copperBarLocked = smithLvl < COPPER_BAR_LVL;
    const copperPickaxeLocked = smithLvl < COPPER_PICKAXE_LVL; // +++ NEW +++
    const copperAxeLocked = smithLvl < COPPER_AXE_LVL;       // +++ NEW +++
    const copperSwordLocked = smithLvl < COPPER_SWORD_LVL;
    const copperBootsLocked = smithLvl < COPPER_BOOTS_LVL;
    const copperHelmetLocked = smithLvl < COPPER_HELMET_LVL;
    const copperChestLocked = smithLvl < COPPER_CHEST_LVL;
    
    container.innerHTML = `
      <button id="copperBarBtn" class="primary ${copperBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperbar.png" alt="Copper Bar" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperPickaxeBtn" class="primary ${copperPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperpickaxe.png" alt="Copper Pickaxe" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperAxeBtn" class="primary ${copperAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperaxe.png" alt="Copper Axe" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperShortswordBtn" class="primary ${copperSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/coppershortsword.png" alt="Copper Shortsword" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperBootsBtn" class="primary ${copperBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperboots.png" alt="Copper Boots" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperHelmetBtn" class="primary ${copperHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperhelmet.png" alt="Copper Helmet" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="copperChestplateBtn" class="primary ${copperChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/copperchestplate.png" alt="Copper Chestplate" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for copper items ---
    setupSmithButton('copperBarBtn', copperBarLocked, openCopperBarSmith, COPPER_BAR_LVL, 'Requires: 2 Copper Ore', 'Copper Bar');
    setupSmithButton('copperPickaxeBtn', copperPickaxeLocked, openCopperPickaxeSmith, COPPER_PICKAXE_LVL, `Requires: ${COPPER_PICKAXE_BAR_COST} Copper Bars, ${COPPER_PICKAXE_WOOD_COST} Softwood`, 'Copper Pickaxe');
    setupSmithButton('copperAxeBtn', copperAxeLocked, openCopperAxeSmith, COPPER_AXE_LVL, `Requires: ${COPPER_AXE_BAR_COST} Copper Bars, ${COPPER_AXE_WOOD_COST} Softwood`, 'Copper Axe');
    setupSmithButton('copperShortswordBtn', copperSwordLocked, openCopperShortswordSmith, COPPER_SWORD_LVL, `Requires: ${SHORTSWORD_BAR_COST} Copper Bars`, 'Copper Shortsword');
    setupSmithButton('copperBootsBtn', copperBootsLocked, openCopperBootsSmith, COPPER_BOOTS_LVL, `Requires: ${BOOTS_BAR_COST} Copper Bars`, 'Copper Boots');
    setupSmithButton('copperHelmetBtn', copperHelmetLocked, openCopperHelmetSmith, COPPER_HELMET_LVL, `Requires: ${HELMET_BAR_COST} Copper Bars`, 'Copper Helmet');
    setupSmithButton('copperChestplateBtn', copperChestLocked, openCopperChestplateSmith, COPPER_CHEST_LVL, `Requires: ${CHESTPLATE_BAR_COST} Copper Bars`, 'Copper Chestplate');
    
  } else if (metalType === 'iron') {
    // --- Iron Level Locks ---
    const ironBarLocked = smithLvl < IRON_BAR_LVL;
    const ironPickaxeLocked = smithLvl < IRON_PICKAXE_LVL; // +++ NEW +++
    const ironAxeLocked = smithLvl < IRON_AXE_LVL;       // +++ NEW +++
    const ironSwordLocked = smithLvl < IRON_SWORD_LVL;
    const ironBootsLocked = smithLvl < IRON_BOOTS_LVL;
    const ironHelmetLocked = smithLvl < IRON_HELMET_LVL;
    const ironChestLocked = smithLvl < IRON_CHEST_LVL;
    
    container.innerHTML = `
      <button id="ironBarBtn" class="primary ${ironBarLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironbar.png" alt="Iron Bar" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironPickaxeBtn" class="primary ${ironPickaxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironpickaxe.png" alt="Iron Pickaxe" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironAxeBtn" class="primary ${ironAxeLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironaxe.png" alt="Iron Axe" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironShortswordBtn" class="primary ${ironSwordLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironshortsword.png" alt="Iron Shortsword" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironBootsBtn" class="primary ${ironBootsLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironboots.png" alt="Iron Boots" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironHelmetBtn" class="primary ${ironHelmetLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironhelmet.png" alt="Iron Helmet" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
      <button id="ironChestplateBtn" class="primary ${ironChestLocked ? 'locked-item' : ''}" style="width: var(--slot-size); height: var(--slot-size); display: flex; align-items: center; justify-content: center; padding: 0;">
        <img src="images/ironchestplate.png" alt="Iron Chestplate" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
      </button>
    `;
    
    // --- Re-attach listeners for iron items ---
    setupSmithButton('ironBarBtn', ironBarLocked, openIronBarSmith, IRON_BAR_LVL, `Requires: ${IRON_BAR_ORE_COST} Iron Ore, ${IRON_BAR_COAL_COST} Coal Ore`, 'Iron Bar');
    setupSmithButton('ironPickaxeBtn', ironPickaxeLocked, openIronPickaxeSmith, IRON_PICKAXE_LVL, `Requires: ${IRON_PICKAXE_BAR_COST} Iron Bars, ${IRON_PICKAXE_WOOD_COST} Oak`, 'Iron Pickaxe');
    setupSmithButton('ironAxeBtn', ironAxeLocked, openIronAxeSmith, IRON_AXE_LVL, `Requires: ${IRON_AXE_BAR_COST} Iron Bars, ${IRON_AXE_WOOD_COST} Oak`, 'Iron Axe');
    setupSmithButton('ironShortswordBtn', ironSwordLocked, openIronShortswordSmith, IRON_SWORD_LVL, `Requires: ${IRON_SHORTSWORD_BAR_COST} Iron Bars`, 'Iron Shortsword');
    setupSmithButton('ironBootsBtn', ironBootsLocked, openIronBootsSmith, IRON_BOOTS_LVL, `Requires: ${IRON_BOOTS_BAR_COST} Iron Bars`, 'Iron Boots');
    setupSmithButton('ironHelmetBtn', ironHelmetLocked, openIronHelmetSmith, IRON_HELMET_LVL, `Requires: ${IRON_HELMET_BAR_COST} Iron Bars`, 'Iron Helmet');
    setupSmithButton('ironChestplateBtn', ironChestLocked, openIronChestplateSmith, IRON_CHEST_LVL, `Requires: ${IRON_CHESTPLATE_BAR_COST} Iron Bars`, 'Iron Chestplate');
  }
}

// --- NEW: Coal Mine UI ---

function openCopperMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Copper Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}




function openCoalMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Coal Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A dark, crumbly coal vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startCoalMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Coal Mine Logic ---
async function startCoalMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++
  
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => coalMiningLoop(now, now));
}

function coalMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / COAL_MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(COAL_MINE_ITEM, 1);
    addXP('mining', COAL_MINE_XP);

    showItemPopup(`+${COAL_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${COAL_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_COAL_MS, 'mineProgressText', coalMiningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => coalMiningLoop(now, startTime));
  }
}

// --- NEW: Iron Mine UI ---
function openIronMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Mine - Iron Vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A sturdy iron vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
        <div class="progress-text" id="mineProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = () => startIronMining();
  document.getElementById('stopMineBtn').onclick = stopMining;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Iron Mine Logic ---
async function startIronMining() {
  // +++ NEW: Tool Check +++
  const bestPickaxe = getBestTool('pickaxe');
  if (bestPickaxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Pickaxe in your inventory to mine this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => ironMiningLoop(now, now));
}

function ironMiningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / IRON_MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(IRON_MINE_ITEM, 1);
    addXP('mining', IRON_MINE_XP);

    showItemPopup(`+${IRON_MINE_XP} Mining XP`, 'mineProgress', 0);
    showItemPopup(`+1 ${IRON_MINE_ITEM}`, 'mineProgress', 450);
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    
    // --- NEW: Start Cooldown ---
    game.progressFrame = requestAnimationFrame((now) => 
      miningCooldownLoop(now, now, MINE_COOLDOWN_IRON_MS, 'mineProgressText', ironMiningLoop)
    );
    // --- END NEW ---
    
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => ironMiningLoop(now, startTime));
  }
}

function openMineHub() {
  showMainScreen('hubMine');
}

// --- NEW: Woodcutting Hub UI ---
function openForestHub() {
  showMainScreen('hubForest');
}

// --- NEW: Softwood Tree UI ---
function openSoftwoodTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Softwood Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A common, pliable tree.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingSoftwood;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Oak Tree UI ---
function openOakTree(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  stopMining();
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>Chop - Oak Tree</h2>
    <div style="margin-top:8px; color:#efe3cf;">A strong, sturdy oak.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="woodcutProgress"></div>
        <div class="progress-text" id="woodcutProgressText"></div> </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startChopBtn" class="primary">Start Chopping</button>
      <button id="stopChopBtn" class="primary" style="background:#555; display:none;">Stop Chopping</button>
      <button onclick="openForestHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startChopBtn').onclick = startChoppingOak;
  document.getElementById('stopChopBtn').onclick = stopWoodcutting;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// --- NEW: Stop Woodcutting Logic ---
function stopWoodcutting(){
  game.woodcuttingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  
  const textEl = document.getElementById('woodcutProgressText');
  if (textEl) textEl.innerText = '';

  const bar = document.getElementById('woodcutProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startChopBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopChopBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

// --- NEW: Woodcutting Cooldown Loop ---
function woodcuttingCooldownLoop(timestamp, startTime, duration, progressTextId, nextLoopFunction) {
  if (!game.woodcuttingActive) {
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    return;
  }

  const elapsed = timestamp - startTime;
  const remainingMs = duration - elapsed;

  if (remainingMs <= 0) {
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = '';
    game.progressFrame = requestAnimationFrame((now) => nextLoopFunction(now, now));
  } else {
    const remainingSecs = (remainingMs / 1000).toFixed(1);
    const textEl = document.getElementById(progressTextId);
    if (textEl) textEl.innerText = `${remainingSecs}s`;
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, startTime, duration, progressTextId, nextLoopFunction)
    );
  }
}

// --- NEW: Softwood Logic ---
async function startChoppingSoftwood() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 1) { // Requires Bronze (Tier 1)
    await showGameAlert("Tool Required", "You need at least a Bronze Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => softwoodChoppingLoop(now, now));
}

function softwoodChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SOFTWOOD_CHOP_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(SOFTWOOD_CHOP_ITEM, 1);
    addXP('woodcutting', SOFTWOOD_CHOP_XP);

    showItemPopup(`+${SOFTWOOD_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${SOFTWOOD_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, now, CHOP_COOLDOWN_SOFTWOOD_MS, 'woodcutProgressText', softwoodChoppingLoop)
    );
  } else {
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => softwoodChoppingLoop(now, startTime));
  }
}

// --- NEW: Oak Logic ---
async function startChoppingOak() {
  // +++ NEW: Tool Check +++
  const bestAxe = getBestTool('axe');
  if (bestAxe < 2) { // Requires Copper (Tier 2)
    await showGameAlert("Tool Required", "You need at least a Copper Axe in your inventory to chop this.");
    return;
  }
  // +++ END NEW +++

  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.woodcuttingActive) return; 
  game.woodcuttingActive = true;
  const startBtn = document.getElementById('startChopBtn');
  const stopBtn = document.getElementById('stopChopBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => oakChoppingLoop(now, now));
}

function oakChoppingLoop(timestamp, startTime) {
  if (!game.woodcuttingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / OAK_CHOP_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(OAK_CHOP_ITEM, 1);
    addXP('woodcutting', OAK_CHOP_XP);

    showItemPopup(`+${OAK_CHOP_XP} Woodcutting XP`, 'woodcutProgress', 0);
    showItemPopup(`+1 ${OAK_CHOP_ITEM}`, 'woodcutProgress', 450);
    
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = '0%';
    
    game.progressFrame = requestAnimationFrame((now) => 
      woodcuttingCooldownLoop(now, now, CHOP_COOLDOWN_OAK_MS, 'woodcutProgressText', oakChoppingLoop)
    );
  } else {
    const bar = document.getElementById('woodcutProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => oakChoppingLoop(now, startTime));
  }
}

function openCombatHub() {
  showMainScreen('hubCombat');
  // Preload the assets for the *next* screen
  // (We can't use preloadImages anymore, but this asset is already in the master list)
}

function openFarmCombatArea() {
  game.shopOpen = false;
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  wrapper.innerHTML = `
    <h2>The Farm</h2>
    <div style="margin-top:8px; color:#efe3cf;">A peaceful farm, mostly.</div>
    
    <div style="margin-top:20px; text-align:center; cursor:pointer;" onclick="openCombatInterface('Chicken')">
      <img src="images/chickenmonster.png" alt="Chicken" style="height: 100px;">
      <div style="font-weight:bold;">Chicken (Lvl 1)</div>
    </div>
    
    <div class="action-buttons" style="margin-top:14px;">
      <button onclick="openCombatHub()" class="primary" style="background:#666;">Return</button>
    </div>
  `;
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}

// NEW: Function to build and open the main combat UI
function openCombatInterface(enemyName) {
  // Stop any skilling
  if (game.miningActive) {
    stopMining();
    game.wasMiningBeforeCombat = true;
  }
  if (game.blacksmithingActive) {
    stopBlacksmithing();
    game.wasSmithingBeforeCombat = true;
  }
  if (game.woodcuttingActive) { // +++ NEW +++
    stopWoodcutting();
    game.wasWoodcuttingBeforeCombat = true;
  }
  
  // Define our enemy
  if (enemyName === 'Chicken') {
    game.currentEnemy = {
      name: 'Chicken',
      level: 1,
      maxHp: 10,
      currentHp: 10,
      attack: 1, // Low attack level
      strength: 1, // Max hit is 1
      defence: 1, // Low defence
      img: 'images/chickenanim.gif'
    };
  } else {
    console.error('Unknown enemy:', enemyName);
    return;
  }
  
  const wrapper = document.getElementById('hubDynamic'); // <-- 1. CHANGED
  
  // --- This is the new UI layout you described ---
  wrapper.innerHTML = `
    <div id="combat-main-container">
    
      <div id="combat-enemy-area">
        <img id="combat-enemy-img" src="${game.currentEnemy.img}" alt="${game.currentEnemy.name}">
        <div id="combat-enemy-hp-bar">
          <div id="combat-enemy-hp-fill" style="width:100%"></div>
          <div id="combat-enemy-hp-text">10 / 10 HP</div>
        </div>
      </div>
      
      <div id="combat-player-area">
        
        <div id="combat-equip-panel">
          <div class="equipment-character">
            <div class="character-frame">
              <div class="equipment-row">
                <div class="equipment-slot" id="combat-helmet">
                  </div>
              </div>
              <div class="equipment-row" style="align-items:center;">
                <div class="equipment-slot" id="combat-weapon"></div>
                <div class="equipment-slot" id="combat-chest"></div>
              </div>
              <div class="equipment-row">
                <div class="equipment-slot" id="combat-boots"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div id="combat-action-panel">
          <p style="margin: 0 0 10px 0; font-weight: bold;">Combat Style:</p>
          <div id="combat-styles">
            <button id="style-attack" class="primary" onclick="setAttackStyle('attack')">Accurate</button>
            <button id="style-strength" class="primary" onclick="setAttackStyle('strength')">Aggressive</button>
            <button id="style-defence" class="primary" onclick="setAttackStyle('defence')">Defensive</button>
          </div>
          
          
          <div id="combat-main-actions">
            <button id="combat-fight-btn" class="primary" style="background:#900;" onclick="beginCombat()">Fight</button>
            <button id="combat-run-btn" class="primary" style="background:#080; display:none;" onclick="runFromCombat()">Run</button>
            <button id="combat-return-btn" class="primary" style="background:#555;" onclick="returnToFarm()">Return</button>
          </div>
          
        </div>
      </div>
    </div>
  `;
  
  // --- THIS IS THE FIX ---
  renderEquipment();
  // --- END FIX ---

  // Set the default active style button
  setAttackStyle(game.playerAttackStyle, true); 
  showMainScreen('hubDynamic'); // <-- 2. ADDED
}
function setAttackStyle(style, isInitialization = false) {
  game.playerAttackStyle = style;
  
  // Update button visual state
  const styles = ['attack', 'strength', 'defence'];
  styles.forEach(s => {
    const btn = document.getElementById(`style-${s}`);
    if (btn) {
      if (s === style) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    }
  });
  
  // --- THIS IS THE FIX ---
  // Re-render equipment to update stats (like style bonuses)
  // This will also update the combat UI equipment panel if it's open
  renderEquipment(); 
  // --- END FIX ---

  if (!isInitialization) {
    // Line deleted
  }
}




// NEW: Function to start the combat loops
function beginCombat() {
  if (game.inCombat) return; 
  if (!game.isSessionActive) {
    showGameAlert("Session Not Active", "This game session is not active. Please take control to perform actions.");
    return;
  }
  
  game.inCombat = true;
  document.getElementById('combat-fight-btn').style.display = 'none'; 
  document.getElementById('combat-run-btn').style.display = 'block'; 
  document.getElementById('combat-run-btn').disabled = false;
  
  // --- NEW: Calculate stats and set dynamic attack speed ---
  const stats = getPlayerCombatStats();
  
  // Player attacks at their calculated attack speed
  game.playerCombatInterval = setInterval(playerAttackTurn, stats.attackSpeed);
  
  // Enemy (Chicken) attacks every 3.0 seconds
  game.enemyCombatInterval = setInterval(enemyAttackTurn, 3000);
}

// NEW: Function to stop combat
function runFromCombat(playerDied = false) {
  if (!game.inCombat) return; // Can't run if not in a fight
  
  game.inCombat = false;
  
  // Stop the attack loops
  if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
  if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
  game.playerCombatInterval = null;
  game.enemyCombatInterval = null;

  const fightBtn = document.getElementById('combat-fight-btn');
  const runBtn = document.getElementById('combat-run-btn');
  const returnBtn = document.getElementById('combat-return-btn');
  
  if (playerDied) {
    // Player is dead, disable all actions
    if (fightBtn) fightBtn.disabled = true;
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'none';
  } else {
    // Player clicked "Run"
    if (fightBtn) fightBtn.style.display = 'block'; // SHOW Fight
    if (fightBtn) fightBtn.disabled = false;
    if (runBtn) runBtn.style.display = 'none'; // HIDE Run
    if (runBtn) runBtn.disabled = true;
    if (returnBtn) returnBtn.style.display = 'block'; // Show return

    // Reset enemy HP
    if (game.currentEnemy) {
        game.currentEnemy.currentHp = game.currentEnemy.maxHp;
        updateEnemyCombatUI();
    }
  }
}

function returnToFarm() {
  // +++ NEW FIX: Stop combat loops +++
  if (game.inCombat) {
    game.inCombat = false;
    if (game.playerCombatInterval) clearInterval(game.playerCombatInterval);
    if (game.enemyCombatInterval) clearInterval(game.enemyCombatInterval);
    game.playerCombatInterval = null;
    game.enemyCombatInterval = null;
  }
  // +++ END FIX +++

  // 1. Go back to the farm screen
  openFarmCombatArea(); 
  
  // 2. Check if we need to resume skilling
  if (game.wasMiningBeforeCombat) {
    openCopperMine(); // Re-opens the mine UI
    startMining();      // Restarts mining
  } else if (game.wasSmithingBeforeCombat) {
    // This is more complex, might need to know *which* item
    openBlacksmithHub(); // Just return to hub for now
  } else if (game.wasWoodcuttingBeforeCombat) { // +++ NEW +++
    openForestHub(); // Return to Forest hub
  }
  game.wasMiningBeforeCombat = false;
  game.wasSmithingBeforeCombat = false;
  game.wasWoodcuttingBeforeCombat = false; // +++ NEW +++
}

// NEW: Helper function to update the enemy's HP bar
function updateEnemyCombatUI() {
  if (!game.currentEnemy) return;
  
  const enemy = game.currentEnemy;
  const percent = Math.max(0, (enemy.currentHp / enemy.maxHp) * 100);
  
  const fill = document.getElementById('combat-enemy-hp-fill');
  const text = document.getElementById('combat-enemy-hp-text');
  
  if (fill) fill.style.width = percent + '%';
  if (text) text.textContent = `${enemy.currentHp} / ${enemy.maxHp} HP`;
}

function showDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'flex';
}

/**
 * Hides the death overlay.
 */
function hideDeathOverlay() {
  const overlay = document.getElementById('deathOverlay');
  if (overlay) overlay.style.display = 'none';
}

/**
 * Handles all logic when a player's HP reaches 0.
 */
function handlePlayerDeath() {
  // 1. Wipe inventory
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  renderInventoryGrid();
  
  // 2. Wipe gold
  game.gold = 0;
  updateGoldUI();
  
  // 3. Save the empty state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
  
  // 4. Show the death modal
  showDeathOverlay();
}

/**
 * Handles the "Revive" button click.
 */
function revivePlayer() {
  // 1. Hide the modal
  hideDeathOverlay();
  
  // 2. Restore HP
  game.hp = game.maxHP;
  updateHPUI();
  
  // 3. Go back to the main hub
  backToActions();
  
  // 4. Save the new HP state
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}
// --- END: Death & Revive Functions ---


function showDamageSplat(target, amount, type) {
  let anchorElement = null;
  if (target === 'player') {
    // This finds the player's main hp-bar
    anchorElement = document.getElementById('hpFill').parentElement; 
  } else if (target === 'enemy') {
    anchorElement = document.getElementById('combat-enemy-hp-bar');
  }

  if (!anchorElement) return;

  const splat = document.createElement('div');
  splat.className = 'combat-splat';
  
  if (type === 'damage') {
    splat.classList.add('splat-damage');
    splat.textContent = amount;
  } else { // 'block'
    splat.classList.add('splat-block');
    splat.textContent = '0';
  }
  
  // Randomize horizontal position slightly
  splat.style.right = (Math.floor(Math.random() * 20) - 40) + 'px';
  
  anchorElement.appendChild(splat);
  setTimeout(() => splat.remove(), 850); // Remove just before animation ends
}

function playerAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;


  // --- NEW: Play attack sound ---
  playGlobalSound('sounds/soundeffects/swordsoundeffect.mp3');
  // --- END NEW ---
  

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- 2. Calculate Hit Chance ---
  // Player's Attack vs. Enemy's Defence
  let hitChance = 70 + (game.attack.level - game.currentEnemy.defence);
  hitChance = Math.max(10, Math.min(90, hitChance)); // Clamp between 10% and 90%

  if (Math.random() * 100 > hitChance) {
    showDamageSplat('enemy', 0, 'block'); // ENEMY MISS
    return;
  }

  // --- 3. Calculate Damage (If Hit) ---
  // Get the final max hit from our stats function
  // This is (Unarmed 1-4) + (Equip Damage)
  let maxHit = playerStats.physicalDamage;
  
  // Damage is a random number from 0 to your max hit
  let damage = Math.floor(Math.random() * (maxHit + 1));

  // +++ FIX: CAP DAMAGE TO ENEMY'S REMAINING HP +++
  // Determine the actual damage applied, which is the MINIMUM of the damage rolled
  // and the enemy's current HP. This prevents over-damage and excess XP.
  let damageApplied = Math.min(damage, game.currentEnemy.currentHp);

  if (damageApplied > 0) {
    showDamageSplat('enemy', damageApplied, 'damage'); // ENEMY HIT
  } else {
    showDamageSplat('enemy', 0, 'block'); // ENEMY HIT A 0
  }

  // Apply damage to enemy
  game.currentEnemy.currentHp -= damageApplied;
  updateEnemyCombatUI();

  // --- 4. Grant XP ---
  if (damageApplied > 0) {
    // XP is now calculated based on the *actual* damage applied (damageApplied)
    let mainXPGained = damageApplied * 4; 
    let skillToTrain = game.playerAttackStyle; 
    
    addXP(skillToTrain, mainXPGained, 0);
    
    let vitalityXPGained = Math.ceil(mainXPGained / 2);
    addXP('vitality', vitalityXPGained, 450);
  }

  // --- 5. Check for Enemy Death ---
  if (game.currentEnemy.currentHp <= 0) {
    addItem('Raw Chicken', 1);
    showItemPopup('+1 Raw Chicken', null, 900);
    
    game.currentEnemy.currentHp = game.currentEnemy.maxHp;
    updateEnemyCombatUI();
  }
}

// NEW: The Enemy's turn to attack
function enemyAttackTurn() {
  if (!game.inCombat || !game.currentEnemy) return;

  // --- 1. Get Player's Current Stats ---
  const playerStats = getPlayerCombatStats();

  // --- 2. Calculate Hit Chance ---
  let hitChance = 25 + (game.currentEnemy.attack - game.defence.level);
  hitChance = Math.max(5, Math.min(50, hitChance)); 
  
  if (Math.random() * 100 > hitChance) {
    showDamageSplat('player', 0, 'block'); // PLAYER MISS
    return;
  }

  // --- 3. Calculate Damage (If Hit) ---
  let maxHit = game.currentEnemy.strength; // Chicken max hit is 1
  let damage = Math.floor(Math.random() * (maxHit + 1)); // Will be 0 or 1

  // --- 4. Apply Damage Reduction ---
  // 'playerStats.armor' is the total armor from skills + equipment
  // The chicken's max hit is 1. We'll make it simple:
  // If player's armor > 0, they have a chance to block.
  // (Armor * 10%) chance to block the hit entirely.
  let armorChance = Math.min(80, playerStats.armor * 10); // Max 80% block chance
  
  if (damage > 0 && (Math.random() * 100 < armorChance)) {
    damage = 0; // Blocked!
  }
  
  if (damage > 0) {
    showDamageSplat('player', damage, 'damage'); // PLAYER HIT
  } else {
    showDamageSplat('player', 0, 'block'); // PLAYER HIT A 0 (or was blocked)
  }
  
  // Apply damage to player
  game.hp -= damage;
  updateHPUI(); 

  // --- 5. Check for Player Death ---
  if (game.hp <= 0) {
    game.hp = 0; 
    updateHPUI();
    runFromCombat(true); 
    handlePlayerDeath();
  }
}

function backToActions(){
  showMainScreen('hubActions');
}

function _createModal(title, contentHtml, buttons) {
  // Return a new promise that we can control
  return new Promise((resolve) => {
    // 1. Create elements
    const overlay = document.createElement('div');
    overlay.id = 'gameModalOverlay';

    const modal = document.createElement('div');
    modal.className = 'game-modal';

    const titleEl = document.createElement('div');
    titleEl.className = 'game-modal-title';
    titleEl.textContent = title;

    const contentEl = document.createElement('div');
    contentEl.className = 'game-modal-content';
    contentEl.innerHTML = contentHtml; // Use innerHTML to allow custom content

    const buttonEl = document.createElement('div');
    buttonEl.className = 'game-modal-buttons';

    // 2. Create buttons
    buttons.forEach(btnConfig => {
      const button = document.createElement('button');
      button.textContent = btnConfig.text;
      button.className = btnConfig.class || 'primary';
      if (btnConfig.style) {
        button.style.background = btnConfig.style;
      }

      // --- MODIFIED ONCLICK LOGIC ---
      button.onclick = () => {
        const inputEl = modal.querySelector('.game-modal-input');
        let resolveValue = btnConfig.value; // Default to the button's value (e.g., null for 'Cancel')

        // If an input exists AND the clicked button was NOT a cancel button (value is not null)
        if (inputEl && btnConfig.value !== null) { 
          resolveValue = inputEl.value; // Resolve with the input's value instead
        }
        
        overlay.remove();
        resolve(resolveValue); // Resolve with either the input value or the button value
      };
      // --- END MODIFICATION ---
      
      buttonEl.appendChild(button);
    });

    // 3. Assemble and append
    modal.appendChild(titleEl);
    modal.appendChild(contentEl);
    modal.appendChild(buttonEl);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Focus the first primary button or input
    const firstButton = modal.querySelector('button.primary');
    const firstInput = modal.querySelector('input');
    if (firstInput) {
      firstInput.focus();
      firstInput.select(); // Also select the text
    } else if (firstButton) {
      firstButton.focus();
    }
  });
}

/**
 * Shows a custom, in-game alert box.
 * Replaces the default browser alert().
 * @param {string} title - The title for the alert.
 * @param {string} message - The message to display.
 */
async function showGameAlert(title, message) {
  const buttons = [
    { text: 'OK', value: 'ok', class: 'primary' }
  ];
  // We await the modal helper. The promise will resolve when 'OK' is clicked.
  await _createModal(title, `<p>${message}</p>`, buttons);
}

async function showGamePrompt(title, message, defaultValue = '') {
  // HTML for the modal's content, including the input field
  const contentHtml = `
    <p>${message}</p>
    <input type="number" class="game-modal-input" value="${defaultValue}" onfocus="this.select();">
  `;
  
  // Buttons: Cancel (value: null) and OK (value: 'ok')
  const buttons = [
    { text: 'Cancel', value: null, class: 'primary', style: '#666' },
    { text: 'OK', value: 'ok', class: 'primary' } // 'ok' is a placeholder, _createModal will grab the input value
  ];

  // Our upgraded _createModal will return the input's value if 'OK' is clicked,
  // or null if 'Cancel' is clicked.
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}

/**
 * Shows a custom, in-game confirmation box (Yes/No).
 * Replaces the default browser confirm().
 * @param {string} title - The title for the confirm box.
 * @param {string} message - The question to ask.
 * @returns {Promise<boolean>} - Resolves true if "Yes" was clicked, false if "No"/"Cancel".
 */
async function showGameConfirm(title, message) {
  const contentHtml = `<p>${message}</p>`;
  
  const buttons = [
    { text: 'No', value: false, class: 'primary', style: '#666' },
    { text: 'Yes', value: true, class: 'primary' } // 'Yes' resolves to true
  ];

  // This will return `true` or `false`
  const result = await _createModal(title, contentHtml, buttons);
  return result;
}


let draggedBankItem = null; // Stores data for bank drag-and-drop

/**
 * Renders the Bank grid UI
 */
function renderBankGrid() {
  const grid = document.getElementById('bankGrid');
  if (!grid) return;
  
  grid.innerHTML = '';
  for(let i = 0; i < game.bankCapacity; i++) {
    const slotData = game.bank[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    slot.addEventListener('dragover', handleBankDragOver);
    slot.addEventListener('dragleave', (e) => e.target.closest('.inv-slot').classList.remove('drag-over'));
    slot.addEventListener('drop', handleBankDrop);
    
    if(slotData) {
      const item = slotData;
      
      slot.draggable = true; 
      slot.addEventListener('dragstart', (e) => handleBankWithdrawDragStart(e, item, i));
      slot.addEventListener('dragend', () => {
        draggedBankItem = null;
        game.isDragging = false; 
        const draggingEl = document.querySelector('.inv-slot.dragging');
        if (draggingEl) draggingEl.classList.remove('dragging');
      });
      
      slot.onclick = () => withdrawItem(i); 

      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      if (item.name === 'Copper Bar') imgName = 'copperbar';
      else if (item.name === 'Copper Chestplate') imgName = 'copperchestplate';
      else if (item.name === 'Copper Shortsword') imgName = 'coppershortsword';
      else if (item.name === 'Copper Helmet') imgName = 'copperhelmet';
      else if (item.name === 'Copper Boots') imgName = 'copperboots';
      else if (item.name === 'Raw Chicken') imgName = 'rawchicken';
      else if (item.name === 'Cooked Chicken') imgName = 'cookedchicken';
      else if (item.name === 'Burnt Chicken') imgName = 'burntchicken';
      else if (item.name === 'Coal Ore') imgName = 'coalore';
      else if (item.name === 'Iron Ore') imgName = 'ironore';
      else if (item.name === 'Iron Bar') imgName = 'ironbar';
      else if (item.name === 'Iron Helmet') imgName = 'ironhelmet';
      else if (item.name === 'Iron Chestplate') imgName = 'ironchestplate';
      else if (item.name === 'Iron Boots') imgName = 'ironboots';
      else if (item.name === 'Iron Shortsword') imgName = 'ironshortsword';
      else if (item.name === 'Softwood') imgName = 'softwood';
      else if (item.name === 'Oak') imgName = 'oak';
      else if (item.name === 'Bronze Pickaxe') imgName = 'bronzepickaxe'; // +++ NEW +++
      else if (item.name === 'Bronze Axe') imgName = 'bronzeaxe'; // +++ NEW +++
      else if (item.name === 'Copper Pickaxe') imgName = 'copperpickaxe'; // +++ NEW +++
      else if (item.name === 'Copper Axe') imgName = 'copperaxe'; // +++ NEW +++
      else if (item.name === 'Iron Pickaxe') imgName = 'ironpickaxe'; // +++ NEW +++
      else if (item.name === 'Iron Axe') imgName = 'ironaxe'; // +++ NEW +++
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      // --- NEW: Generate Stat Tooltip ---
      let itemStats = '';
      const stats = ITEM_STATS[item.name];
      if (stats) {
        if (stats.damage) itemStats += `<div style="color:#aaffaa;">+${stats.damage} Physical Damage</div>`;
        if (stats.styleBonus) itemStats += `<div style="color:#aaffaa;">+${stats.styleBonus} Physical Damage (if accurate)</div>`;
        if (stats.armor) itemStats += `<div style="color:#aaffaa;">+${stats.armor} Armor</div>`;
        if (stats.speed) itemStats += `<div style="color:#aaffaa;">+${stats.speed} Speed</div>`;
      }
      // --- END NEW ---

      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${item.name}</div>
        <div>Amount: ${item.qty.toLocaleString()}</div>
        ${itemStats}
        <div style="color:#ffaaaa; margin-top: 5px;">Click or Drag to withdraw...</div>
      `;
      slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slot.onmouseleave = hideTooltip;
    }
    grid.appendChild(slot);
  }
}



/**
 * Updates the gold values on the bank screen
 */
function updateBankGoldUI() {
  setText('bankPlayerGold', formatAmount(game.gold));
  setText('bankStoredGold', formatAmount(game.bankGold));
}

/**
 * Main function to open the Bank UI
 */
function openBank() {
  showMainScreen('hubBank');
}
// --- Bank Drag-and-Drop Handlers ---

function handleBankDragStart(e, item, fromIndex) {
  // Store item data for the drop
  draggedBankItem = { item, fromIndex };
  e.dataTransfer.effectAllowed = 'move';
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}

function handleBankDragOver(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  if (targetSlot) {
    targetSlot.classList.add('drag-over');
  }
}

async function handleBankDrop(e) {
  e.preventDefault();
  const targetSlot = e.target.closest('.inv-slot');
  
  if (targetSlot) {
    targetSlot.classList.remove('drag-over');
  }
  
  // Clean up *any* dragging slot, from either grid
  const draggingInvEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
  if (draggingInvEl) draggingInvEl.classList.remove('dragging');
  const draggingBankEl = document.querySelector('#bankGrid .inv-slot.dragging');
  if (draggingBankEl) draggingBankEl.classList.remove('dragging');

  if (!targetSlot || !draggedBankItem) {
     draggedBankItem = null;
     return;
  }

  const toIndex = parseInt(targetSlot.dataset.slotIndex);
  const fromIndex = draggedBankItem.fromIndex;

  // --- NEW LOGIC: Check drag source ---
  if (draggedBankItem.source === 'bank') {
    // === BANK -> BANK internal move ===
    
    if (fromIndex !== toIndex) {
      // --- Get the item data *before* the prompt ---
      const dragItemBeforePrompt = game.bank[fromIndex];
      const dropItem = game.bank[toIndex];

      // --- MODIFIED: Handle Shift-Click to move specific amount ---
      if (e.shiftKey && dragItemBeforePrompt) { 
        
        if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
          await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
        } else {
          const input = await showGamePrompt(
            `Move ${dragItemBeforePrompt.name}`, 
            `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
            "" 
          );

          // --- THIS IS THE FIX ---
          // After the prompt (await) is done, we re-check the bank
            
          if (input === null) {
            // User cancelled
            const originalSlotEl = document.querySelector(`#bankGrid .inv-slot[data-slot-index="${fromIndex}"]`);
            if (originalSlotEl) {
              originalSlotEl.classList.remove('dragging');
            }
          } else {
            // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
            const itemAfterPrompt = game.bank[fromIndex]; // Check game.bank
            
            // Check if the item was consumed or changed
            if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
              // The item was consumed! Abort.
              draggedBankItem = null;
              game.isDragging = false;
              return; // Safely exit
            }
            // --- END EXPLOIT FIX ---
            
            const splitAmount = parseInt(input);

            if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid */ }
            
            // Use the most up-to-date quantity
            else if (splitAmount > itemAfterPrompt.qty) { 
              await showGameAlert("Invalid Amount", "You don't have that many.");
            } 
            
            else if (splitAmount === itemAfterPrompt.qty) { 
              // Full stack move
              if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                dropItem.qty += itemAfterPrompt.qty;
                game.bank[fromIndex] = null;
              } else {
                game.bank[fromIndex] = dropItem;
                game.bank[toIndex] = itemAfterPrompt;
              }
              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
            
            else {
              // This is a valid SPLIT
              if (dropItem) { 
                dropItem.qty += splitAmount;
              } else { 
                game.bank[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
              }
              itemAfterPrompt.qty -= splitAmount; // Use the validated item

              renderBankGrid();
              if (typeof window.savePlayerData === 'function') savePlayerData();
            }
          }
        }
      } else {
        // --- BANK SWAP/STACK (No Shift) ---
        // We must re-get the dragItem in case it was consumed
        const dragItem = game.bank[fromIndex]; 
        if (dragItem && dropItem && dragItem.name === dropItem.name) {
          dropItem.qty += dragItem.qty;
          game.bank[fromIndex] = null;
        } else {
          game.bank[fromIndex] = dropItem;
          game.bank[toIndex] = dragItem;
        }
        renderBankGrid();
        if (typeof window.savePlayerData === 'function') savePlayerData();
      }
    }

  } else {
    // === INVENTORY -> BANK deposit (Original Logic) ===
    const depositSuccess = await depositItem(draggedBankItem.item, fromIndex, toIndex);
    
    if (!depositSuccess) {
      // User cancelled deposit, remove 'dragging' class from INVENTORY slot
      const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
      if (originalSlotEl) {
        originalSlotEl.classList.remove('dragging');
      }
    }
  }
  
  draggedBankItem = null;
}

// --- Bank Core Logic ---

function handleBankWithdrawDragStart(e, item, fromBankIndex) {
  // Store item data and the *source* as 'bank'
  draggedBankItem = { item, fromIndex: fromBankIndex, source: 'bank' };
  e.dataTransfer.effectAllowed = 'move';
  game.isDragging = true;
  setTimeout(() => {
    e.target.closest('.inv-slot').classList.add('dragging');
  }, 0);
}


async function depositItem(item, fromInventoryIndex, toBankIndex) {
  if (!item) return;

  const bankSlot = game.bank[toBankIndex];
  
  if (bankSlot && bankSlot.name !== item.name) {
    await showGameAlert("Invalid Slot", "You can't stack different items. Drop on an empty slot or a stack of the same item."); // Replaced alert
    return;
  }

  let qtyToDeposit = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Deposit ${item.name}`,
      `How many ${item.name} do you want to deposit? (You have: ${item.qty})`,
      item.qty
    );
    if (input === null) return false;
    qtyToDeposit = parseInt(input);
    // --- END MODIFICATION ---
  }

  if (isNaN(qtyToDeposit) || qtyToDeposit <= 0) return;
  if (qtyToDeposit > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to deposit."); // Replaced alert
    return;
  }

  game.inventory[fromInventoryIndex].qty -= qtyToDeposit;
  if (game.inventory[fromInventoryIndex].qty <= 0) {
    game.inventory[fromInventoryIndex] = null;
  }

  if (bankSlot) {
    bankSlot.qty += qtyToDeposit;
  } else {
    game.bank[toBankIndex] = { name: item.name, qty: qtyToDeposit };
  }

  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
  return true;
}

async function withdrawItem(fromBankIndex) {
  const item = game.bank[fromBankIndex];
  if (!item) return;

  let qtyToWithdraw = item.qty;

  if (item.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${item.name}`,
      `How many ${item.name} do you want to withdraw? (Bank has: ${item.qty})`,
      item.qty
    );
    if (input === null) return;
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0) return;
  if (qtyToWithdraw > item.qty) {
    await showGameAlert("Invalid Amount", "You don't have that many to withdraw."); // Replaced alert
    return;
  }
  
  const itemToAdd = { name: item.name, qty: qtyToWithdraw };
  addItem(itemToAdd.name, itemToAdd.qty); 
  
  game.bank[fromBankIndex].qty -= qtyToWithdraw;
  if (game.bank[fromBankIndex].qty <= 0) {
    game.bank[fromBankIndex] = null;
  }
  
  renderBankGrid();
  renderInventoryGrid(); 
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function depositGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.gold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold to deposit."); // <-- USE 'await showGameAlert'
    return;
  }

  game.gold -= amount;
  game.bankGold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function withdrawGold() { // <-- ADD 'async'
  const inputEl = document.getElementById('bankGoldInput');
  if (!inputEl) return;
  
  let amount = parseInt(inputEl.value);
  if (isNaN(amount) || amount <= 0) {
    await showGameAlert("Invalid Amount", "Please enter a valid amount."); // <-- USE 'await showGameAlert'
    return;
  }
  if (amount > game.bankGold) {
    await showGameAlert("Not Enough Gold", "You don't have that much gold in your bank."); // <-- USE 'await showGameAlert'
    return;
  }

  game.bankGold -= amount;
  game.gold += amount;

  inputEl.value = '';
  updateBankGoldUI();
  updateGoldUI(); // Update main UI
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

async function dragWithdrawItem(fromBankIndex, toInventoryIndex) {
  const bankItem = game.bank[fromBankIndex];
  const inventorySlotItem = game.inventory[toInventoryIndex];

  if (!bankItem) return;

  let qtyToWithdraw = bankItem.qty;

  if (bankItem.qty > 1) {
    // --- MODIFICATION HERE ---
    const input = await showGamePrompt(
      `Withdraw ${bankItem.name}`,
      `How many ${bankItem.name} do you want to withdraw? (Bank has: ${bankItem.qty})`,
      bankItem.qty
    );
    if (input === null) return; 
    qtyToWithdraw = parseInt(input);
    // --- END MODIFICATION ---
  }
  
  if (isNaN(qtyToWithdraw) || qtyToWithdraw <= 0 || qtyToWithdraw > bankItem.qty) {
    await showGameAlert("Invalid Amount", "Invalid or excessive amount entered."); // Replaced alert
    return;
  }

  if (inventorySlotItem && inventorySlotItem.name === bankItem.name) {
    inventorySlotItem.qty += qtyToWithdraw;
    bankItem.qty -= qtyToWithdraw;
    if (bankItem.qty <= 0) {
      game.bank[fromBankIndex] = null; 
    }

  } else if (inventorySlotItem) {
    if (qtyToWithdraw < bankItem.qty) {
      await showGameAlert("Invalid Action", "You must withdraw the full stack to swap items, or drop onto an empty inventory slot."); // Replaced alert
      return;
    }
    
    game.bank[fromBankIndex] = inventorySlotItem;
    game.inventory[toInventoryIndex] = bankItem;

  } else {
    if (qtyToWithdraw === bankItem.qty) {
        game.inventory[toInventoryIndex] = bankItem;
        game.bank[fromBankIndex] = null; 
    } else {
        game.inventory[toInventoryIndex] = { name: bankItem.name, qty: qtyToWithdraw };
        bankItem.qty -= qtyToWithdraw;
    }
  }
  
  renderBankGrid();
  renderInventoryGrid();
  hideTooltip();
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}
  
// =================================================================
// --- END NEW BANK FUNCTIONS ---
// =================================================================

async function buyShopItem(itemName, price) {
  if (!game.isSessionActive) {
    await showGameAlert("Session Not Active", "This tab is not active. Please take control to perform actions.");
    return;
  }
  if (game.gold < price) {
    await showGameAlert("Not Enough Gold", `You need ${price} Gold to buy that.`);
    return;
  }

  // Check for inventory space
  const emptySlotIndex = game.inventory.findIndex(slot => slot === null);
  if (emptySlotIndex === -1) {
     await showGameAlert("Inventory Full", "You have no space in your inventory to buy this.");
     return;
  }
  
  addGold(-price);
  addItem(itemName, 1);
  await showGameAlert("Purchase Complete", `You bought 1 ${itemName} for ${price} Gold.`);
  
  // No need to render, addItem and addGold already do.
  if (typeof window.savePlayerData === 'function') {
    window.savePlayerData();
  }
}

function openShop() {
  showMainScreen('hubShop');
}

function resetGameState() {
  stopMining(); 
  stopBlacksmithing();
  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  game.gold = 0; 
  // +++ NEW +++
  game.bank = new Array(game.bankCapacity).fill(null);
  game.bankGold = 0;
  game.equipment = { helmet: null, chest: null, weapon: null, boots: null };
  // +++ END NEW +++
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.blacksmith = { level: 1, xp: 0, totalXP: 0 };
  game.cooking = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  game.woodcutting = { level: 1, xp: 0, totalXP: 0 }; // +++ NEW +++
  game.miningActive = false;
  game.blacksmithingActive = false; // +++ NEW +++
  game.cookingActive = false;
  game.woodcuttingActive = false; // +++ NEW +++
  game.shopOpen = false;
  game.isAdmin = false;
  
  // +++ NEW: Reset session state +++
  game.isSessionActive = false;
  game.isDragging = false;
  if (typeof window.stopSessionHeartbeat === 'function') {
      window.stopSessionHeartbeat();
  }
  
  if (game.progressFrame) {
    cancelAnimationFrame(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  renderEquipment(); // <-- ADD THIS
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('inventory'); 
  }
}

/**
 * Saves the current game.settings to localStorage
 */
function saveSettings() {
  localStorage.setItem('rusticGameSettings', JSON.stringify(game.settings));
}

/**
 * Loads settings from localStorage into game.settings
 */
function loadSettings() {
  const savedJSON = localStorage.getItem('rusticGameSettings');
  if (savedJSON) {
    const saved = JSON.parse(savedJSON);

    // --- NEW: Migration logic ---
    // Check for old properties
    if (typeof saved.volume === 'number') {
      game.settings.sfxVolume = saved.volume;
    }
    if (typeof saved.isMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isMuted;
    }

    // Load new properties if they exist
    if (typeof saved.sfxVolume === 'number') {
      game.settings.sfxVolume = saved.sfxVolume;
    }
    if (typeof saved.isSfxMuted === 'boolean') {
      game.settings.isSfxMuted = saved.isSfxMuted;
    }
    if (typeof saved.musicVolume === 'number') {
      game.settings.musicVolume = saved.musicVolume;
    }
    if (typeof saved.isMusicMuted === 'boolean') {
      game.settings.isMusicMuted = saved.isMusicMuted;
    }
    // --- END Migration ---
  }

  applySettingsUI();

  // --- NEW: Apply music settings to player ---
  // This ensures music volume is correct on load
  if (typeof updateMusicPlayerState === 'function') {
    updateMusicPlayerState();
  }
}

/**
 * Updates the UI elements in the settings modal
 */
function applySettingsUI() {
  const sfxSlider = document.getElementById('sfxVolumeSlider');
  const sfxMute = document.getElementById('sfxMuteBtn');
  const musicSlider = document.getElementById('musicVolumeSlider');
  const musicMute = document.getElementById('musicMuteBtn');

  // --- SFX Controls ---
  if (sfxSlider) {
    sfxSlider.value = game.settings.sfxVolume;
    sfxSlider.disabled = game.settings.isSfxMuted;
  }
  if (sfxMute) {
    sfxMute.textContent = game.settings.isSfxMuted ? 'Unmute' : 'Mute';
    if (game.settings.isSfxMuted) {
      sfxMute.style.background = 'var(--gold)';
      sfxMute.style.color = '#000';
    } else {
      sfxMute.style.background = 'var(--accent)';
      sfxMute.style.color = '#fff';
    }
  }

  // --- Music Controls ---
  if (musicSlider) {
    musicSlider.value = game.settings.musicVolume;
    musicSlider.disabled = game.settings.isMusicMuted;
  }
  if (musicMute) {
    musicMute.textContent = game.settings.isMusicMuted ? 'Unmute' : 'Mute';
    if (game.settings.isMusicMuted) {
      musicMute.style.background = 'var(--gold)';
      musicMute.style.color = '#000';
    } else {
      musicMute.style.background = 'var(--accent)';
      musicMute.style.color = '#fff';
    }
  }
}

/**
 * Opens the settings modal
 */
function openSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) {
    applySettingsUI(); // Ensure UI is in sync when opening
    modal.style.display = 'flex';
  }
}

/**
 * Closes the settings modal
 */
function closeSettings() {
  const modal = document.getElementById('settingsModalOverlay');
  if (modal) modal.style.display = 'none';
}

/**
 * The new global sound player that respects settings
 * @param {string} src - The path to the sound file
 */
// +++ NEW: Hub Screen Toggler Function +++
const hubScreenIds = ['hubActions', 'hubMine', 'hubBlacksmith', 'hubForest', 'hubKitchen', 'hubCombat', 'hubShop', 'hubBank', 'hubDynamic'];
function showMainScreen(screenIdToShow) {
  // Stop all skilling actions
  stopMining();
  stopBlacksmithing();
  stopCookingChicken();
  stopWoodcutting();
  game.shopOpen = false;
  hideTooltip();

  // Get the wrapper and clear dynamic content
  const wrapper = document.getElementById('mainContentWrapper');
  const dynamicHub = document.getElementById('hubDynamic');
  
  if (screenIdToShow !== 'hubDynamic') {
    // Clear dynamic content if we're not showing it
    dynamicHub.innerHTML = '';
  }

  // Toggle the screens
  hubScreenIds.forEach(id => {
    const screen = document.getElementById(id);
    if (screen) {
      if (id === screenIdToShow) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    }
  });

  // Special case: if we're showing the blacksmith hub, render its items
  if (screenIdToShow === 'hubBlacksmith') {
    renderSmithingItems('copper'); // Default to copper
  }
  
  // Special case: if we're showing the mine hub, apply level locks
  if (screenIdToShow === 'hubMine') {
    const miningLvl = game.mining.level;
    document.getElementById('ironVeinBtn').classList.toggle('locked-item', miningLvl < IRON_MINE_LVL);
    document.getElementById('coalVeinBtn').classList.toggle('locked-item', miningLvl < COAL_MINE_LVL);
  }
  
  // Special case: if we're showing the forest hub, apply level locks
  if (screenIdToShow === 'hubForest') {
    const woodcuttingLvl = game.woodcutting.level;
    document.getElementById('oakTreeBtn').classList.toggle('locked-item', woodcuttingLvl < OAK_TREE_LVL);
  }
  
  // Special case: if we're showing the shop
  if (screenIdToShow === 'hubShop') {
    game.shopOpen = true;
  }
  
  // Special case: if we're showing the bank
  if (screenIdToShow === 'hubBank') {
    renderBankGrid();
    updateBankGoldUI();
  }
}

function playGlobalSound(src) {
  if (game.settings.isSfxMuted) return; // Use new sfxMuted setting
  try {
    const sound = new Audio(src);
    sound.volume = game.settings.sfxVolume; // Use new sfxVolume setting
    sound.play();
  } catch (e) {
    console.warn("Could not play sound", src, e);
  }
}
// --- END: Settings Functions ---


// --- MODIFIED: Added isDragging logic ---
document.addEventListener('DOMContentLoaded', ()=>{
  
  // +++ ADD THIS ENTIRE BLOCK OF LISTENERS +++
  
  // --- Hub Actions (Main Hub) ---
  document.getElementById('minesActionIcon').onclick = openMineHub;
  document.getElementById('forestActionIcon').onclick = openForestHub;
  document.getElementById('blacksmithActionIcon').onclick = openBlacksmithHub;
  document.getElementById('kitchenActionIcon').onclick = openKitchenHub;
  document.getElementById('combatActionIcon').onclick = openCombatHub;
  document.getElementById('shopActionIcon').onclick = openShop;
  document.getElementById('bankActionIcon').onclick = openBank;
  
  // --- Hub Mine Listeners ---
  document.getElementById('copperVeinBtn').onclick = openCopperMine;
  document.getElementById('ironVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= IRON_MINE_LVL) {
        openIronMine();
    } else {
        showTooltip(document.getElementById('ironVeinBtn'), 'Requires Mining Lvl: 10');
        setTimeout(hideTooltip, 1500); // Show a quick "locked" tooltip
    }
  };
  document.getElementById('coalVeinBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.mining.level >= COAL_MINE_LVL) {
        openCoalMine();
    } else {
        showTooltip(document.getElementById('coalVeinBtn'), 'Requires Mining Lvl: 5');
        setTimeout(hideTooltip, 1500); // Show a quick "locked" tooltip
    }
  };
  document.getElementById('hubMine_ReturnBtn').onclick = backToActions;
  
  // --- Hub Blacksmith Listeners ---
  document.getElementById('smithCopperTab').onclick = () => {
    document.getElementById('smithCopperTab').classList.add('active');
    document.getElementById('smithIronTab').classList.remove('active');
    renderSmithingItems('copper');
  };
  document.getElementById('smithIronTab').onclick = () => {
    document.getElementById('smithIronTab').classList.add('active');
    document.getElementById('smithCopperTab').classList.remove('active');
    renderSmithingItems('iron');
  };
  document.getElementById('hubBlacksmith_ReturnBtn').onclick = backToActions;

  // --- Hub Forest Listeners ---
  document.getElementById('softwoodTreeBtn').onclick = openSoftwoodTree;
  document.getElementById('oakTreeBtn').onclick = () => {
    // We check the level *before* trying to open the screen
    if (game.woodcutting.level >= OAK_TREE_LVL) {
        openOakTree();
    } else {
        showTooltip(document.getElementById('oakTreeBtn'), 'Requires Woodcutting Lvl: 10');
        setTimeout(hideTooltip, 1500); // Show a quick "locked" tooltip
    }
  };
  document.getElementById('hubForest_ReturnBtn').onclick = backToActions;

  // --- Hub Kitchen Listeners ---
  document.getElementById('cookChickenBtn').onclick = openCookChicken;
  document.getElementById('hubKitchen_ReturnBtn').onclick = backToActions;

  // --- Hub Combat Listeners ---
  document.getElementById('farmAreaBtn').onclick = openFarmCombatArea;
  document.getElementById('hubCombat_ReturnBtn').onclick = backToActions;
  
  // --- Hub Shop Listeners ---
  document.getElementById('buyPickaxeBtn').onclick = () => buyShopItem('Bronze Pickaxe', 10);
  document.getElementById('buyAxeBtn').onclick = () => buyShopItem('Bronze Axe', 10);
  document.getElementById('hubShop_ReturnBtn').onclick = backToActions;
  
  // --- Hub Bank Listeners ---
  document.getElementById('bankDepositGoldBtn').onclick = depositGold;
  document.getElementById('bankWithdrawGoldBtn').onclick = withdrawGold;
  document.getElementById('hubBank_ReturnBtn').onclick = backToActions;

  // --- Tooltips for Hub Icons ---
  document.getElementById('minesActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Mine</div>');
  document.getElementById('minesActionIcon').onmouseleave = hideTooltip;
  document.getElementById('forestActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Forest</div>');
  document.getElementById('forestActionIcon').onmouseleave = hideTooltip;
  document.getElementById('blacksmithActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Blacksmith</div>');
  document.getElementById('blacksmithActionIcon').onmouseleave = hideTooltip;
  document.getElementById('kitchenActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Kitchen</div>');
  document.getElementById('kitchenActionIcon').onmouseleave = hideTooltip;
  document.getElementById('combatActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Combat Areas</div>');
  document.getElementById('combatActionIcon').onmouseleave = hideTooltip;
  document.getElementById('shopActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
  document.getElementById('shopActionIcon').onmouseleave = hideTooltip;
  document.getElementById('bankActionIcon').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold);">Bank</div>');
  document.getElementById('bankActionIcon').onmouseleave = hideTooltip;
  
  // --- Tooltips for Hub Mine ---
  document.getElementById('copperVeinBtn').onmouseenter = (e) => showTooltip(e, '<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Copper Vein</div>Requires Mining Lvl: 1');
  document.getElementById('copperVeinBtn').onmouseleave = hideTooltip;
  document.getElementById('ironVeinBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Iron Vein</div>Requires Mining Lvl: ${IRON_MINE_LVL}`;
    showTooltip(e, tt);
  };
  document.getElementById('ironVeinBtn').onmouseleave = hideTooltip;
  document.getElementById('coalVeinBtn').onmouseenter = (e) => {
    const tt = `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Coal Vein</div>Requires Mining Lvl: ${COAL_MINE_LVL}`;
    showTooltip(e, tt);
  };
  document.getElementById('coalVeinBtn').onmouseleave = hideTooltip;
  
  // --- Tooltips for Hub Forest ---
  document.getElementById('softwoodTreeBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Softwood Tree</div>Requires Woodcutting Lvl: ${SOFTWOOD_TREE_LVL}`);
  document.getElementById('softwoodTreeBtn').onmouseleave = hideTooltip;
  document.getElementById('oakTreeBtn').onmouseenter = (e) => showTooltip(e, `<div style="font-weight:bold; color:var(--gold); margin-bottom: 4px;">Oak Tree</div>Requires Woodcutting Lvl: ${OAK_TREE_LVL}`);
  document.getElementById('oakTreeBtn').onmouseleave = hideTooltip;

  // --- Tooltips for Hub Kitchen ---
  document.getElementById('cookChickenBtn').onmouseenter = (e) => showTooltip(e, 'Requires: 1 Raw Chicken');
  document.getElementById('cookChickenBtn').onmouseleave = hideTooltip;

  // --- Tooltips for Hub Combat ---
  document.getElementById('farmAreaBtn').onmouseenter = (e) => showTooltip(e, 'Lvl Required: 1');
  document.getElementById('farmAreaBtn').onmouseleave = hideTooltip;

  // +++ END NEW LISTENER BLOCK +++
  
  
  // preloadAllGameAssets(); // <-- This line should already be here
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
  
  const inventoryGrid = document.getElementById('inventoryGrid');
  const inventoryGridWrap = document.getElementById('inventoryGridWrap');
  let draggedItemIndex = null;
  let currentDragOverSlot = null;
  
if (inventoryGridWrap) {
  inventoryGridWrap.addEventListener('dragover', (e) => {
    // Only scroll if we are actively dragging an item
    if (!game.isDragging) return;

    // We must prevent default for dragover to work
    e.preventDefault(); 

    const rect = inventoryGridWrap.getBoundingClientRect();
    const clientY = e.clientY;

    const scrollSpeed = 10; // Pixels to scroll per frame
    const threshold = 50;   // 50px trigger zone from the edge

    const topThreshold = rect.top + threshold;
    const bottomThreshold = rect.bottom - threshold;

    if (clientY < topThreshold) {
      // Mouse is near the top, scroll up
      inventoryGridWrap.scrollTop -= scrollSpeed;
    } else if (clientY > bottomThreshold) {
      // Mouse is near the bottom, scroll down
      inventoryGridWrap.scrollTop += scrollSpeed;
    }
  });
}

  inventoryGrid.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList.contains('inv-slot') && e.target.draggable) {
      draggedItemIndex = parseInt(e.target.dataset.slotIndex);
      e.dataTransfer.effectAllowed = 'move';
      
      // +++ NEW: Link to bank drag system +++
      const item = game.inventory[draggedItemIndex];
      if (item) {
        // Use the script-global draggedBankItem
        draggedBankItem = { item: { ...item }, fromIndex: draggedItemIndex };
      }
      // +++ END NEW +++

      // +++ NEW: Set dragging flag +++
      game.isDragging = true;
      
      setTimeout(() => {
        e.target.classList.add('dragging');
      }, 0);
    }
  });


  inventoryGrid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      if (currentDragOverSlot && currentDragOverSlot !== targetSlot) {
        currentDragOverSlot.classList.remove('drag-over');
      }
      targetSlot.classList.add('drag-over');
      currentDragOverSlot = targetSlot;
    }
  });
  
  inventoryGrid.addEventListener('dragleave', (e) => {
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      targetSlot.classList.remove('drag-over');
      if (currentDragOverSlot === targetSlot) {
        currentDragOverSlot = null;
      }
    }
  });

inventoryGrid.addEventListener('dragend', (e) => {
    // This event fires when the drag operation finishes, 
    // even if it's cancelled or dropped outside a valid target.
    
    // 1. Clean up the '.dragging' class
    const draggingEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    
    // 2. Clean up any lingering 'drag-over' styles
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    
    // 3. Reset all global drag state variables
    draggedItemIndex = null;
    draggedBankItem = null;
    game.isDragging = false;
  });

  inventoryGrid.addEventListener('drop', async (e) => {
    e.preventDefault();
    const dropSlot = e.target.closest('.inv-slot');
    
    // Cleanup first
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('#inventoryGrid .inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }

    if (!dropSlot) {
      draggedItemIndex = null;
      draggedBankItem = null;
      game.isDragging = false;
      return;
    }
    
    const dropIndex = parseInt(dropSlot.dataset.slotIndex);

    if (draggedBankItem && draggedBankItem.source === 'bank') {
      // --- BANK -> INVENTORY (Withdrawal) ---
      await dragWithdrawItem(draggedBankItem.fromIndex, dropIndex);

    } else if (draggedItemIndex !== null) {
      // --- INVENTORY -> INVENTORY (Internal Move) ---
      const fromIndex = draggedItemIndex;
      const toIndex = dropIndex;
      
      if (fromIndex !== toIndex) { 
        
        // --- Get the item data *before* the prompt ---
        const dragItemBeforePrompt = game.inventory[fromIndex];
        const dropItem = game.inventory[toIndex];

        // --- MODIFIED: Handle Shift-Click to move specific amount ---
        if (e.shiftKey && dragItemBeforePrompt) { 
          
          if (dropItem && dropItem.name !== dragItemBeforePrompt.name) {
            await showGameAlert("Invalid Slot", "You can only move onto an empty slot or a stack of the same item.");
          } else {
            const input = await showGamePrompt(
              `Move ${dragItemBeforePrompt.name}`, 
              `How many to move? (You have: ${dragItemBeforePrompt.qty})`,
              ""
            );
            
            // --- THIS IS THE FIX ---
            // After the prompt (await) is done, we re-check the inventory
            
            if (input === null) { 
              // User cancelled
              const originalSlotEl = document.querySelector(`#inventoryGrid .inv-slot[data-slot-index="${fromIndex}"]`);
              if (originalSlotEl) originalSlotEl.classList.remove('dragging');
              
            } else {
              // --- EXPLOIT FIX: Re-validate the item *after* the prompt ---
              const itemAfterPrompt = game.inventory[fromIndex];
              
              // Check if the item was consumed or changed
              if (!itemAfterPrompt || itemAfterPrompt.name !== dragItemBeforePrompt.name) {
                // The item was consumed! Abort the action.
                draggedItemIndex = null;
                draggedBankItem = null;
                game.isDragging = false;
                return; // Safely exit
              }
              // --- END EXPLOIT FIX ---
            
              const splitAmount = parseInt(input);
              
              if (isNaN(splitAmount) || splitAmount <= 0) { /* Invalid number */ }
              
              // Use the most up-to-date quantity
              else if (splitAmount > itemAfterPrompt.qty) { 
                await showGameAlert("Invalid Amount", "You don't have that many.");
              } 
              
              else if (splitAmount === itemAfterPrompt.qty) { 
                // Full stack move
                if (itemAfterPrompt && dropItem && itemAfterPrompt.name === dropItem.name) {
                    dropItem.qty += itemAfterPrompt.qty;
                    game.inventory[fromIndex] = null;
                } else {
                    game.inventory[fromIndex] = dropItem;
                    game.inventory[toIndex] = itemAfterPrompt;
                }
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
              
              else {
                // This is a valid SPLIT
                if (dropItem) { 
                  dropItem.qty += splitAmount;
                } else { 
                  game.inventory[toIndex] = { name: itemAfterPrompt.name, qty: splitAmount };
                }
                itemAfterPrompt.qty -= splitAmount; // Use the validated item
                
                renderInventoryGrid();
                if (typeof window.savePlayerData === 'function') savePlayerData();
              }
            }
          }
        } else {
          // --- This is the ORIGINAL Swap/Stack logic ---
          // We must re-get the dragItem in case it was consumed
          const dragItem = game.inventory[fromIndex]; 
          if (dragItem && dropItem && dragItem.name === dropItem.name) {
              dropItem.qty += dragItem.qty;
              game.inventory[fromIndex] = null;
          } else {
              game.inventory[fromIndex] = dropItem;
              game.inventory[toIndex] = dragItem;
          }
          renderInventoryGrid();
          if (typeof window.savePlayerData === 'function') savePlayerData();
        }
      }
    }
    
    // Final cleanup
    draggedItemIndex = null;
    draggedBankItem = null;
    game.isDragging = false;
  });
  
  // --- NEW: Settings Modal Listeners ---
  const settingsBtn = document.getElementById('settingsBtn');
  const closeSettingsBtn = document.getElementById('closeSettingsBtn');

  // --- SFX ---
  const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
  const sfxMuteBtn = document.getElementById('sfxMuteBtn');

  // --- Music ---
  const musicVolumeSlider = document.getElementById('musicVolumeSlider');
  const musicMuteBtn = document.getElementById('musicMuteBtn');

  if (settingsBtn) settingsBtn.onclick = openSettings;
  if (closeSettingsBtn) closeSettingsBtn.onclick = closeSettings;

  // --- SFX Slider Listener ---
  if (sfxVolumeSlider) {
    sfxVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.sfxVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isSfxMuted) {
        game.settings.isSfxMuted = false;
        applySettingsUI();
      }
      saveSettings(); // Save on change
    });
  }

  // --- SFX Mute Listener ---
  if (sfxMuteBtn) {
    sfxMuteBtn.onclick = () => {
      game.settings.isSfxMuted = !game.settings.isSfxMuted;
      applySettingsUI(); // Update button text/slider state
      saveSettings(); // Save the new mute state
    };
  }

  // --- Music Slider Listener ---
  if (musicVolumeSlider) {
    musicVolumeSlider.addEventListener('input', (e) => {
      const newVolume = parseFloat(e.target.value);
      game.settings.musicVolume = newVolume;
      // If they change volume, assume they want to unmute
      if (game.settings.isMusicMuted) {
        game.settings.isMusicMuted = false;
        applySettingsUI();
      }
      updateMusicPlayerState(); // Update live music volume
      saveSettings(); // Save on change
    });
  }

  // --- Music Mute Listener ---
  if (musicMuteBtn) {
    musicMuteBtn.onclick = () => {
      game.settings.isMusicMuted = !game.settings.isMusicMuted;
      applySettingsUI(); // Update button text/slider state
      updateMusicPlayerState(); // Update live music volume/mute

      // --- This is a bonus fix for autoplay ---
      // If music isn't playing yet, this click will start it.
      if (!game.settings.isMusicMuted && musicPlayer.paused) {
          musicPlayer.play().then(() => {
            audioAutoplayBlocked = false; 
          }).catch(e => console.warn("Could not start music."));
      }
      // --- End bonus fix ---

      saveSettings(); // Save the new mute state
    };
  }


  
});

window.showSaveIndicator = function() {
    const timerEl = document.getElementById('saveTimerText');
    if (timerEl) {
        timerEl.style.display = 'block';
        // Hide the message after 2 seconds
        setTimeout(() => {
            timerEl.style.display = 'none';
        }, 2000);
    }
}

</script>

<div id="itemContextMenu"></div>

<script>
  (function() {
    // This is the master list of all critical assets
    const MASTER_ASSET_LIST = [
      // Main UI & Background
      'images/brick_background.png',
      'images/gearicon.png',
      'images/goldpouch.png',
      
      // Main Hub Icons
      'images/mines.png',
      'images/foresticon.png',
      'images/blacksmithicon.png',
      'images/kitchenbutton.png',
      'images/combatareas.png',
      'images/shopbutton.png',
      'images/bankbutton.png',
  
      // Equipment Placeholders
      'images/helmet.png',
      'images/weapon.png',
      'images/chestplate.png',
      'images/boots.png',
  
      // Skill Icons
      'images/miningskillicon.png',
      'images/blacksmithskillicon.png',
      'images/attackskillicon.png',
      'images/strengthskillicon.png',
      'images/defenseskillicon.png',
      'images/vitalityskillicon.png',
      'images/cookingskillicon.png',
      'images/woodcuttingskillicon.png',
      
      // Resource/Hub Icons
      'images/coppervein.png',
      'images/ironvein.png',
      'images/coalvein.png',
      'images/farm.png',
  
      // Items: Tools
      'images/bronzepickaxe.png',
      'images/bronzeaxe.png',
      'images/copperpickaxe.png',
      'images/copperaxe.png',
      'images/ironpickaxe.png',
      'images/ironaxe.png',
  
      // Items: Ores & Bars
      'images/copperore.png',
      'images/copperbar.png',
      'images/coalore.png',
      'images/ironore.png',
      'images/ironbar.png',
  
      // Items: Wood
      'images/softwood.png',
      'images/oak.png',
  
      // Items: Food
      'images/rawchicken.png',
      'images/cookedchicken.png',
      'images/burntchicken.png',
  
      // Items: Copper Armor/Weapon
      'images/copperhelmet.png',
      'images/copperchestplate.png',
      'images/copperboots.png',
      'images/coppershortsword.png',
  
      // Items: Iron Armor/Weapon
      'images/ironhelmet.png',
      'images/ironchestplate.png',
      'images/ironboots.png',
      'images/ironshortsword.png',
  
      // Combat
      'images/chickenmonster.png',
      'images/chickenanim.gif'
    ];

    /**
     * This function creates a 'Promise' that only resolves
     * when the image has fully loaded (or failed).
     */
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null); // Don't fail the whole load
        img.src = src;
      });
    }

    /**
     * This function loads all images in the list at the same time
     * and waits for all of them to finish.
     */
    async function preloadAllAssets(urls) {
      const promises = urls.map(url => loadImage(url));
      await Promise.all(promises);
    }

    // --- Start the preload ---
    console.log(`[Preloader] Starting preload of ${MASTER_ASSET_LIST.length} assets...`);
    preloadAllAssets(MASTER_ASSET_LIST).then(() => {
      // --- This runs ONLY after all images are loaded ---
      console.log('[Preloader] All assets loaded.');
      
      const loadingScreen = document.getElementById('loadingScreen');
      const authScreen = document.getElementById('authScreen');

      if (loadingScreen) {
        loadingScreen.style.display = 'none'; // Hide loading
      }
      if (authScreen) {
        authScreen.style.display = 'flex'; // Show login
      }
    });

  })();
</script>

<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc,
    increment // <-- ADD THIS
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";
  
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // +++ --- NEW SESSION LOCK CONSTANTS & FUNCTIONS --- +++
  const LOCK_STALE_TIME_MS = 10000; // 10 seconds
  const LOCK_HEARTBEAT_MS = 999999999;  
  /**
   * (Helper) Gets the player doc ref.
   */
  function getPlayerRef() {
    const user = auth.currentUser;
    if (!user) return null;
    return doc(db, "players", user.uid);
  }

  /**
   * Shows the session lock overlay.
   */
  function showSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'flex';
  }
  
  /**
   * Hides the session lock overlay.
   */
  function hideSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'none';
  }

  /**
   * Starts the heartbeat to keep our session lock fresh.
   */
  // --- REPLACED WITH SIMPLIFIED FUNCTION (starting around line 802) ---
  /**
   * Starts the heartbeat to keep our session lock fresh.
   * NOTE: The active lock refresh logic is now solely handled by the 30s autosave
   * (or a separate manual save), so we only start a passive timer.
   */
  window.startSessionHeartbeat = function() {
    if (game.lockHeartbeat) return; // Already running
    
    // Use the extremely large interval, effectively making this timer passive.
    // The 30s autosave is now the only functional timer.
    game.lockHeartbeat = setInterval(() => {
        // This timer still runs, but the interval is so long it will rarely fire,
        // ensuring the 30s autosave is the primary write source.
    }, LOCK_HEARTBEAT_MS); 
  }

  /**
   * Stops the heartbeat.
   */
  window.stopSessionHeartbeat = function() {
    if (game.lockHeartbeat) {
      clearInterval(game.lockHeartbeat);
      game.lockHeartbeat = null;
    }
  }

  /**
   * Releases the session lock from Firebase.
   * @param {boolean} isAsync - If false, we can't wait for the update (e.g., closing tab).
   */
  window.releaseSessionLock = async function(isAsync = true) {
    stopSessionHeartbeat();
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    // We only release the lock if we are the one holding it.
    try {
      const promise = runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) return;
        const lock = snap.data().activeSession;
        if (lock && lock.id === game.sessionLockId) {
          transaction.update(playerRef, { activeSession: null });
        }
      });
      
      if (isAsync) {
        await promise;
      }
    } catch (e) {
      console.error("Failed to release lock:", e);
    }
  }
  
  /**
   * Tries to acquire the session lock using a transaction.
   * This is called when a lock is free or stale, or when user clicks "Take Control".
   */
  window.acquireSessionLock = async function() {
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    try {
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) throw new Error("Player doc does not exist.");
        
        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();
        
        // Check if a fresh lock is held by another session
        if (lock && lock.id !== game.sessionLockId && (now - lock.timestamp) < LOCK_STALE_TIME_MS) {
          throw new Error("Lock is still fresh and held by another session.");
        }
        
        // Lock is free, stale, or ours. Take it.
        const newLock = { id: game.sessionLockId, timestamp: now };
        transaction.update(playerRef, { activeSession: newLock });
      });
      
      // Success! We are now the active session.
      game.isSessionActive = true;
      
      // *** CRITICAL FIX ***: We no longer call startSessionHeartbeat() 
      // here to prevent the original 3s interval logic from running.
      // We rely purely on the 30s autosave for lock refresh.
      
      // startSessionHeartbeat(); <-- DELETE THIS LINE
      
      hideSessionLockOverlay();
      
    } catch (e) {
      console.error("Failed to acquire lock:", e.message);
      // We failed to get the lock, another tab must have beat us.
      // The onSnapshot listener will handle showing the overlay.
    }
  }
  // +++ --- END NEW SESSION LOCK FUNCTIONS --- +++


  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      
      // +++ NEW: Only the active session can save data +++
      if (!game.isSessionActive) return;
      
      const nameToSave = game.name || "";
      const inventoryToSave = [];
      // --- THIS IS THE FIX ---
      // This code was missing. It adds your inventory to the save file.
      game.inventory.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      // +++ NEW: Convert bank to save format +++
      const bankToSave = [];
      game.bank.forEach((item, index) => {
          if (item) {
              bankToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: inventoryToSave, 
        gold: game.gold,
        // +++ NEW +++
        bank: bankToSave,
        bankGold: game.bankGold,
        // +++ END NEW +++
        equipment: game.equipment, // <-- ADD THIS
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        blacksmith: {
          level: game.blacksmith.level,
          xp: game.blacksmith.xp,
          totalXP: game.blacksmith.totalXP
        },
        // +++ NEW ATTACK SAVE LOGIC +++
        attack: {
          level: game.attack.level,
          xp: game.attack.xp,
          totalXP: game.attack.totalXP
        },
        // +++ NEW STRENGTH AND DEFENCE SAVE LOGIC +++
        strength: {
          level: game.strength.level,
          xp: game.strength.xp,
          totalXP: game.strength.totalXP
        },
        defence: {
          level: game.defence.level,
          xp: game.defence.xp,
          totalXP: game.defence.totalXP
        },
        // +++ NEW VITALITY SAVE LOGIC +++
        vitality: {
          level: game.vitality.level,
          xp: game.vitality.xp,
          totalXP: game.vitality.totalXP
        },
        // +++ END NEW VITALITY SAVE LOGIC +++
        // +++ NEW COOKING SAVE LOGIC +++
        cooking: {
          level: game.cooking.level,
          xp: game.cooking.xp,
          totalXP: game.cooking.totalXP
        },
        // +++ NEW WOODCUTTING SAVE LOGIC +++
        woodcutting: {
          level: game.woodcutting.level,
          xp: game.woodcutting.xp,
          totalXP: game.woodcutting.totalXP
        },
        // +++ END NEW WOODCUTTING SAVE LOGIC +++
        playerAttackStyle: game.playerAttackStyle, // <-- ADD THIS
        updatedAt: new Date().toISOString()
        // We don't save activeSession here, that's handled by the lock functions
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
      
      // *** MODIFIED LINE ***
      if (typeof window.showSaveIndicator === 'function') {
        window.showSaveIndicator();
      }

    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- HEAVILY MODIFIED: loadPlayerDataAndStart (now handles session lock) ---
  async function loadPlayerDataAndStart(user) {
    try {
      if (playerDocListener) {
        playerDocListener();
        playerDocListener = null;
      }

      const ref = doc(db, "players", user.uid);
      let isFirstLoad = true; 
      
      playerDocListener = onSnapshot(ref, (snap) => {
        
        if (!snap.exists()) {
          console.log("Player document doesn't exist, showing start screen.");
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return; 
        }

        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();

        // --- 1. SESSION LOCK LOGIC ---
        if (!lock || (now - lock.timestamp > LOCK_STALE_TIME_MS)) {
          // Lock is free or stale. Try to acquire it.
          // We only do this if we're not *already* the active session.
          if (!game.isSessionActive) {
            acquireSessionLock();
          }
        } else if (lock.id !== game.sessionLockId) {
          // Another tab has a fresh lock. We are INACTIVE.
          game.isSessionActive = false;
          stopSessionHeartbeat();
          showSessionLockOverlay();
          // Stop any local actions immediately
          stopMining();
          stopBlacksmithing();
          if (game.inTrade) closeTradeWindow();
        } else {
          // We have the lock. We are ACTIVE.
          game.isSessionActive = true;
          hideSessionLockOverlay();
        }

        // --- 2. DATA SYNC LOGIC ---
        
        // Ignore our own "echo" saves
        if (snap.metadata.hasPendingWrites) {
          return;
        }
        
        // If we are the active tab, AND we are busy (mining, dragging, etc.),
        // do not sync data. This prevents rollbacks.
        if (game.isSessionActive && (game.miningActive || game.blacksmithingActive || game.cookingActive || game.woodcuttingActive || game.isDragging)) {
          return;
        }
        
        // If we are INACTIVE, OR we are ACTIVE and IDLE, sync the data.
        game.playerAttackStyle = data.playerAttackStyle || 'strength';
        
        // +++ NEW: Load Equipment +++
        game.equipment = data.equipment || { helmet: null, chest: null, weapon: null, boots: null };
        renderEquipment(); // <-- Render the equipment on load
        // +++ END NEW +++

        if (!data.name) {
          // This handles the case right after registration
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return;
        }

        game.name = data.name || game.name || "Adventurer";
        game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
        game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
        
        let loadedInventoryData = data.inventory || [];
        game.inventory = new Array(game.inventoryCapacity).fill(null);
        if (Array.isArray(loadedInventoryData)) {
            if (loadedInventoryData.length > 0 && typeof loadedInventoryData[0].slot === 'number') {
                loadedInventoryData.forEach(item => {
                    if (item && typeof item.slot === 'number' && item.slot < game.inventoryCapacity) {
                        game.inventory[item.slot] = { name: item.name, qty: item.qty };
                    }
                });
            } else if (loadedInventoryData.length > 0) {
                console.log("Migrating (buggy) array inventory...");
                for (let i = 0; i < loadedInventoryData.length && i < game.inventoryCapacity; i++) {
                    if(loadedInventoryData[i]) {
                      game.inventory[i] = { name: loadedInventoryData[i].name, qty: loadedInventoryData[i].qty };
                    }
                }
            }
        } else {
            console.log("Migrating legacy (object) inventory...");
            const entries = Object.entries(loadedInventoryData);
            for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
                game.inventory[i] = { name: entries[i][0], qty: entries[i][1] };
            }
        }
        
        game.gold = (typeof data.gold === 'number') ? data.gold : 0; 
        
        // +++ NEW: Load Bank Data +++
        game.bankGold = (typeof data.bankGold === 'number') ? data.bankGold : 0;
        let loadedBankData = data.bank || [];
        game.bank = new Array(game.bankCapacity).fill(null);
        if (Array.isArray(loadedBankData)) {
            loadedBankData.forEach(item => {
                if (item && typeof item.slot === 'number' && item.slot < game.bankCapacity) {
                    game.bank[item.slot] = { name: item.name, qty: item.qty };
                }
            });
        }
        // +++ END NEW +++
        
        if (data.mining) {
          game.mining.level = data.mining.level || 1;
          game.mining.xp = data.mining.xp || 0;
          game.mining.totalXP = data.mining.totalXP || getTotalXPForLevel(data.mining.level - 1) + data.mining.xp || 0; 
        } else {
          game.mining = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        if (data.blacksmith) {
          game.blacksmith.level = data.blacksmith.level || 1;
          game.blacksmith.xp = data.blacksmith.xp || 0;
          game.blacksmith.totalXP = data.blacksmith.totalXP || getTotalXPForLevel(data.blacksmith.level - 1) + data.blacksmith.xp || 0; 
        } else {
          game.blacksmith = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        // +++ NEW ATTACK LOADING LOGIC +++
        if (data.attack) {
          game.attack.level = data.attack.level || 1;
          game.attack.xp = data.attack.xp || 0;
          game.attack.totalXP = data.attack.totalXP || getTotalXPForLevel(data.attack.level - 1) + data.attack.xp || 0; 
        } else {
          game.attack = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW ATTACK LOADING LOGIC +++
        
        // +++ NEW STRENGTH LOADING LOGIC +++
        if (data.strength) {
          game.strength.level = data.strength.level || 1;
          game.strength.xp = data.strength.xp || 0;
          game.strength.totalXP = data.strength.totalXP || getTotalXPForLevel(data.strength.level - 1) + data.strength.xp || 0; 
        } else {
          game.strength = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW STRENGTH LOADING LOGIC +++
        
        // +++ NEW DEFENCE LOADING LOGIC +++
        if (data.defence) {
          game.defence.level = data.defence.level || 1;
          game.defence.xp = data.defence.xp || 0;
          game.defence.totalXP = data.defence.totalXP || getTotalXPForLevel(data.defence.level - 1) + data.defence.xp || 0; 
        } else {
          game.defence = { level: 1, xp: 0, totalXP: 0 }; 
        }
        //
        //

        // +++ NEW VITALITY LOADING LOGIC +++
        if (data.vitality) {
          game.vitality.level = data.vitality.level || 1;
          game.vitality.xp = data.vitality.xp || 0;
          game.vitality.totalXP = data.vitality.totalXP || getTotalXPForLevel(data.vitality.level - 1) + data.vitality.xp || 0; 
        } else {
          game.vitality = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW COOKING LOADING LOGIC +++
        if (data.cooking) {
          game.cooking.level = data.cooking.level || 1;
          game.cooking.xp = data.cooking.xp || 0;
          game.cooking.totalXP = data.cooking.totalXP || getTotalXPForLevel(data.cooking.level - 1) + data.cooking.xp || 0; 
        } else {
          game.cooking = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW VITALITY LOADING LOGIC +++
        
        // +++ NEW WOODCUTTING LOADING LOGIC +++
        if (data.woodcutting) {
          game.woodcutting.level = data.woodcutting.level || 1;
          game.woodcutting.xp = data.woodcutting.xp || 0;
          game.woodcutting.totalXP = data.woodcutting.totalXP || getTotalXPForLevel(data.woodcutting.level - 1) + data.woodcutting.xp || 0; 
        } else {
          game.woodcutting = { level: 1, xp: 0, totalXP: 0 }; 
        }
        // +++ END NEW WOODCUTTING LOADING LOGIC +++

        setText('charName', game.name);
        updateHPUI(); // This now calculates maxHP using game.vitality.level
        renderInventoryGrid();
        updateSkillUI();
        updateGoldUI(); 
        
        if (isFirstLoad) {
          window.renderLeaderboards(); 
          isFirstLoad = false;         
          backToActions(); 
        }
        
        startScreen.style.display = 'none';
        authScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        loadSettings();
        startMusicPlaylist();

      }, async (error) => { // <-- Add 'async' here
        console.error("Player listener error:", error);
        await showGameAlert("Load Error", "Error loading player data. Please refresh the page.");
      });
      
      const initialSnap = await getDoc(ref);
      if (!initialSnap.exists() || !initialSnap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false; 
      }

      return true; 
      
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }

  // --- MODIFIED: Added activeSession to new doc ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: [],
        gold: 0, 
        // +++ NEW +++
        bank: [],
        bankGold: 0,
        // +++ END NEW +++
        equipment: { helmet: null, chest: null, weapon: null, boots: null },
        mining: { level: 1, xp: 0, totalXP: 0 },
        blacksmith: { level: 1, xp: 0, totalXP: 0 }, 
        attack: { level: 1, xp: 0, totalXP: 0 }, 
        strength: { level: 1, xp: 0, totalXP: 0 }, 
        defence: { level: 1, xp: 0, totalXP: 0 }, 
        vitality: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW VITALITY FOR NEW ACCOUNTS +++
        cooking: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW COOKING FOR NEW ACCOUNTS +++
        woodcutting: { level: 1, xp: 0, totalXP: 0 }, // +++ NEW WOODCUTTING FOR NEW ACCOUNTS +++
        playerAttackStyle: 'strength',
        activeSession: null, // +++ ADD THIS
        createdAt: new Date().toISOString()
      });
      await showGameAlert("Account Created", "Your account has been created. You must now create your character.");
    } catch (err) {
      await showGameAlert("Registration Failed", err.message || "An unknown error occurred during registration.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) { await showGameAlert("Error", "Please enter an email and password."); return; }
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      await showGameAlert("Login Failed", err.message || "An unknown error occurred during login.");
      console.error(err);
    }
  };

  // --- MODIFIED: Handles session cleanup ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();

      const started = await loadPlayerDataAndStart(user);
      
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
        game.playerAttackStyle = 'strength';
      }
      
      if (started) {
        initChatListener();
        initTradeListeners();
        // The loadPlayerDataAndStart listener will automatically handle
        // acquiring the lock on first load.
      } else {
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // User is logged out
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      
      // Stop listeners and release lock
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();
      stopSessionHeartbeat();
      // We don't release the lock, just let it go stale.
      
      if (window.resetGameState) {
        window.resetGameState();
      }
      isTradeRequestsLoaded = false; 
    }
  });

  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) { await showGameAlert("Error", "Please enter a name for your character."); return; }
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            { await showGameAlert("Name Taken", "That name is already taken. Please choose another."); return; }
          }
        } catch (e) {
          console.error("Name check failed:", e);
          { await showGameAlert("Error", "An error occurred while checking the name. Please try again."); return; }
        }
        
        originalCreate(); // Sets game.name locally
        
        const user = auth.currentUser;
        if (user) {
          // --- THIS IS THE FIX ---
          // We MUST acquire the session lock *before* trying to save,
          // otherwise savePlayerData() will exit early because
          // game.isSessionActive is false.
          if (typeof window.acquireSessionLock === 'function') {
            await window.acquireSessionLock();
          }

          game.isSessionActive = true;
         

          await window.savePlayerData(); // This will now succeed
          window.renderLeaderboards();
          initChatListener(); 
          initTradeListeners(); 
          // The onSnapshot listener will fire and update the UI
        }
      };
    }
  })();
  
  // --- CHAT FUNCTIONS (Unchanged) ---
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false;
  let playerDocListener = null; 

  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;
    if (messageText.length === 0) return; 
    
    // +++ NEW: Prevent sending chat from inactive tab +++
    if (!game.isSessionActive) {
      await showGameAlert("Session Not Active", "This tab is not active. Take control to send messages.");
      return;
    }
    
    chatInput.value = '';
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; 
    }
    if (messageText.length > 256) {
      await showGameAlert("Error", "Your message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      await showGameAlert("Error", "You must be logged in and have a character to chat.");
      return;
    }
    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      await showGameAlert("Error", "Failed to send message. Please try again.");
    }
  }
  function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';
    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; 
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    chatMessagesContainer.prepend(msgElement); 
  }
  function initChatListener() {
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      let hasAdds = false; 
      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isChatHistoryLoaded) {
            hasAdds = true; 
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });
      if (!isChatHistoryLoaded) {
        isChatHistoryLoaded = true;
        let hadHistoryMessages = false;
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
        });
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; 
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      else if (hasAdds) {
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        chatMessagesContainer.scrollTop = 0;
      }
    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  
  // --- TRADE FUNCTIONS (Mostly Unchanged) ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; 
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    if (!isChatHistoryLoaded) {
      localMessageQueue.push({ text, type });
    } else {
      _addLocalMessageToDOM(text, type);
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      chatMessagesContainer.scrollTop = 0;
    }
  }
  function convertSavedInvToLocal(savedInvData) {
      const localInv = new Array(game.inventoryCapacity).fill(null);
      if (!Array.isArray(savedInvData)) {
          const entries = Object.entries(savedInvData);
          for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
              localInv[i] = { name: entries[i][0], qty: entries[i][1] };
          }
      } else {
          if (savedInvData.length > 0 && typeof savedInvData[0].slot === 'number') {
              savedInvData.forEach(item => {
                  if (item && item.slot < game.inventoryCapacity) {
                      localInv[item.slot] = { name: item.name, qty: item.qty };
                  }
              });
          } else if (savedInvData.length > 0) {
              for (let i = 0; i < savedInvData.length && i < game.inventoryCapacity; i++) {
                  if (savedInvData[i]) {
                      localInv[i] = { name: savedInvData[i].name, qty: savedInvData[i].qty };
                  }
              }
          }
      }
      return localInv;
  }
  function convertLocalInvToSaved(localInv) {
      const inventoryToSave = [];
      localInv.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      return inventoryToSave;
  }

  // =================================================================
  // --- 3. REPLACED 'checkItem' FUNCTION (module script) ---
  // This function now correctly SUMS all stacks.
  // =================================================================
  function checkItem(localInvArray, itemName, qty) {
      let totalQty = 0;
      for (const slot of localInvArray) {
          if (slot && slot.name === itemName) {
              totalQty += slot.qty;
          }
      }
      return totalQty >= qty;
  }

  // =================================================================
  // --- 4. REPLACED 'modifyInventory' FUNCTION (module script) ---
  // This function now correctly adds/removes from multiple stacks.
  // =================================================================
  function modifyInventory(localInvArray, itemName, qtyChange) {
      // Deep copy the array to avoid modifying the original
      const newInv = JSON.parse(JSON.stringify(localInvArray)); 
      
      if (qtyChange > 0) { // Adding items
          let amountToAdd = qtyChange;
          
          // 1. Try to stack first
          for (const slot of newInv) {
              if (slot && slot.name === itemName) {
                  slot.qty += amountToAdd;
                  amountToAdd = 0;
                  break; 
              }
          }
          
          // 2. If still items left, find an empty slot
          if (amountToAdd > 0) {
              let emptySlotIndex = newInv.findIndex(slot => slot === null);
              if (emptySlotIndex > -1) {
                  newInv[emptySlotIndex] = { name: itemName, qty: amountToAdd };
              } else {
                  // This should be caught by the transaction, but good to have
                  throw new Error(`Inventory full, cannot add ${itemName}.`);
              }
          }
      } else if (qtyChange < 0) { // Removing items
          let amountToRemove = Math.abs(qtyChange);
          
          // 1. Iterate backwards to empty smaller/later stacks first
          for (let i = newInv.length - 1; i >= 0; i--) {
              const slot = newInv[i];
              if (slot && slot.name === itemName) {
                  if (slot.qty > amountToRemove) {
                      // This stack has more than we need
                      slot.qty -= amountToRemove;
                      amountToRemove = 0;
                  } else {
                      // This stack will be emptied
                      amountToRemove -= slot.qty;
                      newInv[i] = null; // Empty the slot
                  }
              }
              if (amountToRemove === 0) break; // We're done
          }
          if (amountToRemove > 0) {
              // This should be impossible if checkItem was called first
              throw new Error(`Tried to remove more ${itemName} than available.`);
          }
      }
      return newInv;
  }
  // =================================================================
  // --- END OF REPLACEMENTS IN THIS SCRIPT BLOCK ---
  // =================================================================

  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);
            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addGold(amount); 
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self gold: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data(); // We still need this for the name
                await updateDoc(doc(db, "players", playerDoc.id), {
                    gold: increment(amount) // Use the atomic increment operation
                });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); 
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; 
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addItem(formattedName, qty); // Uses new addItem
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self item: ${e.message}`, 'error');
                }
                return true;
            }
            // This command now uses the NEW modifyInventory, so it will work
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                let currentLocalInv = convertSavedInvToLocal(playerData.inventory || []);
                const newLocalInv = modifyInventory(currentLocalInv, formattedName, qty); // Uses new modifyInventory
                const newSavedInv = convertLocalInvToSaved(newLocalInv);
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newSavedInv });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            const validSkills = ['mining', 'blacksmith', 'attack', 'strength', 'defence', 'vitality', 'cooking', 'woodcutting'];
if (!validSkills.includes(skill)) {
     addLocalChatMessage("Unknown skill. Use: mining, blacksmith, attack, strength, defence, vitality, cooking, or woodcutting.", 'error');
     return true;
}
            const newTotalXP = getTotalXPForLevel(level); 
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };
            if (targetName === game.name.toLowerCase()) {
                try {
                    game[skill] = newSkillData; 
                    updateSkillUI();
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Set own ${skill} level to ${level}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error setting self level: ${e.message}`, 'error');
                }
                return true;
            }
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { [skill]: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s ${skill} level to ${level}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
    }
    
    // +++ NEW: Check for active session before allowing trade +++
    if (!game.isSessionActive) {
      addLocalChatMessage("This tab is not active. Take control to trade.", 'error');
      return true; // It's a command, but it's blocked.
    }

    if (messageText.startsWith('/trade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    if (messageText.startsWith('/accepttrade ')) {
      addLocalChatMessage("The trade system is temporarily disabled for maintenance.", 'error');
      return true;
    }
    return false;
  }
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }
      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');
    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);
      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      const requestSnapshot = await getDocs(requestQuery);
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          return data.fromUid === requesterUid; 
      });
      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }
      const requestDoc = validRequests[0]; 
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      await batch.commit();
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); 
    tradeSessionUnsubscribes = []; 
    isTradeRequestsLoaded = false; 
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    // Trade requests are disabled due to maintenance.
    tradeRequestUnsubscribe = onSnapshot(requestQuery, () => {
      isTradeRequestsLoaded = true;
    }, (error) => console.error("Trade request listener error:", error));
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; 
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }
    if (game.blacksmithingActive) {
        stopBlacksmithing();
        game.wasMiningBeforeTrade = true; 
    }
    
    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    
    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    // --- THIS IS THE FIX ---
    // Use the session data to initialize the trade state
    game.myTradeOffer = sessionData[myRole];
    game.theirTradeOffer = sessionData[theirRole];
    // --- END FIX ---
    
    game.myTradeRole = myRole; 

    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    
    // Set the gold input to the *correct* initial value
    document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
    document.getElementById('tradeMyGoldOffer').max = game.gold;
    
    renderTradeInventory(); 
    // Render the grids with the data we just loaded
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); 
    renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems); 
    modal.style.display = 'flex'; 
    if (game.activeTradeListener) game.activeTradeListener(); 
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      const data = doc.data();
      if (data.status === 'cancelled') {
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      if (data.status === 'completed') {
        addLocalChatMessage("Trade complete!", 'trade');
        closeTradeWindow();
        return;
      }
      // --- THIS IS THE FIX ---
      // ONLY update THEIR offer from the snapshot
      game.theirTradeOffer = data[theirRole];
      
      // Manually sync our own "accepted" status
      // This is the ONLY part of our offer we want from the server
      game.myTradeOffer.accepted = data[myRole].accepted;

      // Render THEIR grid (our grid is updated locally)
      // We also update our inventory to show correct available amounts
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      renderTradeInventory();
      
      // We no longer need to check if we're typing, because we are
      // no longer syncing our own gold value from the server.
      
      // ONLY set THEIR gold display
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // Update statuses for both
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);
      // --- END FIX ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';

    // --- Create a map of available items from all stacks ---
    const availableItems = new Map();
    for (const slot of game.inventory) {
        if (slot) {
            const currentQty = availableItems.get(slot.name) || 0;
            availableItems.set(slot.name, currentQty + slot.qty);
        }
    }
    
    // --- Subtract offered items ---
    for (const [name, qty] of Object.entries(game.myTradeOffer.offerItems)) {
        if (availableItems.has(name)) {
            availableItems.set(name, availableItems.get(name) - qty);
        }
    }

    // --- Render the grid based on the calculated map ---
    availableItems.forEach((qtyAvailable, name) => {
      if (qtyAvailable <= 0) return; 

      const slotEl = document.createElement('div');
      slotEl.className = 'inv-slot';
      slotEl.onclick = () => addItemToOffer(name, qtyAvailable); 
      let imgName = name.toLowerCase().replace(/\s+/g,'_');
      if (name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      const img = document.createElement('img');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slotEl.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slotEl.appendChild(amt);
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slotEl.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slotEl.onmouseleave = hideTooltip;
      grid.appendChild(slotEl);
    });
  }
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    const itemEntries = Object.entries(items);
    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        const img = document.createElement('img');
        let imgName = name.toLowerCase().replace(/\s+/g,'_');
        if (name === 'Copper Bar') {
            imgName = 'copperbar';
        }
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }
  async function addItemToOffer(itemName, maxQty) {
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      // --- MODIFICATION HERE ---
      const input = await window.showGamePrompt( // Use window.showGamePrompt
        `Offer ${itemName}`,
        `How many ${itemName} do you want to offer? (Max: ${maxQty})`, 
        maxQty
      );
      if (input === null) return; 
      qtyToOffer = parseInt(input);
      // --- END MODIFICATION ---
    }
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      await window.showGameAlert("Invalid Amount", `You can only offer up to ${maxQty} of this item.`); // Use window.showGameAlert
      qtyToOffer = maxQty;
    }
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      await window.showGameAlert("Trade Full", "Your trade offer grid is full (16 unique items)."); // Use window.showGameAlert
      return;
    }
    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    game.myTradeOffer = newOfferObject;
    
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 

    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; 
    delete newOfferItems[itemName]; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 2. Update local UI IMMEDIATELY
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
    renderTradeInventory(); 
    // --- END FIX ---

    try {
      // 3. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    // --- THIS IS THE FIX ---
    // 1. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    // --- END FIX ---

    try {
      // 2. Send the update to the server
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true 
    };
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }
  async function cancelTrade() {
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;
    const sessionId = game.activeTradeSessionId;
    closeTradeWindow(); 
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
      }
    }
  }
  function closeTradeWindow() {
    if (!game.inTrade) return; 
    if (game.activeTradeListener) {
      game.activeTradeListener(); 
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; 
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    renderInventoryGrid();
    updateGoldUI();
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      const startBtn = document.getElementById('startMineBtn');
      const startSmithBtn = document.getElementById('startSmithBtn');
      if (startBtn) {
        startMining();
      } else if (startSmithBtn) { 
        startBlacksmithing();
      }
    }
  }
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);
        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }
        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;
        const p1LocalInv = convertSavedInvToLocal(p1Data.inventory || []);
        const p2LocalInv = convertSavedInvToLocal(p2Data.inventory || []);
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!checkItem(p1LocalInv, item, qty)) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        // --- This loop now uses the NEW 'checkItem' ---
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!checkItem(p2LocalInv, item, qty)) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }

        let newP1LocalInv = [...p1LocalInv];
        let newP2LocalInv = [...p2LocalInv];

        // --- These loops now use the NEW 'modifyInventory' ---
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
            newP1LocalInv = modifyInventory(newP1LocalInv, item, -qty);
            newP2LocalInv = modifyInventory(newP2LocalInv, item, +qty);
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
            newP2LocalInv = modifyInventory(newP2LocalInv, item, -qty);
            newP1LocalInv = modifyInventory(newP1LocalInv, item, +qty);
        }
        // --- End of new function usage ---

        const newP1SavedInv = convertLocalInvToSaved(newP1LocalInv);
        const newP2SavedInv = convertLocalInvToSaved(newP2LocalInv);
        transaction.update(sessionRef, { status: 'completed' });
        transaction.update(player1Ref, {
            gold: p1Data.gold - p1Offer.offerGold + p2Offer.offerGold,
            inventory: newP1SavedInv
        });
        transaction.update(player2Ref, {
            gold: p2Data.gold - p2Offer.offerGold + p1Offer.offerGold,
            inventory: newP2SavedInv
        });
      });
    } catch (e) {
      console.error("TRADE FAILED:", e);
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    contentContainer.innerHTML = `
      <div style="text-align:center; margin-top: 20px; color: #fff; opacity: 0.7;">Refreshing...</div>
    `;
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        
        // --- THIS IS THE FIX ---
        // We now get the totalXP from *all* skills and add them together.
        const miningXp = data.mining?.totalXP || 0; 
        const blacksmithXp = data.blacksmith?.totalXP || 0;
        const attackXp = data.attack?.totalXP || 0;
        const strengthXp = data.strength?.totalXP || 0;
        const defenceXp = data.defence?.totalXP || 0;
        const vitalityXp = data.vitality?.totalXP || 0;
        const cookingXp = data.cooking?.totalXP || 0;
        const woodcuttingXp = data.woodcutting?.totalXP || 0; // +++ NEW +++

        const totalXp = miningXp + blacksmithXp + attackXp + strengthXp + defenceXp + vitalityXp + cookingXp + woodcuttingXp;
        // --- END OF FIX ---

        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // --- MODIFIED: Added Session Lock Button ---
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = async () => {
          if (typeof window.savePlayerData === 'function') {
            await window.savePlayerData();
          }
          window.renderLeaderboards();
        };
    }
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); 
          sendChatMessage();
        }
      });
    }
    
    // +++ NEW: Session Lock Button +++
    const takeControlBtn = document.getElementById('takeControlButton');
    if (takeControlBtn) {
      takeControlBtn.onclick = () => {
        if (typeof window.acquireSessionLock === 'function') {
          window.acquireSessionLock();
        }
      };
    }
  });

  // --- Autosave runs every 30s, but only performs writes if the tab is visible ---
  setInterval(async () => {
    const user = auth.currentUser;

    // Check if user is logged in, is the active session, not in trade, AND THE TAB IS VISIBLE.
    if (user && game.isSessionActive && !game.inTrade && !document.hidden) {
        
      // 1. Refresh Lock Heartbeat (WRITE)
      // This update maintains the lock and prevents other tabs from stealing control.
      const playerRef = getPlayerRef();
      if (playerRef) {
          try {
              await updateDoc(playerRef, { "activeSession.timestamp": Date.now() }); 
          } catch (e) {
              console.error("Autosave Heartbeat failed:", e);
          }
      }
      
      // 2. Perform Full Save (WRITE)
      window.savePlayerData();
    }
    // If document.hidden is true, the timer function exits immediately with no writes.
  }, 9000);

  // --- MODIFIED: Releases session lock on tab close ---
  window.addEventListener('beforeunload', (e) => {
    try {
      // If we are the active session, release the lock
      if (game.isSessionActive) {
        if (typeof window.releaseSessionLock === 'function') {
          // Fire-and-forget, we can't wait for the update
          window.releaseSessionLock(false); 
        }
      }
      
      // Try one last save
      const user = auth.currentUser;
      if (user && game.isSessionActive && !game.inTrade) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // --- MODIFIED: Releases session lock on logout ---
  window.firebaseLogout = async function() {
  try {
    // 1. If in trade, cancel it first (Existing logic)
    if (game.inTrade && game.activeTradeSessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.warn("Could not cancel active trade on logout:", e);
      }
      closeTradeWindow();
    }
    
    // 2. +++ NEW CRITICAL FIX +++: Release the session lock explicitly
    if (game.isSessionActive) {
      if (typeof window.releaseSessionLock === 'function') {
        // Await the lock release before doing anything else
        await window.releaseSessionLock(true);
      }
    }
    stopSessionHeartbeat();
    
    // 3. Save, then sign out
    await window.savePlayerData();
    await signOut(auth);
    
    await showGameAlert("Logged Out", "You have been successfully logged out.");
  } catch (e) {
    console.error("Logout failed:", e);
    await showGameAlert("Logout Failed", "Logout failed. Please try again or close your browser.");
  }
};

  (function() {
    // --- This is the new master preloader ---

    // Define all critical images your game needs to start
    const MASTER_ASSET_LIST = [
      'images/brick_background.png',
      'images/gearicon.png',
      'images/helmet.png',
      'images/weapon.png',
      'images/chestplate.png',
      'images/boots.png',
      'images/goldpouch.png',
      'images/mines.png',
      'images/foresticon.png',
      'images/blacksmithicon.png',
      'images/kitchenbutton.png',
      'images/combatareas.png',
      'images/shopbutton.png',
      'images/bankbutton.png',
      'images/miningskillicon.png',
      'images/blacksmithskillicon.png',
      'images/attackskillicon.png',
      'images/strengthskillicon.png',
      'images/defenseskillicon.png',
      'images/vitalityskillicon.png',
      'images/cookingskillicon.png',
      'images/woodcuttingskillicon.png',
      'images/copperore.png',
      'images/copperbar.png',
      'images/coppershortsword.png',
      'images/copperhelmet.png',
      'images/copperchestplate.png',
      'images/copperboots.png',
      'images/rawchicken.png',
      'images/cookedchicken.png',
      'images/burntchicken.png',
      'images/chickenmonster.png',
      'images/chickenanim.gif',
      'images/coppervein.png',
      'images/coalvein.png',
      'images/ironvein.png',
      'images/farm.png',
      'images/softwood.png',
      'images/oak.png',
      'images/bronzepickaxe.png',
      'images/bronzeaxe.png',
      'images/copperpickaxe.png',
      'images/copperaxe.png',
      'images/ironpickaxe.png',
      'images/ironaxe.png',
      'images/ironore.png',
      'images/ironbar.png',
      'images/ironshortsword.png',
      'images/ironhelmet.png',
      'images/ironchestplate.png',
      'images/ironboots.png'
    ];

    /**
     * Preloads all assets and shows a loading screen
     * @param {string[]} assetList - Array of image paths
     * @returns {Promise}
     */
    function preloadAllAssets(assetList) {
      const authScreen = document.getElementById('authScreen');
      if (authScreen) authScreen.style.display = 'none';

      // Find the existing loading screen
      const loadingScreen = document.getElementById('loadingScreen');
      loadingScreen.style.display = 'flex'; // Make sure it's visible
      
      const loadingText = loadingScreen.querySelector('div');
      const progressText = document.createElement('p');
      progressText.id = 'loadingProgress';
      progressText.innerText = '0 / ' + assetList.length;
      if(loadingText) loadingText.appendChild(progressText);


      let loadedCount = 0;
      const promises = assetList.map(src => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            loadedCount++;
            if (progressText) {
              progressText.innerText = loadedCount + ' / ' + assetList.length;
            }
            resolve();
          };
          img.onerror = () => {
            console.warn(`[Preloader] Failed to load: ${src}`);
            resolve(); // Resolve anyway so the game doesn't hang
          };
          img.src = src;
        });
      });

      return Promise.all(promises);
    }

    // Run the preloader
    preloadAllAssets(MASTER_ASSET_LIST).then(() => {
      console.log('[Preloader] All assets loaded.');

      // +++ NEW: Force-decode the combat GIF +++
   const primeImg = document.createElement('img');
   primeImg.src = 'images/chickenanim.gif';
   primeImg.style.cssText = 'position:absolute; left:-9999px; top:-9999px;';
   document.body.appendChild(primeImg);
   // +++ END NEW +++
      
      const loadingScreen = document.getElementById('loadingScreen');
      const authScreen = document.getElementById('authScreen');

      if (loadingScreen) {
        loadingScreen.style.display = 'none'; // Hide loading
      }
      if (authScreen) {
        authScreen.style.display = 'flex'; // Show login
      }
    });

  })();
</script>
</body>
</html>