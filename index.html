<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rustic Skilling & Crafting Game</title>
<style>
 /* --- Base / Background --- */
:root {
  --panel-bg: rgba(64, 40, 20, 0.95); /* Deeper, earthier brown */
  --accent: #6d452d; /* Darker, richer wood tone */
  --accent-hover: #8a5a3a; /* Darker hover effect */
  --gold: #b5a642;
  --slot-size: 60px;
  --slot-gap: 10px;
}
body {
  margin: 0;
  font-family: "Garamond", serif;
  background: #3f2b21;
  background-image: url('images/brick_background.png');
  background-size: cover;
  background-attachment: fixed;
  background-position: center center;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

/* --- Start / Game screens --- */
#startScreen, #gameScreen {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
#gameScreen { display: none; }

/* --- Layout container (MODIFIED) --- */
.container {
  width: 100%;
  max-width: 1240px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 24px;
  box-sizing: border-box;
  margin: 0 auto;
}

/* --- Panel Row Wrappers --- */
#top-row-panels {
  display: flex;
  gap: 20px;
  align-items: stretch;
  width: 100%;
}

#bottom-row-chat {
  display: flex;
  gap: 20px;
  width: 100%;
}

/* --- Spacer for Chat Panel --- */
.sidebar-spacer {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  flex-shrink: 0;
}


/* --- Sidebar --- */
.sidebar {
  width: calc((var(--slot-size) * 4) + (var(--slot-gap) * 3) + 32px + 8px);
  background: var(--panel-bg);
  padding: 16px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.char-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
.char-header h2, .main h2, #leaderboardPanel h2 { 
  margin: 0; 
  font-size: 20px;
}

.hp-bar { background: #772222; border-radius: 6px; overflow: hidden; margin-bottom: 12px; position: relative; height: 28px; }
.hp-fill { height: 100%; background: #d22; width: 100%; transition: width 0.25s; }
.hp-text { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-size: 13px; }

.tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tabs button { flex: 1; padding: 10px; border-radius: 8px; border: 0; background: var(--accent); color: #fff; cursor: pointer; font-weight: 700; }
.tabs button:hover { background: var(--accent-hover); }

/* --- Equipment / Inventory / Skills --- */
.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

#equipmentTab {
  display: flex;
  flex-direction: column;
  justify-content: center;
  flex-grow: 1;
  padding-top: 70px;
}

.equipment-character { display: flex; justify-content: center; }
.character-frame { display: flex; flex-direction: column; align-items: center; }
.equipment-row { display: flex; justify-content: center; margin: 6px 0; gap: 10px; }
.equipment-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c69c6d;
  border-radius: 8px;
  border: 2px solid rgba(170,140,100,0.55);
  box-shadow: 0 3px 8px rgba(0,0,0,0.35);
  display: flex; align-items: center; justify-content: center; overflow: hidden;
}
.equipment-slot img { width: 100%; height: 100%; object-fit: contain; display: block; }

/* --- Inventory --- */
.inventory-grid-wrap {
  width: 100%;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4);
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--slot-size), 1fr));
  gap: var(--slot-gap);
  padding: var(--slot-gap); 
  align-content: start;
}
.inv-slot {
  width: var(--slot-size); height: var(--slot-size);
  background: #c8b89a33;
  border-radius: 8px;
  border: 2px solid rgba(120,90,50,0.25);
  position: relative;
  display: flex; align-items: center; justify-content: center; overflow: hidden;
  cursor: pointer;
}
.inv-slot img { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; }
.inv-amount {
  position: absolute;
  right: 4px; bottom: 4px;
  background: rgba(0,0,0,0.6);
  padding: 2px 5px;
  font-size: 12px;
  border-radius: 6px;
  color: #fff;
  font-weight: 700;
  pointer-events: none;
}

/* --- Tooltip --- */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: rgba(20,20,20,0.95);
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 2000;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  max-width: 240px;
}

/* --- Custom Scrollbar --- */
.inventory-grid-wrap::-webkit-scrollbar,
#chatMessages::-webkit-scrollbar {
  width: 8px;
}
.inventory-grid-wrap::-webkit-scrollbar-track,
#chatMessages::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb,
#chatMessages::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}
.inventory-grid-wrap::-webkit-scrollbar-thumb:hover,
#chatMessages::-webkit-scrollbar-thumb:hover {
  background: var(--accent-hover);
}

/* --- Main area --- */
.main {
  flex: 1;
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  min-height: 500px; 
  position: relative;
}

/* --- Chat Panel --- */
.chat-panel {
  background: var(--panel-bg);
  padding: 18px;
  border-radius: 10px;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border: 4px solid #453625;
  display: flex; 
  flex-direction: column;
  min-height: 200px;
  flex-shrink: 0;
  flex: 1;
}
#chatMessages {
  flex-grow: 1; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  padding: 8px; 
  overflow-y: auto; 
  height: 150px; 
  display: flex; 
  flex-direction: column-reverse;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#chatInputContainer { 
  display: flex; 
  gap: 8px; 
  margin-top: 10px;
}
#chatInput { 
  flex-grow: 1; 
  padding: 8px; 
  border-radius: 6px; 
  border: 1px solid var(--accent); 
  background: #3f2b21; 
  color: #fff;
}

/* --- Action Progress --- */
.progress-container {
  background: #7c644c;
  border-radius: 10px;
  height: 24px;
  overflow: hidden;
  position: relative;
}
.progress-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.08s; }
.action-buttons { margin-top: 14px; display: flex; gap: 10px; flex-wrap: wrap; }
button.primary {
  background: var(--accent); color: #fff; border: 0; padding: 10px 14px; border-radius: 8px; font-weight: 700; cursor: pointer;
}
button.primary:hover { background: var(--accent-hover); }

.xp-popup {
  position: absolute;
  background: #ffd700cc;
  color: #000;
  padding: 6px 10px;
  border-radius: 6px;
  font-weight: 800;
  pointer-events: none;
  z-index: 1500;
  transform-origin: center;
  animation: rise 900ms ease-out forwards;
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}
@keyframes rise {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-46px); opacity: 0; }
}

@media(max-width:900px) {
  .container { flex-direction: column; align-items: center; }
  #top-row-panels, #bottom-row-chat {
      flex-direction: column;
      width: 95%;
  }
  .sidebar, .main, .chat-panel { 
      width: 100%;
      box-sizing: border-box;
  }
  .sidebar-spacer {
      display: none;
  }
}

/* --- Trade Modal --- */
#tradeModal { display: none; }
.trade-content {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
  border-radius: 10px;
  padding: 20px;
  width: 90%;
  max-width: 1300px;
  min-height: 600px;
  display: flex;
  flex-direction: column;
}
.trade-main-area { display: flex; gap: 20px; flex: 1; }
.trade-panel {
  background: rgba(0,0,0,0.15);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  flex: 1;
}
.trade-gold-display {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 16px;
}
.trade-gold-display img { width: 30px; height: 30px; }
#tradeInventoryGridWrap {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--panel-bg);
}
#tradeMyOfferGrid, #tradeTheirOfferGrid {
  display: grid;
  grid-template-columns: repeat(4, var(--slot-size));
  grid-template-rows: repeat(4, var(--slot-size));
  gap: var(--slot-gap);
  padding: var(--slot-gap);
  align-content: start;
  height: calc((var(--slot-size) + var(--slot-gap)) * 4 + var(--slot-gap));
  background: rgba(0,0,0,0.2);
  border-radius: 6px;
}
.inv-slot.offer-slot-placeholder {
  background: rgba(120,90,50,0.1);
  border-style: dashed;
}
.trade-offer-layout { display: flex; gap: 20px; }
.trade-offer-box { flex: 1; display: flex; flex-direction: column; }
.trade-gold-input {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}
#tradeMyGoldOffer {
  width: 100px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid var(--accent);
  background: #3f2b21;
  color: #fff;
  font-size: 14px;
}
#tradeAcceptBtn {
  margin-top: 15px;
  background: var(--accent);
  font-size: 16px;
}
#tradeAcceptBtn:disabled {
  background: #555;
  opacity: 0.7;
  cursor: not-allowed;
}
.trade-status-indicator {
  margin-top: 10px;
  text-align: center;
  font-weight: bold;
  padding: 8px;
  border-radius: 6px;
}
#myTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#myTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}
#theirTradeStatus {
  background: rgba(150,0,0,0.3);
  color: #ffaaaa;
}
#theirTradeStatus.accepted {
  background: rgba(0,150,0,0.3);
  color: #aaffaa;
}

/* --- Drag & Drop --- */
.inv-slot.dragging {
  opacity: 0.4;
  cursor: grabbing;
}
.inv-slot.drag-over {
  border-color: var(--gold);
  border-style: dashed;
  background: rgba(181, 166, 66, 0.1);
}

/* +++ NEW: SESSION LOCK OVERLAY +++ */
#sessionLockOverlay {
  display: none; /* Hidden by default */
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0,0,0,0.85);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
}
#sessionLockOverlay div {
  background: var(--panel-bg);
  border: 4px solid #453625;
  box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  padding: 30px 40px;
  border-radius: 10px;
  max-width: 400px;
}
#sessionLockOverlay h2 {
  margin-top: 0;
  color: var(--gold);
}
/* +++ END NEW STYLES +++ */

</style>
</head>
<body>

<div id="authScreen" style="display:flex; align-items:center; justify-content:center; width:100%;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Login or Register</h1>
    <input id="authEmail" placeholder="Email" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:8px;"><br>
    <input id="authPassword" type="password" placeholder="Password" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;"><br>
    <div style="display:flex; gap:8px; justify-content:center;">
      <button class="primary" id="registerBtn">Register</button>
      <button class="primary" id="loginBtn" style="background:#666;">Login</button>
    </div>
    <div style="margin-top:12px; font-size:13px; opacity:0.9;">
      After login you will name your character and begin.
    </div>
  </div>
</div>

<div id="startScreen" style="display:none;">
  <div style="background:rgba(0,0,0,0.15); padding:26px; border-radius:12px; text-align:center;">
    <h1>Create your character</h1>
    <input id="playerName" placeholder="Enter name" style="padding:10px; font-size:16px; border-radius:8px; border:none; margin-bottom:12px;">
    <br>
    <button class="primary" onclick="createCharacter()">Create Character</button>
    <p style="margin-top:10px; font-size:13px; opacity:0.9;">Images: place them in <code>images/</code> (optional)</p>
  </div>
</div>


<div id="gameScreen">
  <div class="container">
    
    <div id="top-row-panels">
      
      <div class="sidebar">
        <div class="char-header">
          <h2 id="charName">Player</h2>
        </div>
        <div class="hp-bar">
          <div class="hp-fill" id="hpFill" style="width:100%"></div>
          <div class="hp-text" id="hpText">10 / 10 HP</div>
        </div>
        <div class="tabs">
          <button onclick="showTab('equipment')" id="tabEquipmentBtn">Equipment</button>
          <button onclick="showTab('inventory')" id="tabInventoryBtn">Inventory</button>
          <button onclick="showTab('skills')" id="tabSkillsBtn">Skills</button>
        </div>
        <div class="tab-content">
          <div id="equipmentTab">
            <div class="equipment-character">
              <div class="character-frame">
                <div class="equipment-row">
                  <div class="equipment-slot" id="helmet">
                    <img src="images/helmet.png" alt="Helmet">
                  </div>
                </div>
                <div class="equipment-row" style="align-items:center;">
                  <div class="equipment-slot" id="weapon">
                    <img src="images/weapon.png" alt="Weapon">
                  </div>
                  <div class="equipment-slot" id="chest">
                    <img src="images/chestplate.png" alt="Chest">
                  </div>
                </div>
                <div class="equipment-row">
                  <div class="equipment-slot" id="boots">
                    <img src="images/boots.png" alt="Boots">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div id="inventoryTab" style="display:none;">
            <div class="inventory-grid-wrap" id="inventoryGridWrap">
              <div class="inventory-grid" id="inventoryGrid"></div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 14px;">
            
              <div id="goldDisplay" style="display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 0px 8px;">
                <img src="images/goldpouch.png" alt="Gold" style="width: 60px; height: 60px; object-fit: contain;">
                <span id="goldAmountText" style="font-weight: bold; font-size: 16px; color: var(--gold); padding-top: 8px;">0</span>
              </div>
              
            </div>
            
          </div>
          
          <div id="skillsTab" style="display:none;">
            </div>
          
        </div>
      </div>

      <div class="main" id="mainArea">
        <div id="mainContentWrapper">
          </div>
        <button onclick="firebaseLogout()" class="primary" style="position: absolute; bottom: 18px; right: 18px; background: #900;">Log Out</button>
      </div>

      <div class="sidebar" id="leaderboardPanel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
          <h2>Leaderboard</h2>
          <button id="refreshLeaderboardBtn" class="primary" style="padding: 6px 10px; font-size: 12px;">Refresh</button>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid var(--accent); margin-bottom: 2px;">
          <span style="font-weight: bold;">TOTAL XP</span>
          <span style="font-weight: bold;">NAME</span>
        </div>
        <div id="leaderboardContent">
          <div style="text-align:center; margin-top: 10px; color: #fff; opacity: 0.7;">Loading leaderboard...</div>
        </div>
      </div>

    </div> 
    
    <div id="bottom-row-chat">

      <div class="sidebar-spacer"></div>

      <div class="chat-panel" id="chatPanel">
        <div id="chatMessages">
          </div>
        
        <div id="chatInputContainer">
          <input id="chatInput" type="text" placeholder="Type message...">
          <button id="chatSendBtn" class="primary" style="padding: 8px 12px;">Send</button>
        </div>
      </div>

      <div class="sidebar-spacer"></div>

    </div> 
    
  </div> 
</div>
<div id="tooltip" class="tooltip" style="display:none;"></div>

<div id="tradeModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;">
  
  <div class="trade-content">
    
    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 10px;">
      <h2 style="margin: 0;">Trade with <span id="tradePartnerName">Player</span></h2>
      <button id="tradeCancelBtn" class="primary" style="background:#900;">Cancel</button>
    </div>

    <div class="trade-main-area">

      <div class="trade-panel">
        <h3>Your Inventory</h3>
        <div class="trade-gold-display">
          My Gold: 
          <img src="images/goldpouch.png" alt="Gold">
          <span id="tradeMyGold">0</span>
        </div>
        <div class="inventory-grid-wrap" id="tradeInventoryGridWrap">
          <div class="inventory-grid" id="tradeInventoryGrid">
            </div>
        </div>
      </div>

      <div class="trade-panel" style="flex-grow: 1.5;">
        <div class="trade-offer-layout">

          <div class="trade-offer-box">
            <h4>Your Offer</h4>
            <div class="inventory-grid" id="tradeMyOfferGrid" data-grid-type="my-offer">
              </div>
            <div class="trade-gold-input">
              <label for="tradeMyGoldOffer">Gold:</label>
              <input type="number" id="tradeMyGoldOffer" min="0" value="0">
            </div>
            <button id="tradeAcceptBtn" class="primary">Accept</button>
            <div id="myTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

          <div class="trade-offer-box">
            <h4>Their Offer</h4>
            <div class="inventory-grid" id="tradeTheirOfferGrid">
              </div>
            <div class="trade-gold-input">
              <span>Gold:</span>
              <span id="tradeTheirGoldOffer">0</span>
            </div>
            <div id="theirTradeStatus" class="trade-status-indicator">Not Accepted</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<div id="sessionLockOverlay" style="display: none;">
  <div>
    <h2>Session Active Elsewhere</h2>
    <p>This account is already being played in another tab or browser. To prevent data corruption, this tab has been disabled.</p>
    <button id="takeControlButton" class="primary">Take Control Here</button>
  </div>
</div>

<script>
// --- Game State (MODIFIED) ---
const game = {
  name: '',
  hp: 10,
  maxHP: 10,
  inventory: [], 
  inventoryCapacity: 39,
  gold: 0, 
  mining: { level: 1, xp: 0, totalXP: 0 },
  blacksmith: { level: 1, xp: 0, totalXP: 0 },
  miningActive: false,
  blacksmithingActive: false, 
  progressFrame: null,
  wasMiningBeforeTrade: false,
  shopOpen: false, 
  isAdmin: false,
  
  // +++ NEW SESSION LOCK +++
  // This is a unique ID for this specific tab
  sessionLockId: (function() {
  let id = sessionStorage.getItem('gameSessionId');
  if (!id) {
    // No ID exists, so this is a new tab. Create one.
    id = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    sessionStorage.setItem('gameSessionId', id);
  }
  // Return the persistent ID for this tab
  return id;
})(),
// +++ END MODIFICATION +++

lockHeartbeat: null,    // This will hold the setInterval ID for the heartbeat
isSessionActive: false, // Is this tab the "master" tab?
isDragging: false,      // Are we currently dragging an item?

inTrade: false,
activeTradeSessionId: null,
activeTradeListener: null, 
myTradeRole: null, 
myTradeOffer: { offerItems: {}, offerGold: 0, accepted: false },
theirTradeOffer: { offerItems: {}, offerGold: 0, accepted: false }
};
// +++ END MODIFICATION +++

game.inventory = new Array(game.inventoryCapacity).fill(null);

const VALID_ITEMS = [
  'Copper Ore',
  'Copper Bar'
];

function setText(id, text){ const el=document.getElementById(id); if(el) el.innerText=text; }

function formatAmount(n) {
  if (n < 1000) return n.toString();
  if (n < 1000000) return parseFloat((n / 1000).toFixed(2)) + 'k';
  return parseFloat((n / 1000000).toFixed(2)) + 'M';
}

function createCharacter(){
  const name = document.getElementById('playerName').value.trim();
  if(!name) return; 
  game.name = name;
  document.getElementById('charName').innerText = name;
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI();
  backToActions(); 
}

function updateHPUI(){
  const percent = Math.min(100, Math.round((game.hp / game.maxHP) * 100));
  document.getElementById('hpFill').style.width = percent + '%';
  setText('hpText', `${game.hp} / ${game.maxHP} HP`);
}

function updateGoldUI() {
  setText('goldAmountText', formatAmount(game.gold));
}

function addGold(amount) {
  game.gold = Math.max(0, game.gold + amount);
  updateGoldUI();
}

function showTab(tab){
  document.getElementById('equipmentTab').style.display = 'none';
  document.getElementById('inventoryTab').style.display = 'none';
  document.getElementById('skillsTab').style.display = 'none';
  document.getElementById(tab + 'Tab').style.display = 'block';
}

function renderInventoryGrid(){
  const grid = document.getElementById('inventoryGrid');
  grid.innerHTML = '';
  const capacity = game.inventoryCapacity;

  for(let i = 0; i < capacity; i++){
    const slotData = game.inventory[i];
    const slot = document.createElement('div');
    slot.className = 'inv-slot';
    slot.dataset.slotIndex = i;
    
    if(slotData){
      slot.draggable = true;
      const item = slotData;
      const img = document.createElement('img');
      let imgName = item.name.toLowerCase().replace(/\s+/g,'_');
      if (item.name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      img.src = `images/${imgName}.png`;
      img.alt = item.name;
      img.onerror = function(){ this.style.opacity='0.08'; this.style.filter='grayscale(90%)'; };
      slot.appendChild(img);
      
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(item.qty); 
      slot.appendChild(amt);
      
      const exactAmount = item.qty.toLocaleString(); 
      const itemName = item.name;
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${itemName}</div>
        <div style="color:#fff;">Amount: ${exactAmount}</div>
      `;
      slot.onmouseenter = (evt) => {
        showTooltip(evt, tooltipContent);
      };
      slot.onmouseleave = () => {
        hideTooltip();
      };
      slot.onclick = () => {
        handleSellItemClick(item.name, item.qty);
      };
    } else {
      slot.draggable = false;
    }
    grid.appendChild(slot);
  }
}

function addItem(name, qty=1){
  let existingSlot = game.inventory.find(slot => slot && slot.name === name);
  if (existingSlot) {
    existingSlot.qty += qty;
  } else {
    let emptySlotIndex = game.inventory.findIndex(slot => slot === null);
    if (emptySlotIndex > -1) {
      game.inventory[emptySlotIndex] = { name: name, qty: qty };
    } else {
      console.warn(`Inventory full! Could not add ${name}`);
      return; 
    }
  }
  renderInventoryGrid();
}

function removeItem(name, qty = 1) {
  let slotIndex = game.inventory.findIndex(slot => slot && slot.name === name);
  if (slotIndex === -1) {
    console.warn(`Tried to remove item not in inventory: ${name}`);
    return false;
  }
  const slot = game.inventory[slotIndex];
  if (slot.qty < qty) {
    console.warn(`Tried to remove ${qty} ${name}, but only have ${slot.qty}`);
    return false; 
  }
  slot.qty -= qty;
  if (slot.qty <= 0) {
    game.inventory[slotIndex] = null;
  }
  return true;
}

function handleSellItemClick(itemName, currentQty) {
  if (!game.shopOpen) return;
  let sellPrice = 0;
  if (itemName === 'Copper Ore') {
    sellPrice = 1;
  } else {
    alert("This shop doesn't buy that item.");
    return;
  }
  let qtyToSell = 0;
  if (currentQty === 1) {
    qtyToSell = 1;
  } else {
    const input = prompt(`How many ${itemName} do you want to sell? (You have: ${currentQty})`, currentQty);
    if (input === null) return;
    qtyToSell = parseInt(input);
  }
  if (isNaN(qtyToSell) || qtyToSell <= 0) return;
  if (qtyToSell > currentQty) {
    alert("You don't have that many to sell.");
    return;
  }
  const totalGold = qtyToSell * sellPrice;
  const confirmed = confirm(`Are you sure you want to sell ${qtyToSell} ${itemName} for ${totalGold} Gold?`);
  
  if (confirmed) {
    if (removeItem(itemName, qtyToSell)) {
        addGold(totalGold);
        hideTooltip(); 
        renderInventoryGrid();
        if (game.inTrade) {
          renderTradeInventory();
        }
        alert(`You sold ${qtyToSell} ${itemName} for ${totalGold} Gold.`);
    } else {
        alert("Something went wrong, the sale did not complete.");
    }
  }
}

const tooltip = document.getElementById('tooltip');
function showTooltip(evt, content) {
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.display = 'block';
  moveTooltip(evt);
}
function hideTooltip() {
  if (!tooltip) return;
  tooltip.style.display = 'none';
}
function moveTooltip(evt) {
  if (!tooltip || tooltip.style.display === 'none') return;
  const tooltipRect = tooltip.getBoundingClientRect();
  let x = evt.clientX + 10;
  let y = evt.clientY + 10;
  if (x + tooltipRect.width > window.innerWidth) {
    x = evt.clientX - tooltipRect.width - 10;
  }
  if (y + tooltipRect.height > window.innerHeight) {
    y = evt.clientY - tooltipRect.height - 10;
  }
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
}

function getNextXP(level){ return Math.floor(100 * Math.pow(1.15, level-1)); }
function getTotalXPForLevel(level) {
    let total = 0;
    for(let i = 1; i < level; i++) {
        total += getNextXP(i);
    }
    return total;
  }

function updateSkillUI(){
  const skillsTab = document.getElementById('skillsTab');
  if (!skillsTab) return;
  
  // Clear the tab and set up the header/container
  skillsTab.innerHTML = `
    <div style="font-size:14px; margin-bottom:12px;">Skills</div>
    <div id="skillIconsContainer" style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: flex-start;">
      </div>
  `;

  const container = document.getElementById('skillIconsContainer');

  /**
   * Helper function to create a skill icon with a tooltip
   * @param {string} skillName - The display name (e.g., "Mining")
   * @param {string} skillDataKey - The key in the game object (e.g., "mining")
   * @param {string} iconFileName - The name of the icon file in /images/
   */
  const createSkillIcon = (skillName, skillDataKey, iconFileName) => {
    const data = game[skillDataKey];
    const iconWrapper = document.createElement('button');
    iconWrapper.className = 'primary'; // Use 'primary' class for base styling
    iconWrapper.style.cssText = `
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 5px; 
      padding: 8px 10px; 
      height: 80px; /* Fixed height for consistency */
      width: 80px;  /* Fixed width for consistency */
      justify-content: center;
      font-size: 13px;
      background: var(--accent);
      border: 2px solid #50311f; /* Added a border to define the button */
      transition: all 0.15s ease;
    `;
    
    // --- Create the tooltip content ---
    const nextXP = getNextXP(data.level);
    // Calculate progress percentage, ensuring it doesn't exceed 100%
    const progressPercent = Math.min(100, (data.xp / nextXP) * 100);
    
    const tooltipContent = `
      <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${skillName}</div>
      <div style="font-size: 14px; margin-bottom: 6px;">Level: <span style="font-weight: bold;">${data.level}</span></div>
      <div>XP: ${data.xp.toLocaleString()} / ${nextXP.toLocaleString()}</div>
      <div>(Total XP: ${data.totalXP.toLocaleString()})</div>
      
      <div style="width: 100%; height: 8px; background: #555; border-radius: 4px; margin-top: 8px; border: 1px solid #333;">
        <div style="height: 100%; width: ${progressPercent}%; background: #4caf50; border-radius: 4px; transition: width 0.2s;"></div>
      </div>
    `;

    // Set up hover/tooltip events
    iconWrapper.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
    iconWrapper.onmouseleave = hideTooltip;

    // Create and append icon image
    const img = document.createElement('img');
    img.src = `images/${iconFileName}`;
    img.alt = skillName;
    img.style.cssText = 'width: 40px; height: 40px; object-fit: contain; margin-bottom: 2px; pointer-events: none;';
    img.onerror = function(){ this.style.opacity='0.1'; this.style.filter='grayscale(100%)'; }; // Fallback
    iconWrapper.appendChild(img);

    // Append level text
    const levelText = document.createElement('span');
    levelText.innerText = `Lvl ${data.level}`;
    levelText.style.fontWeight = 'bold';
    levelText.style.pointerEvents = 'none';
    iconWrapper.appendChild(levelText);

    container.appendChild(iconWrapper);
  };

  // --- Call the function for each of your skills ---
  createSkillIcon('Mining', 'mining', 'miningskillicon.png');
  createSkillIcon('Blacksmith', 'blacksmith', 'blacksmithskillicon.png');
}

function showItemPopup(text, progressElementId) {
    const main = document.getElementById('mainArea');
    if (!main) return;
    const popup = document.createElement('div');
    popup.className = 'xp-popup';
    popup.innerHTML = text; // Allow HTML
popup.style.lineHeight = '1.4';
    const bar = document.getElementById(progressElementId);
    if (bar) {
        const barRect = bar.getBoundingClientRect();
        const mainRect = main.getBoundingClientRect();
        const relativeX = barRect.left - mainRect.left;
        const relativeY = barRect.top - mainRect.top;
        popup.style.left = (relativeX + barRect.width / 2 - 40) + 'px';
        popup.style.top = (relativeY - 30) + 'px';
    } else {
        popup.style.left = '50%';
        popup.style.top = '120px';
        popup.style.transform = 'translateX(-50%)';
    }
    main.appendChild(popup);
    setTimeout(()=>popup.remove(), 900);
}

function addXP(skill, amount){
  if (!game[skill]) {
      console.warn(`Skill "${skill}" does not exist.`);
      return;
  }
  game[skill].totalXP += amount; 
  game[skill].xp += amount;
  while(game[skill].xp >= getNextXP(game[skill].level)){
    game[skill].xp -= getNextXP(game[skill].level);
    game[skill].level++;
  }
  updateSkillUI();
  let barId = '';
  if (skill === 'mining') barId = 'mineProgress';
  if (skill === 'blacksmith') barId = 'smithProgress';
  if (skill !== 'blacksmith' && skill !== 'mining') { // Don't show popup for blacksmith, it will be handled manually
  showItemPopup(`+${amount} ${skill.toUpperCase()} XP`, barId);
 }

}

const MINE_TIME_MS = 1500;
const MINE_XP = 15;
const MINE_ITEM = 'Copper Ore';

// --- MODIFIED: Added Session Lock Check ---
function startMining() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.miningActive) return; 
  game.miningActive = true;
  const startBtn = document.getElementById('startMineBtn');
  const stopBtn = document.getElementById('stopMineBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
}

function miningLoop(timestamp, startTime) {
  if (!game.miningActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / MINE_TIME_MS) * 100;

  if (progress >= 100) {
    addItem(MINE_ITEM, 1);
    addXP('mining', MINE_XP); // This now adds XP without a popup

    // Create the new combined popup
    const popupText = `+${MINE_XP} Mining XP<br>+1 Copper Ore`;
    showItemPopup(popupText, 'mineProgress');
    
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = '0%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, now));
  } else {
    const bar = document.getElementById('mineProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => miningLoop(now, startTime));
  }
}

function stopMining(){
  game.miningActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('mineProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startMineBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopMineBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

const SMITH_TIME_MS = 5000;
const SMITH_XP = 25;
const SMITH_ORE_COST = 2;
const SMITH_BAR_ITEM = 'Copper Bar';

// --- MODIFIED: Added Session Lock Check ---
function startBlacksmithing() {
  if (!game.isSessionActive) {
    alert("This game session is not active. Please take control to perform actions.");
    return;
  }
  if (game.blacksmithingActive) return;

  const copperSlot = game.inventory.find(slot => slot && slot.name === 'Copper Ore');
  if (!copperSlot || copperSlot.qty < SMITH_ORE_COST) {
      alert(`You need at least ${SMITH_ORE_COST} Copper Ore to smith a bar.`);
      return;
  }
  
  game.blacksmithingActive = true;
  const startBtn = document.getElementById('startSmithBtn');
  const stopBtn = document.getElementById('stopSmithBtn');
  if (startBtn) startBtn.style.display = 'none';
  if (stopBtn) stopBtn.style.display = 'inline-block';
  game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
}

function blacksmithingLoop(timestamp, startTime) {
  if (!game.blacksmithingActive) return; 
  const elapsed = timestamp - startTime;
  let progress = (elapsed / SMITH_TIME_MS) * 100;

  if (progress >= 100) {
    const copperSlot = game.inventory.find(slot => slot && slot.name === 'Copper Ore');
    if (!copperSlot || copperSlot.qty < SMITH_ORE_COST) {
        alert("You've run out of Copper Ore.");
        stopBlacksmithing();
        return;
    }
    removeItem('Copper Ore', SMITH_ORE_COST);
    addItem(SMITH_BAR_ITEM, 1);
    addXP('blacksmith', SMITH_XP); // This now adds XP without a popup
    
    // Create the new combined popup
    const popupText = `+${SMITH_XP} Blacksmith XP<br>+1 Copper Bar`;
    showItemPopup(popupText, 'smithProgress');
    
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = '0%';
    
    const copperSlotAgain = game.inventory.find(slot => slot && slot.name === 'Copper Ore');
    if (!copperSlotAgain || copperSlotAgain.qty < SMITH_ORE_COST) {
        alert("You don't have enough ore to smith another bar.");
        stopBlacksmithing();
        return;
    }
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, now));
  } else {
    const bar = document.getElementById('smithProgress');
    if (bar) bar.style.width = progress + '%';
    game.progressFrame = requestAnimationFrame((now) => blacksmithingLoop(now, startTime));
  }
}

function stopBlacksmithing(){
  game.blacksmithingActive = false;
  if(game.progressFrame) cancelAnimationFrame(game.progressFrame);
  const bar = document.getElementById('smithProgress');
  if(bar) bar.style.width = '0%';
  const startBtn = document.getElementById('startSmithBtn');
  if(startBtn) startBtn.style.display = 'inline-block';
  const stopBtn = document.getElementById('stopSmithBtn');
  if(stopBtn) stopBtn.style.display = 'none';
  if (typeof window.savePlayerData === 'function') window.savePlayerData();
}

function openCopperBarSmith(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Smithing - Copper Bar</h2>
    <div style="margin-top:8px; color:#efe3cf;">Requires: 2 Copper Ore.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="smithProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startSmithBtn" class="primary">Start Smithing</button>
      <button id="stopSmithBtn" class="primary" style="background:#555; display:none;">Stop Smithing</button>
      <button onclick="openBlacksmithHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startSmithBtn').onclick = startBlacksmithing;
  document.getElementById('stopSmithBtn').onclick = stopBlacksmithing;
}

function openBlacksmithHub() {
  game.shopOpen = false;
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Blacksmith</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose an item to smith.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
      <button id="copperBarBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/copperbar.png" alt="Copper Bar" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Bar</span>
      </button>
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const copperBarBtn = document.getElementById('copperBarBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (copperBarBtn) {
    copperBarBtn.onclick = openCopperBarSmith;
    copperBarBtn.onmouseenter = (event) => {
      showTooltip(event, 'Requires: 2 Copper Ore');
    };
    copperBarBtn.onmouseleave = hideTooltip;
  }
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function openCopperMine(){
  game.shopOpen = false; 
  hideTooltip();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Beginner Mine - Copper vein</h2>
    <div style="margin-top:8px; color:#efe3cf;">A low level copper vein.</div>
    <div style="margin-top:16px;">
      <div class="progress-container">
        <div class="progress-fill" id="mineProgress"></div>
      </div>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="startMineBtn" class="primary">Start Mining</button>
      <button id="stopMineBtn" class="primary" style="background:#555; display:none;">Stop Mining</button>
      <button onclick="openMineHub()" class="primary" style="background:#666;">Return</button> </div>
  `;
  document.getElementById('startMineBtn').onclick = startMining;
  document.getElementById('stopMineBtn').onclick = stopMining;
}

function openMineHub() {
  game.shopOpen = false; 
  hideTooltip();
  stopMining(); 
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>Mines</h2>
    <div style="margin-top:8px; color:#efe3cf;">Choose a mine to enter.</div>
    <div class="action-buttons" style="margin-top:14px; display:flex; flex-direction:column; align-items:flex-start;">
      <button id="copperVeinBtn" class="primary" style="display: flex; align-items: center; gap: 10px;">
        <img src="images/coppervein.png" alt="Copper Vein" style="width: 40px; height: 40px; border-radius: 4px; object-fit: contain;">
        <span>Copper Vein</span>
      </button>
      <button id="returnToActionsBtn" class="primary" style="background:#666; margin-top: 30px;">Return</button>
    </div>
  `;
  const copperBtn = document.getElementById('copperVeinBtn');
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (copperBtn) {
    copperBtn.onclick = openCopperMine;
    copperBtn.onmouseenter = (event) => {
      showTooltip(event, 'Lvl Required: 1');
    };
    copperBtn.onmouseleave = hideTooltip;
  }
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function backToActions(){
  game.shopOpen = false; 
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <div id="actionScreen" style="display: flex; gap: 10px;">
      <img id="minesActionIcon" src="images/mines.png" alt="Mines" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="blacksmithActionIcon" src="images/blacksmithicon.png" alt="Blacksmith" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
      <img id="shopActionIcon" src="images/shopbutton.png" alt="Shop" style="margin-top: 10px; cursor: pointer; width: 60px; height: 60px; object-fit: contain;">
    </div>
  `;
  const minesIcon = document.getElementById('minesActionIcon');
  const blacksmithIcon = document.getElementById('blacksmithActionIcon');
  const shopIcon = document.getElementById('shopActionIcon'); 
  if (minesIcon) {
    minesIcon.onclick = openMineHub;
    minesIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Mines</div>');
    };
    minesIcon.onmouseleave = hideTooltip;
  }
  if (blacksmithIcon) {
    blacksmithIcon.onclick = openBlacksmithHub; 
    blacksmithIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Blacksmith</div>');
    };
    blacksmithIcon.onmouseleave = hideTooltip;
  }
  if (shopIcon) {
    shopIcon.onclick = openShop; 
    shopIcon.onmouseenter = (event) => {
      showTooltip(event, '<div style="font-weight:bold; color:var(--gold);">Shop</div>');
    };
    shopIcon.onmouseleave = hideTooltip;
  }
}

function openShop() {
  hideTooltip();
  stopMining();
  stopBlacksmithing();
  game.shopOpen = true; 
  const wrapper = document.getElementById('mainContentWrapper');
  wrapper.innerHTML = `
    <h2>General Store</h2>
    <div style="margin-top:8px; color:#efe3cf;">
      Click an item in your inventory to sell it.
    </div>
    <div style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.1); border-radius:6px;">
      <strong>Items you can sell:</strong>
      <ul style="margin: 5px 0 0 20px; padding: 0;">
        <li style="margin-top:5px;">Copper Ore - 1 Gold each</li>
      </ul>
    </div>
    <div class="action-buttons" style="margin-top:14px;">
      <button id="returnToActionsBtn" class="primary" style="background:#666;">Return</button>
    </div>
  `;
  const returnBtn = document.getElementById('returnToActionsBtn');
  if (returnBtn) {
    returnBtn.onclick = backToActions;
  }
}

function resetGameState() {
  stopMining(); 
  stopBlacksmithing();
  game.name = '';
  game.hp = 10;
  game.maxHP = 10;
  game.inventory = new Array(game.inventoryCapacity).fill(null);
  game.gold = 0; 
  game.mining = { level: 1, xp: 0, totalXP: 0 };
  game.blacksmith = { level: 1, xp: 0, totalXP: 0 };
  game.miningActive = false;
  game.blacksmithingActive = false;
  game.shopOpen = false; 
  game.isAdmin = false;
  
  // +++ NEW: Reset session state +++
  game.isSessionActive = false;
  game.isDragging = false;
  if (typeof window.stopSessionHeartbeat === 'function') {
      window.stopSessionHeartbeat();
  }
  
  if (game.progressFrame) {
    cancelAnimationFrame(game.progressFrame);
    game.progressFrame = null;
  }
  setText('charName', 'Player');
  updateHPUI();
  renderInventoryGrid();
  updateSkillUI();
  updateGoldUI(); 
  if (typeof backToActions === 'function') {
    backToActions();
  }
  if (typeof showTab === 'function') {
    showTab('inventory'); 
  }
}

// --- MODIFIED: Added isDragging logic ---
document.addEventListener('DOMContentLoaded', ()=>{
  showTab('inventory'); 
  window.resetGameState = resetGameState;
  document.addEventListener('mousemove', moveTooltip);
  
  const inventoryGrid = document.getElementById('inventoryGrid');
  let draggedItemIndex = null;
  let currentDragOverSlot = null;
  
  inventoryGrid.addEventListener('dragstart', (e) => {
    if (e.target && e.target.classList.contains('inv-slot') && e.target.draggable) {
      draggedItemIndex = parseInt(e.target.dataset.slotIndex);
      e.dataTransfer.effectAllowed = 'move';
      
      // +++ NEW: Set dragging flag +++
      game.isDragging = true;
      
      setTimeout(() => {
        e.target.classList.add('dragging');
      }, 0);
    }
  });

  inventoryGrid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      if (currentDragOverSlot && currentDragOverSlot !== targetSlot) {
        currentDragOverSlot.classList.remove('drag-over');
      }
      targetSlot.classList.add('drag-over');
      currentDragOverSlot = targetSlot;
    }
  });
  
  inventoryGrid.addEventListener('dragleave', (e) => {
    const targetSlot = e.target.closest('.inv-slot');
    if (targetSlot) {
      targetSlot.classList.remove('drag-over');
      if (currentDragOverSlot === targetSlot) {
        currentDragOverSlot = null;
      }
    }
  });

  inventoryGrid.addEventListener('drop', (e) => {
    e.preventDefault();
    const dropSlot = e.target.closest('.inv-slot');
    if (dropSlot && draggedItemIndex !== null) {
      const dropIndex = parseInt(dropSlot.dataset.slotIndex);
      if (draggedItemIndex !== dropIndex) {
        const temp = game.inventory[draggedItemIndex];
        game.inventory[draggedItemIndex] = game.inventory[dropIndex];
        game.inventory[dropIndex] = temp;
        renderInventoryGrid();
        // +++ NEW: Save immediately after a successful drag/drop +++
        if (typeof window.savePlayerData === 'function') {
            window.savePlayerData();
        }
      }
    }
    
    // Cleanup
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    draggedItemIndex = null;
    // +++ NEW: Clear dragging flag +++
    game.isDragging = false;
  });

  inventoryGrid.addEventListener('dragend', (e) => {
    // Final cleanup
    if (currentDragOverSlot) {
      currentDragOverSlot.classList.remove('drag-over');
      currentDragOverSlot = null;
    }
    const draggingEl = document.querySelector('.inv-slot.dragging');
    if (draggingEl) {
      draggingEl.classList.remove('dragging');
    }
    draggedItemIndex = null;
    // +++ NEW: Clear dragging flag +++
    game.isDragging = false;
  });
  
});
</script>

<script type="module">
  // Firebase imports (CDN modules)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
  import {

  getFirestore, doc, setDoc, getDoc, collection, query, getDocs, where,
    addDoc, serverTimestamp, onSnapshot, orderBy, limit, limitToLast, runTransaction, writeBatch, updateDoc
    
  } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

  const ADMIN_UID = "qHclRuNSFTTrE19xYd7ilqIPFVe2";
  
  const firebaseConfig = {
    apiKey: "AIzaSyD6sIi0SbPUUjJFJsJB22xBOF7ZD0H7utw",
    authDomain: "skill-3d8e1.firebaseapp.com",
    projectId: "skill-3d8e1",
    storageBucket: "skill-3d8e1.firebasestorage.app",
    messagingSenderId: "973290752767",
    appId: "1:973290752767:web:e80faba45f8707603d9aca"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const authScreen = document.getElementById('authScreen');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const registerBtn = document.getElementById('registerBtn');
  const loginBtn = document.getElementById('loginBtn');
  const refreshLeaderboardBtn = document.getElementById('refreshLeaderboardBtn'); 

  // +++ --- NEW SESSION LOCK CONSTANTS & FUNCTIONS --- +++
  const LOCK_STALE_TIME_MS = 10000; // 10 seconds
  const LOCK_HEARTBEAT_MS = 4000;   // 4 seconds

  /**
   * (Helper) Gets the player doc ref.
   */
  function getPlayerRef() {
    const user = auth.currentUser;
    if (!user) return null;
    return doc(db, "players", user.uid);
  }

  /**
   * Shows the session lock overlay.
   */
  function showSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'flex';
  }
  
  /**
   * Hides the session lock overlay.
   */
  function hideSessionLockOverlay() {
    const overlay = document.getElementById('sessionLockOverlay');
    if (overlay) overlay.style.display = 'none';
  }

  /**
   * Starts the heartbeat to keep our session lock fresh.
   */
  window.startSessionHeartbeat = function() {
    if (game.lockHeartbeat) return; // Already running
    game.lockHeartbeat = setInterval(async () => {
      const playerRef = getPlayerRef();
      if (!playerRef || !game.isSessionActive) {
        stopSessionHeartbeat(); // Stop if we're no longer active
        return;
      }
      try {
        await updateDoc(playerRef, { "activeSession.timestamp": Date.now() });
      } catch (e) {
        console.error("Heartbeat failed:", e);
        // If it fails, the lock will become stale and another tab can take it.
        stopSessionHeartbeat();
      }
    }, LOCK_HEARTBEAT_MS);
  }

  /**
   * Stops the heartbeat.
   */
  window.stopSessionHeartbeat = function() {
    if (game.lockHeartbeat) {
      clearInterval(game.lockHeartbeat);
      game.lockHeartbeat = null;
    }
  }

  /**
   * Releases the session lock from Firebase.
   * @param {boolean} isAsync - If false, we can't wait for the update (e.g., closing tab).
   */
  window.releaseSessionLock = async function(isAsync = true) {
    stopSessionHeartbeat();
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    // We only release the lock if we are the one holding it.
    try {
      const promise = runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) return;
        const lock = snap.data().activeSession;
        if (lock && lock.id === game.sessionLockId) {
          transaction.update(playerRef, { activeSession: null });
        }
      });
      
      if (isAsync) {
        await promise;
      }
    } catch (e) {
      console.error("Failed to release lock:", e);
    }
  }
  
  /**
   * Tries to acquire the session lock using a transaction.
   * This is called when a lock is free or stale, or when user clicks "Take Control".
   */
  window.acquireSessionLock = async function() {
    const playerRef = getPlayerRef();
    if (!playerRef) return;
    
    try {
      await runTransaction(db, async (transaction) => {
        const snap = await transaction.get(playerRef);
        if (!snap.exists()) throw new Error("Player doc does not exist.");
        
        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();
        
        // Check if a fresh lock is held by another session
        if (lock && lock.id !== game.sessionLockId && (now - lock.timestamp) < LOCK_STALE_TIME_MS) {
          throw new Error("Lock is still fresh and held by another session.");
        }
        
        // Lock is free, stale, or ours. Take it.
        const newLock = { id: game.sessionLockId, timestamp: now };
        transaction.update(playerRef, { activeSession: newLock });
      });
      
      // Success! We are now the active session.
      game.isSessionActive = true;
      startSessionHeartbeat();
      hideSessionLockOverlay();
      
    } catch (e) {
      console.error("Failed to acquire lock:", e.message);
      // We failed to get the lock, another tab must have beat us.
      // The onSnapshot listener will handle showing the overlay.
    }
  }
  // +++ --- END NEW SESSION LOCK FUNCTIONS --- +++


  window.savePlayerData = async function() {
    try {
      const user = auth.currentUser;
      if (!user) return;
      
      // +++ NEW: Only the active session can save data +++
      if (!game.isSessionActive) return;
      
      const nameToSave = game.name || "";
      const inventoryToSave = [];
      game.inventory.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      
      const payload = {
        name: nameToSave,
        name_lowercase: nameToSave.toLowerCase(),
        hp: game.hp,
        maxHP: game.maxHP,
        inventory: inventoryToSave, 
        gold: game.gold, 
        mining: {
          level: game.mining.level,
          xp: game.mining.xp,
          totalXP: game.mining.totalXP 
        },
        blacksmith: {
          level: game.blacksmith.level,
          xp: game.blacksmith.xp,
          totalXP: game.blacksmith.totalXP
        },
        updatedAt: new Date().toISOString()
        // We don't save activeSession here, that's handled by the lock functions
      };
      await setDoc(doc(db, "players", user.uid), payload, { merge: true });
    } catch (e) {
      console.error("Save failed:", e);
    }
  }

  // --- HEAVILY MODIFIED: loadPlayerDataAndStart (now handles session lock) ---
  async function loadPlayerDataAndStart(user) {
    try {
      if (playerDocListener) {
        playerDocListener();
        playerDocListener = null;
      }

      const ref = doc(db, "players", user.uid);
      let isFirstLoad = true; 
      
      playerDocListener = onSnapshot(ref, (snap) => {
        
        if (!snap.exists()) {
          console.log("Player document doesn't exist, showing start screen.");
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return; 
        }

        const data = snap.data();
        const lock = data.activeSession;
        const now = Date.now();

        // --- 1. SESSION LOCK LOGIC ---
        if (!lock || (now - lock.timestamp > LOCK_STALE_TIME_MS)) {
          // Lock is free or stale. Try to acquire it.
          // We only do this if we're not *already* the active session.
          if (!game.isSessionActive) {
            acquireSessionLock();
          }
        } else if (lock.id !== game.sessionLockId) {
          // Another tab has a fresh lock. We are INACTIVE.
          game.isSessionActive = false;
          stopSessionHeartbeat();
          showSessionLockOverlay();
          // Stop any local actions immediately
          stopMining();
          stopBlacksmithing();
          if (game.inTrade) closeTradeWindow();
        } else {
          // We have the lock. We are ACTIVE.
          game.isSessionActive = true;
          hideSessionLockOverlay();
        }

        // --- 2. DATA SYNC LOGIC ---
        
        // Ignore our own "echo" saves
        if (snap.metadata.hasPendingWrites) {
          return;
        }
        
        // If we are the active tab, AND we are busy (mining, dragging, etc.),
        // do not sync data. This prevents rollbacks.
        if (game.isSessionActive && (game.miningActive || game.blacksmithingActive || game.inTrade || game.isDragging)) {
          return;
        }
        
        // If we are INACTIVE, OR we are ACTIVE and IDLE, sync the data.
        
        if (!data.name) {
          // This handles the case right after registration
          authScreen.style.display = 'none';
          startScreen.style.display = 'block'; 
          gameScreen.style.display = 'none';
          return;
        }

        game.name = data.name || game.name || "Adventurer";
        game.hp = (typeof data.hp === 'number') ? data.hp : game.hp;
        game.maxHP = (typeof data.maxHP === 'number') ? data.maxHP : game.maxHP;
        
        let loadedInventoryData = data.inventory || [];
        game.inventory = new Array(game.inventoryCapacity).fill(null);
        if (Array.isArray(loadedInventoryData)) {
            if (loadedInventoryData.length > 0 && typeof loadedInventoryData[0].slot === 'number') {
                loadedInventoryData.forEach(item => {
                    if (item && typeof item.slot === 'number' && item.slot < game.inventoryCapacity) {
                        game.inventory[item.slot] = { name: item.name, qty: item.qty };
                    }
                });
            } else if (loadedInventoryData.length > 0) {
                console.log("Migrating (buggy) array inventory...");
                for (let i = 0; i < loadedInventoryData.length && i < game.inventoryCapacity; i++) {
                    if(loadedInventoryData[i]) {
                      game.inventory[i] = { name: loadedInventoryData[i].name, qty: loadedInventoryData[i].qty };
                    }
                }
            }
        } else {
            console.log("Migrating legacy (object) inventory...");
            const entries = Object.entries(loadedInventoryData);
            for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
                game.inventory[i] = { name: entries[i][0], qty: entries[i][1] };
            }
        }
        
        game.gold = (typeof data.gold === 'number') ? data.gold : 0; 
        
        if (data.mining) {
          game.mining.level = data.mining.level || 1;
          game.mining.xp = data.mining.xp || 0;
          game.mining.totalXP = data.mining.totalXP || getTotalXPForLevel(data.mining.level - 1) + data.mining.xp || 0; 
        } else {
          game.mining = { level: 1, xp: 0, totalXP: 0 }; 
        }
        
        if (data.blacksmith) {
          game.blacksmith.level = data.blacksmith.level || 1;
          game.blacksmith.xp = data.blacksmith.xp || 0;
          game.blacksmith.totalXP = data.blacksmith.totalXP || getTotalXPForLevel(data.blacksmith.level - 1) + data.blacksmith.xp || 0; 
        } else {
          game.blacksmith = { level: 1, xp: 0, totalXP: 0 }; 
        }

        setText('charName', game.name);
        updateHPUI();
        renderInventoryGrid();
        updateSkillUI();
        updateGoldUI(); 
        
        if (isFirstLoad) {
          window.renderLeaderboards(); 
          isFirstLoad = false;         
          backToActions(); 
        }
        
        startScreen.style.display = 'none';
        authScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        
      }, (error) => {
        console.error("Player listener error:", error);
        alert("Error loading player data. Please refresh.");
      });
      
      const initialSnap = await getDoc(ref);
      if (!initialSnap.exists() || !initialSnap.data().name) {
        authScreen.style.display = 'none';
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        return false; 
      }

      return true; 
      
    } catch (e) {
      console.error("Load failed:", e);
      return false;
    }
  }

  // --- MODIFIED: Added activeSession to new doc ---
  registerBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      const uc = await createUserWithEmailAndPassword(auth, email, password);
      await setDoc(doc(db, "players", uc.user.uid), {
        name: "",
        name_lowercase: "",
        hp: 10,
        maxHP: 10,
        inventory: [],
        gold: 0, 
        mining: { level: 1, xp: 0, totalXP: 0 },
        blacksmith: { level: 1, xp: 0, totalXP: 0 }, 
        activeSession: null, // +++ ADD THIS
        createdAt: new Date().toISOString()
      });
      alert("Account created. Now create your character."); 
    } catch (err) {
      alert(err.message || "Registration failed.");
      console.error(err);
    }
  };

  loginBtn.onclick = async function() {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    if (!email || !password) return alert("Enter email and password.");
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (err) {
      alert(err.message || "Login failed."); 
      console.error(err);
    }
  };

  // --- MODIFIED: Handles session cleanup ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();

      const started = await loadPlayerDataAndStart(user);
      
      if (user.uid === ADMIN_UID) {
        game.isAdmin = true;
        console.log("Admin status granted.");
      } else {
        game.isAdmin = false;
      }
      
      if (started) {
        initChatListener();
        initTradeListeners();
        // The loadPlayerDataAndStart listener will automatically handle
        // acquiring the lock on first load.
      } else {
        startScreen.style.display = 'block';
        gameScreen.style.display = 'none';
        authScreen.style.display = 'none';
      }
    } else {
      // User is logged out
      authScreen.style.display = 'flex';
      startScreen.style.display = 'none';
      gameScreen.style.display = 'none';
      
      // Stop listeners and release lock
      if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
      tradeSessionUnsubscribes.forEach(unsub => unsub()); 
      tradeSessionUnsubscribes = []; 
      if (playerDocListener) playerDocListener();
      stopSessionHeartbeat();
      // We don't release the lock, just let it go stale.
      
      if (window.resetGameState) {
        window.resetGameState();
      }
      isTradeRequestsLoaded = false; 
    }
  });

  (function(){
    const originalCreate = window.createCharacter;
    if (typeof originalCreate === "function") {
      window.createCharacter = async function() {
        const name = document.getElementById('playerName').value.trim();
        if(!name) return alert('Enter a name first.');
        try {
          const nameLower = name.toLowerCase();
          const q = query(collection(db, "players"), where("name_lowercase", "==", nameLower));
          const querySnapshot = await getDocs(q);
          if (!querySnapshot.empty) {
            return alert("That name is already taken. Please choose another.");
          }
        } catch (e) {
          console.error("Name check failed:", e);
          return alert("Error checking name. Please try again.");
        }
        
        originalCreate();
        
        const user = auth.currentUser;
        if (user) {
          await window.savePlayerData();
          window.renderLeaderboards();
          initChatListener(); 
          initTradeListeners(); 
          // The onSnapshot listener will fire and handle the lock.
        }
      };
    }
  })();
  
  // --- CHAT FUNCTIONS (Unchanged) ---
  let isChatHistoryLoaded = false;
  let localMessageQueue = [];
  let chatListenerUnsubscribe = null;
  let isTradeRequestsLoaded = false;
  let playerDocListener = null; 

  async function sendChatMessage() {
    const chatInput = document.getElementById('chatInput');
    const messageText = chatInput.value.trim();
    const user = auth.currentUser;
    if (messageText.length === 0) return; 
    
    // +++ NEW: Prevent sending chat from inactive tab +++
    if (!game.isSessionActive) {
      alert("This tab is not active. Take control to send messages.");
      return;
    }
    
    chatInput.value = '';
    if (messageText.startsWith('/')) {
      const isCommand = await handleChatCommand(messageText);
      if (isCommand) return; 
    }
    if (messageText.length > 256) {
      alert("Message is too long (max 256 chars).");
      return;
    }
    if (!user || !game.name) {
      alert("You must be logged in and have a character to chat.");
      return;
    }
    try {
      await addDoc(collection(db, "messages"), {
        senderUid: user.uid,
        senderName: game.name,
        text: messageText,
        timestamp: serverTimestamp()
      });
    } catch (e) {
      console.error("Error sending message: ", e);
      alert("Failed to send message. Please try again.");
    }
  }
  function _addLocalMessageToDOM(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const msgElement = document.createElement('div');
    msgElement.style.marginBottom = '6px';
    msgElement.style.lineHeight = '1.3';
    msgElement.style.wordBreak = 'break-word';
    if (type === 'system') {
      msgElement.style.color = '#aaffaa'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    } else if (type === 'trade') {
      msgElement.style.color = 'var(--gold)'; 
      msgElement.style.fontWeight = 'bold';
      msgElement.textContent = text;
    } else if (type === 'error') {
      msgElement.style.color = '#ff8888'; 
      msgElement.style.fontStyle = 'italic';
      msgElement.textContent = text;
    }
    chatMessagesContainer.prepend(msgElement); 
  }
  function initChatListener() {
    if (chatListenerUnsubscribe) {
      chatListenerUnsubscribe();
      chatListenerUnsubscribe = null;
    }
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    const q = query(
      collection(db, "messages"), 
      orderBy("timestamp", "asc"),
      limitToLast(25)
    );
    chatListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
      let hasAdds = false; 
      querySnapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isChatHistoryLoaded) {
            hasAdds = true; 
            const msg = change.doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
          }
        }
      });
      if (!isChatHistoryLoaded) {
        isChatHistoryLoaded = true;
        let hadHistoryMessages = false;
        querySnapshot.docs.forEach(doc => {
            hadHistoryMessages = true;
            const msg = doc.data();
            const msgElement = document.createElement('div');
            msgElement.style.marginBottom = '6px';
            msgElement.style.lineHeight = '1.3';
            msgElement.style.wordBreak = 'break-word';
            const sender = document.createElement('strong');
            sender.style.color = 'var(--gold)'; 
            sender.textContent = msg.senderName ? `${msg.senderName}: ` : 'System: ';
            const text = document.createTextNode(msg.text);
            msgElement.appendChild(sender);
            msgElement.appendChild(text);
            chatMessagesContainer.prepend(msgElement);
        });
        let hadQueuedMessages = localMessageQueue.length > 0;
        localMessageQueue.forEach(msg => {
          _addLocalMessageToDOM(msg.text, msg.type);
        });
        localMessageQueue = []; 
        if (hadHistoryMessages || hadQueuedMessages) {
          chatMessagesContainer.scrollTop = 0;
        }
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
      } 
      else if (hasAdds) {
        while (chatMessagesContainer.childElementCount > 30) {
          chatMessagesContainer.lastChild.remove();
        }
        chatMessagesContainer.scrollTop = 0;
      }
    }, (error) => {
      console.error("Chat listener error: ", error);
      chatMessagesContainer.innerHTML = '<div style="color: red;">Error loading chat.</div>';
    });
  }
  
  // --- TRADE FUNCTIONS (Mostly Unchanged) ---
  let tradeRequestUnsubscribe = null;
  let tradeSessionUnsubscribes = []; 
  function addLocalChatMessage(text, type = 'system') {
    const chatMessagesContainer = document.getElementById('chatMessages');
    if (!chatMessagesContainer) return;
    if (!isChatHistoryLoaded) {
      localMessageQueue.push({ text, type });
    } else {
      _addLocalMessageToDOM(text, type);
      while (chatMessagesContainer.childElementCount > 30) {
        chatMessagesContainer.lastChild.remove();
      }
      chatMessagesContainer.scrollTop = 0;
    }
  }
  function convertSavedInvToLocal(savedInvData) {
      const localInv = new Array(game.inventoryCapacity).fill(null);
      if (!Array.isArray(savedInvData)) {
          const entries = Object.entries(savedInvData);
          for (let i = 0; i < entries.length && i < game.inventoryCapacity; i++) {
              localInv[i] = { name: entries[i][0], qty: entries[i][1] };
          }
      } else {
          if (savedInvData.length > 0 && typeof savedInvData[0].slot === 'number') {
              savedInvData.forEach(item => {
                  if (item && item.slot < game.inventoryCapacity) {
                      localInv[item.slot] = { name: item.name, qty: item.qty };
                  }
              });
          } else if (savedInvData.length > 0) {
              for (let i = 0; i < savedInvData.length && i < game.inventoryCapacity; i++) {
                  if (savedInvData[i]) {
                      localInv[i] = { name: savedInvData[i].name, qty: savedInvData[i].qty };
                  }
              }
          }
      }
      return localInv;
  }
  function convertLocalInvToSaved(localInv) {
      const inventoryToSave = [];
      localInv.forEach((item, index) => {
          if (item) {
              inventoryToSave.push({
                  slot: index,
                  name: item.name,
                  qty: item.qty
              });
          }
      });
      return inventoryToSave;
  }
  function checkItem(localInvArray, itemName, qty) {
      const item = localInvArray.find(slot => slot && slot.name === itemName);
      return item && item.qty >= qty;
  }
  function modifyInventory(localInvArray, itemName, qtyChange) {
      const newInv = [...localInvArray];
      let slotIndex = newInv.findIndex(slot => slot && slot.name === itemName);
      if (slotIndex > -1) {
          const newQty = newInv[slotIndex].qty + qtyChange;
          if (newQty <= 0) {
              newInv[slotIndex] = null;
          } else {
              newInv[slotIndex] = { ...newInv[slotIndex], qty: newQty };
          }
      } else if (qtyChange > 0) {
          let emptySlotIndex = newInv.findIndex(slot => slot === null);
          if (emptySlotIndex > -1) {
              newInv[emptySlotIndex] = { name: itemName, qty: qtyChange };
          } else {
              throw new Error(`Inventory full, cannot add ${itemName}.`);
          }
      }
      return newInv;
  }
  async function handleChatCommand(messageText) {
    const user = auth.currentUser;
    if (!user) return false;
    if (game.isAdmin && messageText.startsWith('/')) {
        const parts = messageText.substring(1).split(' ');
        const command = parts[0].toLowerCase();
        const args = parts.slice(1);
        if (command === 'givegold') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const amount = parseInt(args[1]);
            if (!targetName || isNaN(amount) || amount <= 0) {
                addLocalChatMessage("Usage: /givegold [playername] [amount]", 'error');
                return true;
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addGold(amount); 
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${amount} Gold.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self gold: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                const newGold = (playerData.gold || 0) + amount;
                await updateDoc(doc(db, "players", playerDoc.id), { gold: newGold });
                addLocalChatMessage(`Admin: Gave ${amount} Gold to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving gold: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'giveitem') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const qty = parseInt(args[args.length - 1]);
            const itemName = args.slice(1, -1).join(' '); 
            if (!targetName || itemName.length === 0 || isNaN(qty) || qty <= 0) {
                addLocalChatMessage("Usage: /giveitem [playername] [Item Name] [amount]", 'error');
                return true;
            }
            const formattedName = itemName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
            if (!VALID_ITEMS.includes(formattedName)) {
                addLocalChatMessage(`Admin Error: "${formattedName}" is not a valid item.`, 'error');
                return true; 
            }
            if (targetName === game.name.toLowerCase()) {
                try {
                    addItem(formattedName, qty);
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Gave self ${qty}x ${formattedName}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error giving self item: ${e.message}`, 'error');
                }
                return true;
            }
            try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                const playerData = playerDoc.data();
                let currentLocalInv = convertSavedInvToLocal(playerData.inventory || []);
                const newLocalInv = modifyInventory(currentLocalInv, formattedName, qty);
                const newSavedInv = convertLocalInvToSaved(newLocalInv);
                await updateDoc(doc(db, "players", playerDoc.id), { inventory: newSavedInv });
                addLocalChatMessage(`Admin: Gave ${qty}x ${formattedName} to ${playerData.name}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error giving item: ${e.message}`, 'error');
            }
            return true;
        }
        if (command === 'setlevel') {
            const targetName = args[0] ? args[0].toLowerCase() : '';
            const skill = args[1] ? args[1].toLowerCase() : '';
            const level = parseInt(args[2]);
            if (!targetName || !skill || isNaN(level) || level < 1 || level > 99) {
                addLocalChatMessage("Usage: /setlevel [playername] [skill] [1-99]", 'error');
                return true;
            }
            if (skill !== 'mining' && skill !== 'blacksmith') {
                 addLocalChatMessage("Unknown skill. Use 'mining' or 'blacksmith'.", 'error');
                 return true;
            }
            const newTotalXP = getTotalXPForLevel(level); 
            const newSkillData = { level: level, xp: 0, totalXP: newTotalXP };
            if (targetName === game.name.toLowerCase()) {
                try {
                    game[skill] = newSkillData; 
                    updateSkillUI();
                    await window.savePlayerData(); 
                    addLocalChatMessage(`Admin: Set own ${skill} level to ${level}.`, 'system');
                } catch (e) {
                    addLocalChatMessage(`Error setting self level: ${e.message}`, 'error');
                }
                return true;
            }
             try {
                const q = query(collection(db, "players"), where("name_lowercase", "==", targetName));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    addLocalChatMessage(`Player not found: ${args[0]}`, 'error');
                    return true;
                }
                const playerDoc = querySnapshot.docs[0];
                await updateDoc(doc(db, "players", playerDoc.id), { [skill]: newSkillData });
                addLocalChatMessage(`Admin: Set ${playerDoc.data().name}'s ${skill} level to ${level}.`, 'system');
            } catch (e) {
                addLocalChatMessage(`Error setting level: ${e.message}`, 'error');
            }
            return true;
        }
    }
    
    // +++ NEW: Check for active session before allowing trade +++
    if (!game.isSessionActive) {
      addLocalChatMessage("This tab is not active. Take control to trade.", 'error');
      return true; // It's a command, but it's blocked.
    }

    if (messageText.startsWith('/trade ')) {
      const targetName = messageText.substring(7).trim();
      if (targetName.toLowerCase() === game.name.toLowerCase()) {
        addLocalChatMessage("You cannot trade with yourself.", 'error');
        return true;
      }
      if (game.inTrade) {
        addLocalChatMessage("You are already in a trade.", 'error');
        return true;
      }
      addLocalChatMessage(`Sending trade request to ${targetName}...`, 'system');
      await initiateTradeRequest(targetName);
      return true;
    }
    if (messageText.startsWith('/accepttrade ')) {
      const requesterName = messageText.substring(13).trim(); 
      if (game.inTrade) {
        addLocalChatMessage("You are already in a trade.", 'error');
        return true;
      }
      addLocalChatMessage(`Attempting to accept trade from ${requesterName}...`, 'system');
      await acceptTradeRequest(requesterName);
      return true;
    }
    return false;
  }
  async function initiateTradeRequest(targetName) {
    try {
      const targetNameLower = targetName.toLowerCase();
      const q = query(collection(db, "players"), where("name_lowercase", "==", targetNameLower));
      const querySnapshot = await getDocs(q);
      if (querySnapshot.empty) {
        addLocalChatMessage(`Player not found: ${targetName}`, 'error');
        return;
      }
      const targetDoc = querySnapshot.docs[0];
      const targetUid = targetDoc.id;
      const targetData = targetDoc.data();
      await addDoc(collection(db, "tradeRequests"), {
        fromUid: auth.currentUser.uid,
        fromName: game.name,
        toUid: targetUid,
        toName: targetData.name,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      addLocalChatMessage(`Trade request sent to ${targetData.name}. It will expire in 60 seconds.`, 'trade');
    } catch (e) {
      console.error("Error sending trade request:", e);
      addLocalChatMessage("Error sending trade request.", 'error');
    }
  }
  async function acceptTradeRequest(requesterName) {
    try {
      const myUid = auth.currentUser.uid;
      const requesterNameLower = requesterName.toLowerCase();
      const playerQuery = query(collection(db, "players"), where("name_lowercase", "==", requesterNameLower));
      const playerSnapshot = await getDocs(playerQuery);
      if (playerSnapshot.empty) {
        addLocalChatMessage(`Player not found: ${requesterName}`, 'error');
        return;
      }
      const requesterUid = playerSnapshot.docs[0].id;
      const requesterData = playerSnapshot.docs[0].data();
      const requestQuery = query(
        collection(db, "tradeRequests"),
        where("toUid", "==", myUid),
        where("status", "==", "pending")
      );
      const requestSnapshot = await getDocs(requestQuery);
      const validRequests = requestSnapshot.docs.filter(doc => {
          const data = doc.data();
          return data.fromUid === requesterUid; 
      });
      if (validRequests.length === 0) {
        addLocalChatMessage(`No pending trade request found from ${requesterData.name}. It may have expired.`, 'error');
        return;
      }
      const requestDoc = validRequests[0]; 
      const tradeSessionRef = doc(collection(db, "tradeSessions"));
      const tradeSessionData = {
        status: 'active',
        createdAt: serverTimestamp(),
        player1: {
          uid: requesterUid,
          name: requesterData.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        },
        player2: {
          uid: myUid,
          name: game.name,
          offerItems: {},
          offerGold: 0,
          accepted: false
        }
      };
      const batch = writeBatch(db);
      batch.set(tradeSessionRef, tradeSessionData);
      batch.update(requestDoc.ref, { status: 'accepted', sessionId: tradeSessionRef.id });
      await batch.commit();
    } catch (e) {
      console.error("Error accepting trade:", e);
      addLocalChatMessage("Error accepting trade. Are they busy?", 'error');
    }
  }
  function initTradeListeners() {
    const myUid = auth.currentUser.uid;
    if (!myUid) return;
    if (tradeRequestUnsubscribe) tradeRequestUnsubscribe();
    tradeSessionUnsubscribes.forEach(unsub => unsub()); 
    tradeSessionUnsubscribes = []; 
    isTradeRequestsLoaded = false; 
    const requestQuery = query(
      collection(db, "tradeRequests"),
      where("toUid", "==", myUid),
      where("status", "==", "pending")
    );
    tradeRequestUnsubscribe = onSnapshot(requestQuery, (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          if (isTradeRequestsLoaded) {
            const request = change.doc.data();
            addLocalChatMessage(
              `${request.fromName} sent you a trade request. Type '/accepttrade ${request.fromName}' to accept.`,
              'trade'
            );
          }
        }
      });
      isTradeRequestsLoaded = true;
    }, (error) => console.error("Trade request listener error:", error));
    const sessionQuery1 = query(
      collection(db, "tradeSessions"),
      where("player1.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const sessionQuery2 = query(
      collection(db, "tradeSessions"),
      where("player2.uid", "==", myUid),
      where("status", "in", ["active", "cancelled"]) 
    );
    const handleSessionStart = (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const sessionData = change.doc.data();
        const sessionId = change.doc.id;
        if (change.type === "added" && sessionData.status === "active" && !game.inTrade) {
          openTradeWindow(sessionId, sessionData);
        } 
        else if (change.type === "modified" && sessionData.status === "cancelled" && game.inTrade) {
          if (sessionId === game.activeTradeSessionId) {
            addLocalChatMessage(`Trade was cancelled.`, 'trade');
            closeTradeWindow();
          }
        }
      });
    };
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery1, handleSessionStart, (e) => console.error("Session listener 1:", e))
    );
    tradeSessionUnsubscribes.push( 
      onSnapshot(sessionQuery2, handleSessionStart, (e) => console.error("Session listener 2:", e))
    );
  }
  function openTradeWindow(sessionId, sessionData) {
    if (game.inTrade) return; 
    if (game.miningActive) {
      stopMining();
      game.wasMiningBeforeTrade = true;
    }
    if (game.blacksmithingActive) {
        stopBlacksmithing();
        game.wasMiningBeforeTrade = true; 
    }
    game.inTrade = true;
    game.activeTradeSessionId = sessionId;
    
    const myUid = auth.currentUser.uid;
    const myRole = (sessionData.player1.uid === myUid) ? 'player1' : 'player2';
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    
    // --- THIS IS THE FIX ---
    // Use the session data to initialize the trade state
    game.myTradeOffer = sessionData[myRole];
    game.theirTradeOffer = sessionData[theirRole];
    // --- END FIX ---
    
    game.myTradeRole = myRole; 

    const modal = document.getElementById('tradeModal');
    setText('tradePartnerName', sessionData[theirRole].name);
    setText('tradeMyGold', formatAmount(game.gold));
    
    // Set the gold input to the *correct* initial value
    document.getElementById('tradeMyGoldOffer').value = game.myTradeOffer.offerGold;
    document.getElementById('tradeMyGoldOffer').max = game.gold;
    
    renderTradeInventory(); 
    // Render the grids with the data we just loaded
    renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); 
    renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems); 
    modal.style.display = 'flex'; 
    if (game.activeTradeListener) game.activeTradeListener(); 
    game.activeTradeListener = onSnapshot(doc(db, "tradeSessions", sessionId), (doc) => {
      if (!doc.exists()) {
        closeTradeWindow();
        addLocalChatMessage("Trade session was deleted.", 'error');
        return;
      }
      const data = doc.data();
      if (data.status === 'cancelled') {
        const errorMsg = data.errorMessage ? `: ${data.errorMessage}` : '.';
        addLocalChatMessage(`Trade was cancelled${errorMsg}`, 'trade');
        closeTradeWindow();
        return;
      }
      if (data.status === 'completed') {
        addLocalChatMessage("Trade complete!", 'trade');
        closeTradeWindow();
        return;
      }
      game.theirTradeOffer = data[theirRole];
      
      // Manually sync our own "accepted" status
      // This is the ONLY part of our offer we want from the server
      game.myTradeOffer.accepted = data[myRole].accepted;

      // Render grids based on our local (for us) and synced (for them) data
      renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems);
      renderOfferGrid('tradeTheirOfferGrid', game.theirTradeOffer.offerItems);
      
      // We no longer need to check if we're typing, because we are
      // no longer syncing our own gold value from the server.
      
      // ONLY set THEIR gold display
      setText('tradeTheirGoldOffer', formatAmount(game.theirTradeOffer.offerGold));
      
      // Update statuses for both
      updateTradeAcceptStatus('myTradeStatus', game.myTradeOffer.accepted);
      updateTradeAcceptStatus('theirTradeStatus', game.theirTradeOffer.accepted);
      // --- END FIX ---
      if (game.myTradeOffer.accepted && game.theirTradeOffer.accepted) {
        document.getElementById('tradeAcceptBtn').disabled = true;
        document.getElementById('tradeCancelBtn').disabled = true;
        if (myRole === 'player1') {
          executeTrade(sessionId, data);
        }
      } else {
         document.getElementById('tradeAcceptBtn').disabled = false;
         document.getElementById('tradeCancelBtn').disabled = false;
      }
    });
    document.getElementById('tradeCancelBtn').onclick = cancelTrade;
    document.getElementById('tradeAcceptBtn').onclick = setTradeAccepted;
    document.getElementById('tradeMyGoldOffer').onchange = updateMyGoldOffer;
  }
  function renderTradeInventory() {
    const grid = document.getElementById('tradeInventoryGrid');
    grid.innerHTML = '';
    game.inventory.forEach(slot => {
      if (!slot) return; 
      const name = slot.name;
      const qty = slot.qty;
      const itemInOffer = game.myTradeOffer.offerItems[name] || 0;
      const qtyAvailable = qty - itemInOffer;
      if (qtyAvailable <= 0) return; 
      const slotEl = document.createElement('div');
      slotEl.className = 'inv-slot';
      slotEl.onclick = () => addItemToOffer(name, qtyAvailable); 
      let imgName = name.toLowerCase().replace(/\s+/g,'_');
      if (name === 'Copper Bar') {
          imgName = 'copperbar';
      }
      const img = document.createElement('img');
      img.src = `images/${imgName}.png`;
      img.alt = name;
      slotEl.appendChild(img);
      const amt = document.createElement('div');
      amt.className = 'inv-amount';
      amt.innerText = formatAmount(qtyAvailable);
      slotEl.appendChild(amt);
      const tooltipContent = `
        <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
        <div>Amount: ${qtyAvailable.toLocaleString()}</div>
        <div style="color:#aaffaa; margin-top: 5px;">Click to offer...</div>
      `;
      slotEl.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
      slotEl.onmouseleave = hideTooltip;
      grid.appendChild(slotEl);
    });
  }
  function renderOfferGrid(gridId, items) {
    const grid = document.getElementById(gridId);
    const isMyOffer = (gridId === 'tradeMyOfferGrid');
    grid.innerHTML = '';
    const itemEntries = Object.entries(items);
    for (let i = 0; i < 16; i++) {
      const slot = document.createElement('div');
      if (itemEntries[i]) {
        const [name, qty] = itemEntries[i];
        slot.className = 'inv-slot';
        if (isMyOffer) {
          slot.onclick = () => removeItemFromOffer(name);
        }
        const img = document.createElement('img');
        let imgName = name.toLowerCase().replace(/\s+/g,'_');
        if (name === 'Copper Bar') {
            imgName = 'copperbar';
        }
        img.src = `images/${imgName}.png`;
        img.alt = name;
        slot.appendChild(img);
        const amt = document.createElement('div');
        amt.className = 'inv-amount';
        amt.innerText = formatAmount(qty);
        slot.appendChild(amt);
        const tooltipContent = `
          <div style="font-weight:bold; color:var(--gold); margin-bottom:4px;">${name}</div>
          <div>Amount: ${qty.toLocaleString()}</div>
          ${isMyOffer ? '<div style="color:#ffaaaa; margin-top: 5px;">Click to remove...</div>' : ''}
        `;
        slot.onmouseenter = (evt) => showTooltip(evt, tooltipContent);
        slot.onmouseleave = hideTooltip;
      } else {
        slot.className = 'inv-slot offer-slot-placeholder';
      }
      grid.appendChild(slot);
    }
  }
  function updateTradeAcceptStatus(elementId, isAccepted) {
    const el = document.getElementById(elementId);
    if (isAccepted) {
      el.textContent = 'Accepted';
      el.classList.add('accepted');
    } else {
      el.textContent = 'Not Accepted';
      el.classList.remove('accepted');
    }
  }
  async function addItemToOffer(itemName, maxQty) {
    const currentOfferQty = game.myTradeOffer.offerItems[itemName] || 0;
    let qtyToOffer = 0;
    if (maxQty === 1) {
      qtyToOffer = 1;
    } else {
      const input = prompt(`How many ${itemName} do you want to offer? (Max: ${maxQty})`, maxQty);
      if (input === null) return; 
      qtyToOffer = parseInt(input);
    }
    if (isNaN(qtyToOffer) || qtyToOffer <= 0) return;
    if (qtyToOffer > maxQty) {
      alert(`You can only offer up to ${maxQty} of this item.`);
      qtyToOffer = maxQty;
    }
    const offerItemCount = Object.keys(game.myTradeOffer.offerItems).length;
    if (!game.myTradeOffer.offerItems[itemName] && offerItemCount >= 16) {
      alert("Your trade offer grid is full (16 unique items).");
      return;
    }
    const newOfferItems = { ...game.myTradeOffer.offerItems };
    newOfferItems[itemName] = (newOfferItems[itemName] || 0) + qtyToOffer;
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    
    // 1. Create the new offer
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    
    // 2. Create the payload
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;

    // 3. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 4. Update Firebase and render UI
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      renderTradeInventory(); 
      renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); // Re-render our offer grid
    } catch (e) {
      console.error("Error updating offer:", e);
      addLocalChatMessage("Error updating offer.", 'error');
    }
  }
  async function removeItemFromOffer(itemName) {
    const newOfferItems = { ...game.myTradeOffer.offerItems }; 
    delete newOfferItems[itemName]; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerItems: newOfferItems,
        accepted: false
    };
    
    // 2. Create the payload
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;

    // 3. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;

    // 4. Update Firebase and render UI
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      renderTradeInventory(); 
      renderOfferGrid('tradeMyOfferGrid', game.myTradeOffer.offerItems); // Re-render our offer grid
    } catch (e) {
      console.error("Error updating offer:", e);
    }
  }
  async function updateMyGoldOffer(event) {
    let gold = parseInt(event.target.value);
    if (isNaN(gold) || gold < 0) gold = 0;
    if (gold > game.gold) {
      gold = game.gold;
      event.target.value = gold;
    }
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        offerGold: gold,
        accepted: false
    };

    // 2. Create the payload
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 
    const theirRole = (myRole === 'player1') ? 'player2' : 'player1';
    updatePayload[`${theirRole}.accepted`] = false;
    
    // 3. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;

    // 4. Update Firebase
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      // No UI render needed here, the input field already has the value
    } catch (e) {
      console.error("Error updating gold offer:", e);
    }
  }
  async function setTradeAccepted() {
    document.getElementById('tradeAcceptBtn').disabled = true; 
    const myRole = game.myTradeRole;
    if (!myRole) return; 
    const newOfferObject = {
        ...game.myTradeOffer,
        accepted: true 
    };
    
    // 2. Create the payload
    const updatePayload = {};
    updatePayload[myRole] = newOfferObject; 

    // 3. Update local state IMMEDIATELY
    game.myTradeOffer = newOfferObject;
    
    // 4. Update Firebase
    try {
      await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), updatePayload);
      // The snapshot listener will handle the UI update for the "Accepted" text
    } catch (e) {
      console.error("Error accepting trade:", e);
      document.getElementById('tradeAcceptBtn').disabled = false;
    }
  }
  async function cancelTrade() {
    document.getElementById('tradeCancelBtn').disabled = true;
    document.getElementById('tradeAcceptBtn').disabled = true;
    const sessionId = game.activeTradeSessionId;
    closeTradeWindow(); 
    if (sessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", sessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.error("Error updating cancelled trade:", e);
      }
    }
  }
  function closeTradeWindow() {
    if (!game.inTrade) return; 
    if (game.activeTradeListener) {
      game.activeTradeListener(); 
      game.activeTradeListener = null;
    }
    game.inTrade = false;
    game.activeTradeSessionId = null;
    game.myTradeRole = null; 
    game.myTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    game.theirTradeOffer = { offerItems: {}, offerGold: 0, accepted: false };
    document.getElementById('tradeModal').style.display = 'none';
    hideTooltip();
    renderInventoryGrid();
    updateGoldUI();
    if (game.wasMiningBeforeTrade) {
      game.wasMiningBeforeTrade = false;
      const startBtn = document.getElementById('startMineBtn');
      const startSmithBtn = document.getElementById('startSmithBtn');
      if (startBtn) {
        startMining();
      } else if (startSmithBtn) { 
        startBlacksmithing();
      }
    }
  }
  async function executeTrade(sessionId, sessionData) {
    try {
      await runTransaction(db, async (transaction) => {
        const sessionRef = doc(db, "tradeSessions", sessionId);
        const player1Ref = doc(db, "players", sessionData.player1.uid);
        const player2Ref = doc(db, "players", sessionData.player2.uid);
        const [sessionSnap, p1Snap, p2Snap] = await Promise.all([
          transaction.get(sessionRef),
          transaction.get(player1Ref),
          transaction.get(player2Ref)
        ]);
        if (!sessionSnap.exists() || !p1Snap.exists() || !p2Snap.exists()) {
          throw new Error("A player or session does not exist.");
        }
        const trade = sessionSnap.data();
        const p1Data = p1Snap.data();
        const p2Data = p2Snap.data();
        if (trade.status !== 'active') {
          throw new Error("Trade is no longer active.");
        }
        if (!trade.player1.accepted || !trade.player2.accepted) {
          throw new Error("Both players have not accepted.");
        }
        const p1Offer = trade.player1;
        const p2Offer = trade.player2;
        const p1LocalInv = convertSavedInvToLocal(p1Data.inventory || []);
        const p2LocalInv = convertSavedInvToLocal(p2Data.inventory || []);
        if (p1Data.gold < p1Offer.offerGold) throw new Error(`${p1Data.name} does not have enough gold.`);
        if (p2Data.gold < p2Offer.offerGold) throw new Error(`${p2Data.name} does not have enough gold.`);
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
          if (!checkItem(p1LocalInv, item, qty)) {
            throw new Error(`${p1Data.name} does not have ${qty} ${item}.`);
          }
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
          if (!checkItem(p2LocalInv, item, qty)) {
            throw new Error(`${p2Data.name} does not have ${qty} ${item}.`);
          }
        }
        let newP1LocalInv = [...p1LocalInv];
        let newP2LocalInv = [...p2LocalInv];
        for (const [item, qty] of Object.entries(p1Offer.offerItems)) {
            newP1LocalInv = modifyInventory(newP1LocalInv, item, -qty);
            newP2LocalInv = modifyInventory(newP2LocalInv, item, +qty);
        }
        for (const [item, qty] of Object.entries(p2Offer.offerItems)) {
            newP2LocalInv = modifyInventory(newP2LocalInv, item, -qty);
            newP1LocalInv = modifyInventory(newP1LocalInv, item, +qty);
        }
        const newP1SavedInv = convertLocalInvToSaved(newP1LocalInv);
        const newP2SavedInv = convertLocalInvToSaved(newP2LocalInv);
        transaction.update(sessionRef, { status: 'completed' });
        transaction.update(player1Ref, {
            gold: p1Data.gold - p1Offer.offerGold + p2Offer.offerGold,
            inventory: newP1SavedInv
        });
        transaction.update(player2Ref, {
            gold: p2Data.gold - p2Offer.offerGold + p1Offer.offerGold,
            inventory: newP2SavedInv
        });
      });
    } catch (e) {
      console.error("TRADE FAILED:", e);
      await updateDoc(doc(db, "tradeSessions", sessionId), { 
        status: 'cancelled',
        errorMessage: e.message
      });
    }
  }

  // --- LEADERBOARD FUNCTION (Unchanged) ---
  window.renderLeaderboards = async function() {
    const contentContainer = document.getElementById('leaderboardContent'); 
    if (!contentContainer) return;
    contentContainer.innerHTML = `
      <div style="text-align:center; margin-top: 20px; color: #fff; opacity: 0.7;">Refreshing...</div>
    `;
    try {
      const playersCol = collection(db, "players");
      const q = query(playersCol);
      const querySnapshot = await getDocs(q);
      let players = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        if (!data.name || data.name === "") return;
        const miningXp = data.mining?.totalXP || 0; 
        const blacksmithXp = data.blacksmith?.totalXP || 0;
        const totalXp = miningXp + blacksmithXp;
        players.push({
          name: data.name,
          totalXp: totalXp,
        });
      });
      players.sort((a, b) => b.totalXp - a.totalXp);
      let leaderboardHtml = '';
      players.slice(0, 10).forEach((player, index) => {
        const rank = index + 1;
        const xpFormatted = player.totalXp.toLocaleString();
        const isCurrentPlayer = (auth.currentUser && game.name === player.name); 
        leaderboardHtml += `
          <div style="display: flex; justify-content: space-between; padding: 2px 10px; border-bottom: 1px dashed rgba(255,255,255,0.1); background: ${isCurrentPlayer ? 'rgba(181, 166, 66, 0.1)' : 'transparent'};">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="width: 20px; text-align: right; font-weight: bold; color: ${rank <= 3 ? 'var(--gold)' : '#fff'};">${rank}.</span>
              <span>${xpFormatted}</span>
            </div>
            <span>${player.name}</span>
          </div>
        `;
      });
      if(players.length === 0){
        leaderboardHtml += `<div style="text-align:center; padding: 20px; opacity: 0.7;">No players found. Start playing to get on the board!</div>`;
      }
      contentContainer.innerHTML = leaderboardHtml;
    } catch (e) {
      console.error("Failed to load leaderboards:", e);
      contentContainer.innerHTML = `<div style="text-align:center; margin-top: 0px; color: red;">Failed to load data.</div>`;
    }
  }
  
  // --- MODIFIED: Added Session Lock Button ---
  document.addEventListener('DOMContentLoaded', () => {
    if (refreshLeaderboardBtn) {
        refreshLeaderboardBtn.onclick = async () => {
          if (typeof window.savePlayerData === 'function') {
            await window.savePlayerData();
          }
          window.renderLeaderboards();
        };
    }
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatInput = document.getElementById('chatInput');
    if (chatSendBtn) {
      chatSendBtn.onclick = sendChatMessage;
    }
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); 
          sendChatMessage();
        }
      });
    }
    
    // +++ NEW: Session Lock Button +++
    const takeControlBtn = document.getElementById('takeControlButton');
    if (takeControlBtn) {
      takeControlBtn.onclick = () => {
        if (typeof window.acquireSessionLock === 'function') {
          window.acquireSessionLock();
        }
      };
    }
  });

  // --- MODIFIED: Autosave only runs on active, visible tab ---
  setInterval(() => {
    const user = auth.currentUser;
    // Only save if this is the active session and the tab is visible
    if (user && game.isSessionActive && !document.hidden && !game.inTrade) {
      window.savePlayerData();
    }
  }, 30000);

  // --- MODIFIED: Releases session lock on tab close ---
  window.addEventListener('beforeunload', (e) => {
    try {
      // If we are the active session, release the lock
      if (game.isSessionActive) {
        if (typeof window.releaseSessionLock === 'function') {
          // Fire-and-forget, we can't await this
          window.releaseSessionLock(false); 
        }
      }
      
      // Try one last save
      const user = auth.currentUser;
      if (user && game.isSessionActive && !game.inTrade) {
        window.savePlayerData();
      }
    } catch (err) { /* ignore */ }
  });

  // --- MODIFIED: Releases session lock on logout ---
  window.firebaseLogout = async function() {
  try {
    // 1. If in trade, cancel it first (Existing logic)
    if (game.inTrade && game.activeTradeSessionId) {
      try {
        await updateDoc(doc(db, "tradeSessions", game.activeTradeSessionId), {
          status: 'cancelled'
        });
      } catch (e) {
        console.warn("Could not cancel active trade on logout:", e);
      }
      closeTradeWindow();
    }
    
    // 2. +++ NEW CRITICAL FIX +++: Release the session lock explicitly
    if (game.isSessionActive) {
      if (typeof window.releaseSessionLock === 'function') {
        // Await the lock release before doing anything else
        await window.releaseSessionLock(true);
      }
    }
    stopSessionHeartbeat();
    
    // 3. Save, then sign out
    await window.savePlayerData();
    await signOut(auth);
    
    alert("Logged out."); 
  } catch (e) {
    console.error("Logout failed:", e);
    alert("Logout failed. Please try again or close your browser.");
  }
};
</script>
</body>
</html>